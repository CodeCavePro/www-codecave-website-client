{"version":3,"file":"c2b82a6e-a01fdfd2dc0fd769559c.js","mappings":"qKA8BWA,E,kQACX,SAAWA,GAEPA,EAAyBA,EAA6C,mBAAI,GAAK,qBAE/EA,EAAyBA,EAAuC,aAAI,GAAK,eAEzEA,EAAyBA,EAAqC,WAAI,GAAK,YAC1E,CAPD,CAOGA,IAA6BA,EAA2B,CAAC,IAKrD,MAAMC,UAAc,IAMvBC,8BAA8BC,GAC1B,MAAM,OAAY,mBACtB,CAKAD,qCACI,MAAM,OAAY,8BACtB,CAMIE,yBACA,OAAOC,KAAKC,mBAChB,CAMIF,uBAAmBG,GACfF,KAAKC,sBAAwBC,IAGjCF,KAAKC,oBAAsBC,EAC3BF,KAAKG,wBAAwB,GACjC,CASIC,mCACA,OAAOJ,KAAKK,6BAChB,CAIIC,0BACA,OAAON,KAAKO,oBAChB,CACID,wBAAoBJ,GACpB,GAAIA,IAAUF,KAAKO,qBAAnB,CAIA,OADAP,KAAKO,qBAAuBL,EACpBA,GACJ,KAAKP,EAAyBa,mBAC1BR,KAAKS,qBAAsB,EAC3BT,KAAKU,kBAAkBC,4BAA6B,EACpDX,KAAKY,wBAAyB,EAC9BZ,KAAKa,WAAY,EACjB,MACJ,KAAKlB,EAAyBmB,aAC1Bd,KAAKS,qBAAsB,EAC3BT,KAAKU,kBAAkBC,4BAA6B,EACpDX,KAAKY,wBAAyB,EAC9BZ,KAAKa,WAAY,EACjB,MACJ,KAAKlB,EAAyBoB,WAC1Bf,KAAKS,qBAAsB,EAC3BT,KAAKU,kBAAkBC,4BAA6B,EACpDX,KAAKY,wBAAyB,EAC9BZ,KAAKa,WAAY,EAGzBb,KAAKgB,4CAA4CC,gBAAgBf,EAtBjE,CAuBJ,CAIIgB,mBAAehB,GACXF,KAAKmB,kBAAoBjB,IAG7BF,KAAKmB,gBAAkBjB,EACvBF,KAAKG,wBAAwB,IACjC,CACIe,qBACA,OAAOlB,KAAKmB,eAChB,CAIIV,wBAAoBP,GAChBF,KAAKoB,uBAAyBlB,IAGlCF,KAAKoB,qBAAuBlB,EAChC,CACIO,0BACA,OAAOT,KAAKoB,oBAChB,CAIIC,qBAAiBnB,GACbF,KAAKsB,oBAAsBpB,IAG/BF,KAAKsB,kBAAoBpB,EACzBF,KAAKG,wBAAwB,IACjC,CACIkB,uBACA,OAAOrB,KAAKsB,iBAChB,CAIIC,kCACA,OAAOvB,KAAKwB,4BAChB,CACID,gCAA4BrB,GAC5BF,KAAKwB,6BAA+BtB,CACxC,CAEIuB,cAAUC,GACN1B,KAAK2B,oBACL3B,KAAK4B,oBAAoBC,OAAO7B,KAAK2B,oBAEzC3B,KAAK2B,mBAAqB3B,KAAK4B,oBAAoBE,IAAIJ,EAC3D,CAEIK,iBAAaL,GACT1B,KAAKgC,yBACLhC,KAAKiC,yBAAyBJ,OAAO7B,KAAKgC,yBAE1CN,IACA1B,KAAKgC,wBAA0BhC,KAAKiC,yBAAyBH,IAAIJ,GAEzE,CAEIQ,gBAAYR,GACR1B,KAAKmC,wBACLnC,KAAKoC,wBAAwBP,OAAO7B,KAAKmC,wBAEzCT,IACA1B,KAAKmC,uBAAyBnC,KAAKoC,wBAAwBN,IAAIJ,GAEvE,CAEIW,uBAAmBX,GACf1B,KAAKsC,+BACLtC,KAAKuC,+BAA+BV,OAAO7B,KAAKsC,+BAEpDtC,KAAKsC,8BAAgCtC,KAAKuC,+BAA+BT,IAAIJ,EACjF,CAEIc,sBAAkBd,GACd1B,KAAKyC,8BACLzC,KAAK0C,8BAA8Bb,OAAO7B,KAAKyC,8BAEnDzC,KAAKyC,6BAA+BzC,KAAK0C,8BAA8BZ,IAAIJ,EAC/E,CAIIiB,0BACA,OAAO3C,KAAK4C,cAAcD,mBAC9B,CAIWE,mCACP,OAAO,yBACX,CACWA,iCAAsB3C,GAC7B,0BAAqCA,CACzC,CAIW4C,4BACP,OAAO,kBACX,CACWA,0BAAe5C,GACtB,mBAA8BA,CAClC,CAIW6C,8BACP,OAAO,oBACX,CACWA,4BAAiB7C,GACxB,qBAAgCA,CACpC,CAEW8C,sCACP,OAAO,4BACX,CACWA,oCAAyB9C,GAChC,6BAAwCA,CAC5C,CAQA+C,gBAAgBC,EAAQC,EAAe,eAAgBC,GAAY,GAC/D,IAAIC,EACJ,MAAMC,EAActD,KAAKuD,oBACnBvD,KAAKuD,oBACLvD,KAAKwD,wBACDxD,KAAKwD,wBACuC,QAA3CH,EAAKrD,KAAKyD,aAAaC,sBAAmC,IAAPL,EAAgBA,EAAKrD,KAAKyD,aAAaE,eAC/FC,EAAe5D,KAAK6D,wBAA0D,MAAhC7D,KAAKwD,yBAUzD,OATA,oBAA0BF,EAAYQ,EAAGR,EAAYS,EAAGT,EAAYU,EAAGJ,GAAgB,EAAI,GACvFV,IACIE,EACAF,EAAOe,UAAUd,EAAc,kBAAyB,kBAAyB,mBAGjFD,EAAOgB,WAAWf,EAAc,kBAGjC,eACX,CAKAgB,mBACI,MAAMC,EAAMpE,KAAKqE,wBACXf,EAActD,KAAKiD,gBAAgB,MAGzC,OAFAmB,EAAIE,aAAa,eAAgBhB,EAAYQ,EAAGR,EAAYS,EAAGT,EAAYU,EAAGV,EAAYiB,GAC1FH,EAAII,SACGJ,CACX,CAIIP,yBAAqB3D,GACjBF,KAAKyE,wBAA0BvE,IAGnCF,KAAKyE,sBAAwBvE,EAC7BF,KAAKG,wBAAwB,IACjC,CACI0D,2BACA,OAAO7D,KAAKyE,qBAChB,CAMAC,UAAUC,GACN3E,KAAK4E,eAAiBD,CAC1B,CAMAE,YACI,OAAO7E,KAAK4E,cAChB,CAMAE,kBACI,OAAO9E,KAAK+E,oBAChB,CAMIC,eAAW9E,GACPF,KAAKiF,cAAgB/E,IAGzBF,KAAKiF,YAAc/E,EACnBF,KAAKG,wBAAwB,IACjC,CACI6E,iBACA,OAAOhF,KAAKiF,WAChB,CAWIC,YAAQhF,GACJF,KAAKmF,WAAajF,IAGtBF,KAAKmF,SAAWjF,EAChBF,KAAKG,wBAAwB,IACjC,CACI+E,cACA,OAAOlF,KAAKmF,QAChB,CAIIC,cACA,QAASpF,KAAKqF,iBAAmBrF,KAAKqF,gBAAgBC,UAAUC,OACpE,CAIIC,mBAAetF,GACXF,KAAKyF,kBAAoBvF,IAG7BF,KAAKyF,gBAAkBvF,EACvBF,KAAKG,wBAAwB,GACjC,CACIqF,qBACA,OAAOxF,KAAKyF,eAChB,CAIIC,kBAAcxF,GACVF,KAAK2F,iBAAmBzF,IAG5BF,KAAK2F,eAAiBzF,EACtBF,KAAKG,wBAAwB,GACjC,CACIuF,oBACA,OAAO1F,KAAK2F,cAChB,CAEIC,oBACA,OAAO5F,KAAK6F,cAChB,CACID,kBAAcE,GACV9F,KAAK+F,0BACL/F,KAAK+F,0BACL/F,KAAK+F,wBAA0B,MAE/BD,IACA9F,KAAK+F,yBAA0B,OAAcD,GAAS,KAClD9F,KAAKgG,uBAAuB/E,gBAAgBjB,KAAK,KAGzDA,KAAK6F,eAAiBC,CAC1B,CAEIrC,mBACA,OAAOzD,KAAKiG,aAChB,CACIxC,iBAAavD,GACTA,IAAUF,KAAKiG,gBAGnBjG,KAAKiG,cAAgB/F,EACrBF,KAAKkG,sBAAsBjF,gBAAgBjB,MAC/C,CAEImG,sBAIA,OAHKnG,KAAKoG,mBACNpG,KAAKoG,iBAAmBxG,EAAMyG,uBAAuBrG,OAElDA,KAAKoG,gBAChB,CAEID,oBAAgBjG,GAChBF,KAAKoG,iBAAmBlG,CAC5B,CAIIoG,oBAAgBpG,GACZF,KAAKuG,mBAAqBrG,IAG9BF,KAAKuG,iBAAmBrG,EACxBF,KAAKG,wBAAwB,GACjC,CACImG,sBACA,OAAOtG,KAAKuG,gBAChB,CAIIC,qBAAiBtG,GACbF,KAAKyG,oBAAsBvG,IAG/BF,KAAKyG,kBAAoBvG,EACzBF,KAAKG,wBAAwB,GACjC,CACIqG,uBACA,OAAOxG,KAAKyG,iBAChB,CAEIC,2BAKA,OAJK1G,KAAK2G,wBACN3G,KAAK2G,sBAAwB/G,EAAMgH,8BACnC5G,KAAK2G,sBAAsBE,KAAK7G,OAE7BA,KAAK2G,qBAChB,CAIIG,uBACA,OAAO9G,KAAKU,iBAChB,CAIIqG,oBACA,OAAO/G,KAAKgH,cAChB,CAIAC,+BAEI,GAAIjH,KAAKkH,qBAAqBC,OAAS,EAAG,CACtC,IAAK,MAAMC,KAAapH,KAAKkH,qBACzBE,EAAUC,WAEdrH,KAAKkH,qBAAqBC,OAAS,CACvC,CACJ,CAQAG,cAAcF,GACVpH,KAAKuH,YAAYC,KAAKJ,GACtBpH,KAAKkH,qBAAqBM,KAAKJ,GAC/B,MAAMK,EAAwBL,EAC1BK,EAAsBC,kBAAoBD,EAAsBE,WAChE3H,KAAK4H,wBAAwBJ,KAAKC,EAE1C,CAOAI,cAAcC,GACV,IAAK,MAAMV,KAAapH,KAAKuH,YACzB,GAAIH,EAAUU,OAASA,EACnB,OAAOV,EAGf,OAAO,IACX,CAMAW,YAAYC,EAAQC,GAChBC,QAGAlI,KAAK4C,cAAgB,IAAI,IAAa5C,MAEtCA,KAAKmI,uBAAyB,KAE9BnI,KAAKoI,UAAW,EAEhBpI,KAAKqI,wBAAyB,EAI9BrI,KAAKa,WAAY,EAIjBb,KAAKsI,0BAA2B,EAIhCtI,KAAKuI,WAAa,IAAI,KAAO,GAAK,GAAK,GAAK,GAI5CvI,KAAKwI,aAAe,IAAI,KAAO,EAAG,EAAG,GAOrCxI,KAAKyI,qBAAuB,EAC5BzI,KAAKO,qBAAuBZ,EAAyBa,mBAIrDR,KAAKgB,4CAA8C,IAAI,KACvDhB,KAAKmB,iBAAkB,EACvBnB,KAAKoB,sBAAuB,EAC5BpB,KAAKsB,mBAAoB,EAIzBtB,KAAK0I,mBAAoB,EACzB1I,KAAKwB,6BAA+B,KAKpCxB,KAAK2I,+BAAgC,EAKrC3I,KAAK4I,kCAAmC,EAIxC5I,KAAK6I,YAAc,UAInB7I,KAAK8I,cAAgB,GAIrB9I,KAAK+I,oBAAqB,EAK1B/I,KAAKgJ,6BAA8B,EAKnChJ,KAAKiJ,2BAA4B,EAKjCjJ,KAAKkJ,SAAW,KAIhBlJ,KAAKmJ,kBAAoB,KAIzBnJ,KAAKoJ,oCAAsC,IAAIC,MAI/CrJ,KAAK4B,oBAAsB,IAAI,KAC/B5B,KAAK2B,mBAAqB,KAI1B3B,KAAKiC,yBAA2B,IAAI,KACpCjC,KAAKgC,wBAA0B,KAI/BhC,KAAKoC,wBAA0B,IAAI,KAKnCpC,KAAKsJ,8BAAgC,IAAI,KACzCtJ,KAAKmC,uBAAyB,KAI9BnC,KAAKuJ,6BAA+B,IAAI,KAIxCvJ,KAAKwJ,4BAA8B,IAAI,KAIvCxJ,KAAKyJ,4BAA8B,IAAI,KAIvCzJ,KAAK0J,2BAA6B,IAAI,KAItC1J,KAAK2J,kBAAoB,IAAI,KAI7B3J,KAAKuC,+BAAiC,IAAI,KAC1CvC,KAAKsC,8BAAgC,KAKrCtC,KAAK0C,8BAAgC,IAAI,KACzC1C,KAAKyC,6BAA+B,KAIpCzC,KAAK4J,yCAA2C,IAAI,KAIpD5J,KAAK6J,wCAA0C,IAAI,KAKnD7J,KAAK8J,qCAAuC,IAAI,KAKhD9J,KAAK+J,oCAAsC,IAAI,KAI/C/J,KAAKgK,uBAAyB,IAAI,KAIlChK,KAAKiK,2BAA6B,IAAI,KAItCjK,KAAKkK,0BAA4B,IAAI,KAIrClK,KAAKmK,0BAA4B,IAAI,KAIrCnK,KAAKoK,yBAA2B,IAAI,KAIpCpK,KAAKqK,6BAA+B,IAAI,KAIxCrK,KAAKsK,4BAA8B,IAAI,KAIvCtK,KAAKuK,kCAAoC,IAAI,KAI7CvK,KAAKwK,iCAAmC,IAAI,KAI5CxK,KAAKyK,yBAA2B,IAAI,KAIpCzK,KAAK0K,wBAA0B,IAAI,KAInC1K,KAAK2K,6BAA+B,IAAI,KAIxC3K,KAAK4K,4BAA8B,IAAI,KAIvC5K,KAAK6K,6BAA+B,IAAI,KAIxC7K,KAAK8K,kCAAoC,IAAI,KAI7C9K,KAAK+K,4BAA8B,IAAI,KAIvC/K,KAAKgL,iCAAmC,IAAI,KAI5ChL,KAAKiL,4BAA8B,IAAI,KAIvCjL,KAAKkL,2BAA6B,IAAI,KAKtClL,KAAKmL,sCAAwC,IAAI,KAKjDnL,KAAKoL,qCAAuC,IAAI,KAIhDpL,KAAKqL,uBAAyB,IAAI,KAIlCrL,KAAKsL,sBAAwB,IAAI,KAIjCtL,KAAKkG,sBAAwB,IAAI,KAIjClG,KAAKgG,uBAAyB,IAAI,KAMlChG,KAAKuL,iCAAmC,IAAI,KAM5CvL,KAAKwL,gCAAkC,IAAI,KAI3CxL,KAAKyL,yBAA2B,IAAI,KAIpCzL,KAAK0L,kCAAoC,IAAI,KAG7C1L,KAAK2L,oCAAsC,IAAI,IAAsB,KAIrE3L,KAAKY,wBAAyB,EAI9BZ,KAAK4L,wBAAyB,EAI9B5L,KAAK6L,sBAAuB,EAK5B7L,KAAK8L,uBAAyB,IAAI,KAIlC9L,KAAK+L,oBAAsB,IAAI,KAM/B/L,KAAKgM,wBAA0B,IAAI,KAInChM,KAAKiM,qBAAuB,IAAI,KAEhCjM,KAAKyE,uBAAwB,EAE7BzE,KAAKkM,iBAAmB,EACxBlM,KAAK4E,eAAiB,EACtB5E,KAAK+E,qBAAuB,EAE5B/E,KAAKiF,aAAc,EACnBjF,KAAKmF,SAAWvF,EAAMuM,aAMtBnM,KAAKoM,SAAW,IAAI,KAAO,GAAK,GAAK,IAMrCpM,KAAKqM,WAAa,GAMlBrM,KAAKsM,SAAW,EAMhBtM,KAAKuM,OAAS,IAIdvM,KAAKwM,4BAA6B,EAElCxM,KAAKyF,iBAAkB,EACvBzF,KAAK2F,gBAAiB,EACtB3F,KAAK+F,wBAA0B,KAE/B/F,KAAKuG,kBAAmB,EAKxBvG,KAAKyM,gBAAiB,EAKtBzM,KAAK0M,kBAAmB,EAKxB1M,KAAK2M,gBAAiB,EAEtB3M,KAAKyG,mBAAoB,EAKzBzG,KAAK4M,mBAAoB,EAMzB5M,KAAK6M,mBAAoB,EAKzB7M,KAAK8M,QAAU,IAAI,IAAQ,GAAI,MAAO,GAKtC9M,KAAK+M,sBAAuB,EAK5B/M,KAAKgN,sBAAuB,EAK5BhN,KAAKiN,uBAAwB,EAI7BjN,KAAKkN,oBAAsB,IAAI7D,MAI/BrJ,KAAKmN,oBAAsB,IAAI9D,MAK/BrJ,KAAKoN,eAAgB,EACrBpN,KAAKqN,wBAA0B,IAAI,IAAsB,KAKzDrN,KAAKsN,2BAA4B,EAEjCtN,KAAKuN,eAAiB,IAAI,IAE1BvN,KAAKwN,eAAiB,IAAI,IAE1BxN,KAAKyN,iBAAmB,IAAI,IAE5BzN,KAAK0N,aAAe,IAAI,IAExB1N,KAAK2N,eAAiB,EAKtB3N,KAAK4N,mBAAqB,EAC1B5N,KAAK6N,UAAY,EACjB7N,KAAK8N,SAAW,EAChB9N,KAAK+N,2BAA6B,KAClC/N,KAAKgO,wBAAyB,EAC9BhO,KAAKiO,4BAA6B,EAClCjO,KAAKkO,iBAAmB,EACxBlO,KAAKmO,uBAAyB,EAE9BnO,KAAKoO,cAAgB,IAAI/E,MAAM,KAC/BrJ,KAAKqO,gBAAkB,IAAIhF,MAE3BrJ,KAAKsO,aAAe,IAAIjF,MACxBrJ,KAAKuO,aAAc,EAKnBvO,KAAKwO,oCAAqC,EAC1CxO,KAAKyO,cAAgB,IAAI,IAAW,KACpCzO,KAAK0O,oBAAsB,IAAI,IAAW,KAC1C1O,KAAK2O,eAAiB,IAAI,IAAsB,KAChD3O,KAAK4O,wBAA0B,IAAI,IAAsB,KAEzD5O,KAAK6O,uBAAyB,IAAI,IAAW,KAC7C7O,KAAK8O,iBAAmB,IAAI,IAAsB,IAClD9O,KAAK+O,uBAAyB,IAAI,IAAsB,IAExD/O,KAAKgP,mBAAqB,IAAI3F,MAC9BrJ,KAAKiP,iBAAmB,YAKxBjP,KAAKkP,qBAAsB,EAK3BlP,KAAKuH,YAAc,GAKnBvH,KAAK4H,wBAA0B,GAI/B5H,KAAKkH,qBAAuB,GAK5BlH,KAAKmP,yBAA2B,aAKhCnP,KAAKoP,kBAAoB,aAKzBpP,KAAKqP,8BAAgC,aAKrCrP,KAAKsP,0BAA4B,aAKjCtP,KAAKuP,sCAAwC,aAK7CvP,KAAKwP,qBAAuB,aAK5BxP,KAAKyP,+BAAiC,aAKtCzP,KAAK0P,sBAAwB,aAK7B1P,KAAK2P,oBAAsB,aAK3B3P,KAAK4P,6BAA+B,aAKpC5P,KAAK6P,uBAAyB,aAK9B7P,KAAK8P,6BAA+B,aAKpC9P,KAAK+P,+BAAiC,aAKtC/P,KAAKgQ,0BAA4B,aAKjChQ,KAAKiQ,yBAA2B,aAKhCjQ,KAAKkQ,8BAAgC,aAKrClQ,KAAKmQ,sBAAwB,aAK7BnQ,KAAKoQ,6BAA+B,aAKpCpQ,KAAKqQ,4BAA8B,aAInCrQ,KAAKsQ,mCAAqC,aAK1CtQ,KAAKuQ,kBAAoB,aAKzBvQ,KAAKwQ,kBAAoB,aAKzBxQ,KAAKyQ,kBAAoB,aAKzBzQ,KAAK0Q,gBAAkB,aAIvB1Q,KAAK2Q,sBAAwB,KAC7B3Q,KAAK4Q,uBAAyB,CAC1BC,KAAM,GACN1J,OAAQ,GAEZnH,KAAK8Q,0BAA4B,CAC7BD,KAAM,GACN1J,OAAQ,GAEZnH,KAAK+Q,4CAA6C,EAElD/Q,KAAKgR,qBAAsB,EAE3BhR,KAAKiR,oCAAqC,EAC1CjR,KAAKkR,qCAAsC,EAE3ClR,KAAKmR,6BAA8B,EAInCnR,KAAKoR,0BAA4B,IACtBpR,KAAKqR,QAAQC,cAGxBtR,KAAKuR,mBAAqB,EAC1BvR,KAAKwR,8BAA+B,EAKpCxR,KAAKyR,eAAiB,KACtBzR,KAAK4F,cAAgB,IAAIyD,MACzB,MAAMqI,EAAcC,OAAOC,OAAO,CAAEC,yBAAyB,EAAMC,oBAAoB,EAAMC,kBAAkB,EAAMC,SAAS,GAAS/J,GACvIjI,KAAKqR,QAAUrJ,GAAU,sBACpB0J,EAAYM,QAKbhS,KAAKqR,QAAQY,eAAezK,KAAKxH,OAJjC,sBAAgCA,KAChCA,KAAKqR,QAAQa,OAAO1K,KAAKxH,OAK7BA,KAAKmS,KAAO,KACZnS,KAAKU,kBAAoB,IAAI,IAAiBV,MAC1C,MACAA,KAAKoS,mBAAqB,IAAI,IAAmBpS,QAEjD,WACAA,KAAKqS,gBAGTrS,KAAKsS,aAED,MACAtS,KAAKK,8BAAgC,IAAI,KAE7CL,KAAKuS,+BACDb,EAAYG,0BACZ7R,KAAK2Q,sBAAwB,CAAC,GAElC3Q,KAAK8R,mBAAqBJ,EAAYI,mBACtC9R,KAAK+R,iBAAmBL,EAAYK,iBAC/B9J,GAAYA,EAAQ+J,SACrBhS,KAAKqR,QAAQmB,0BAA0BvR,gBAAgBjB,KAE/D,CAKAyS,eACI,MAAO,OACX,CAIAC,4BAGI,OAFA1S,KAAK4Q,uBAAuBC,KAAO7Q,KAAK2S,OACxC3S,KAAK4Q,uBAAuBzJ,OAASnH,KAAK2S,OAAOxL,OAC1CnH,KAAK4Q,sBAChB,CAIAgC,6BAA6BC,GAGzB,OAFA7S,KAAK8Q,0BAA0BD,KAAOgC,EAAKC,UAC3C9S,KAAK8Q,0BAA0B3J,OAAS0L,EAAKC,UAAU3L,OAChDnH,KAAK8Q,yBAChB,CAMAyB,+BACIvS,KAAK+S,wBAA0B/S,KAAK0S,0BAA0BM,KAAKhT,MACnEA,KAAKiT,2BAA6BjT,KAAK4S,6BAA6BI,KAAKhT,MACzEA,KAAKkT,iCAAmClT,KAAK4S,6BAA6BI,KAAKhT,MAC/EA,KAAKmT,8BAAgCnT,KAAK4S,6BAA6BI,KAAKhT,KAChF,CAIIoT,uBACA,OAAOpT,KAAK4C,cAAcwQ,gBAC9B,CAIIC,eACA,OAAOrT,KAAK4C,cAAcyQ,QAC9B,CACIA,aAASnT,GACTF,KAAK4C,cAAcyQ,SAAWnT,CAClC,CAIIoT,eACA,OAAOtT,KAAK4C,cAAc0Q,QAC9B,CACIA,aAASpT,GACTF,KAAK4C,cAAc0Q,SAAWpT,CAClC,CAKAqT,oBACI,OAAOvT,KAAKwT,eAChB,CAKAC,kBACI,OAAOzT,KAAK0T,aAChB,CAKAC,sBACI,OAAO3T,KAAK4T,iBAChB,CAQAC,wBAAwBC,EAAU5Q,EAAQ6Q,EAAa,GACnD,OAAO/T,KAAK0T,gBAAkBxQ,GAAUlD,KAAKwT,kBAAoBM,GAAY9T,KAAK4T,oBAAsBG,CAC5G,CAKAC,YACI,OAAOhU,KAAKqR,OAChB,CAKA4C,mBACI,OAAOjU,KAAKuN,eAAe2G,OAC/B,CAKIC,+BACA,OAAOnU,KAAKuN,cAChB,CAKA6G,mBACI,OAAOpU,KAAKwN,eAAe0G,OAC/B,CAKIG,oCACA,OAAOrU,KAAKwN,cAChB,CAKA8G,qBACI,OAAOtU,KAAKyN,iBAAiByG,OACjC,CAKIK,iCACA,OAAOvU,KAAKyN,gBAChB,CAKA+G,iBACI,OAAOxU,KAAK0N,aAAawG,OAC7B,CAKIO,6BACA,OAAOzU,KAAK0N,YAChB,CAKAgH,kBACI,OAAO1U,KAAKyO,aAChB,CAKAkG,oBACI,YAAgCC,IAAzB5U,KAAK6U,gBAAgC7U,KAAK6U,gBAAkB,CACvE,CAKAC,cACI,OAAO9U,KAAK6N,SAChB,CAKAkH,aACI,OAAO/U,KAAK8N,QAChB,CAEAkH,oBACIhV,KAAK6N,WACT,CACAyE,aACItS,KAAKiV,sBAAsBjV,KAAKkV,2BACpC,CAQAC,oBAAoBC,EAAYC,GAE5B,OADArV,KAAK4C,cAAcuS,oBAAoBC,EAAYC,GAC5CrV,IACX,CAQAsV,oBAAoBF,EAAYC,GAE5B,OADArV,KAAK4C,cAAc0S,oBAAoBF,EAAYC,GAC5CrV,IACX,CASAuV,kBAAkBH,EAAYC,EAAkBG,GAE5C,OADAxV,KAAK4C,cAAc2S,kBAAkBH,EAAYC,EAAkBG,GAC5DxV,IACX,CAMAyV,kBAAkBC,EAAY,GAC1B,OAAO1V,KAAK4C,cAAc6S,kBAAkBC,EAChD,CAOArD,cAAcsD,GAAW,EAAMC,GAAa,EAAMC,GAAa,GAC3D7V,KAAK4C,cAAcyP,cAAcsD,EAAUC,EAAYC,EAC3D,CAEAC,gBACI9V,KAAK4C,cAAckT,eACvB,CAOAC,QAAQC,GAAqB,GACzB,IAAI3S,EAAI4S,EAAIC,EACZ,GAAIlW,KAAKuO,YACL,OAAO,EAEX,IAAI4H,EACJ,MAAMnO,EAAShI,KAAKgU,YACdoC,EAAsBpO,EAAOoO,oBACnCpO,EAAOoO,oBAA+G,QAAxFH,EAAkC,QAA5B5S,EAAKrD,KAAKyD,oBAAiC,IAAPJ,OAAgB,EAASA,EAAGgT,oBAAiC,IAAPJ,EAAgBA,EAAKG,EACnJ,IAAIL,GAAU,EAYd,IAVI/V,KAAKsO,aAAanH,OAAS,IAC3B4O,GAAU,GAGkB,QAA/BG,EAAKlW,KAAKqF,uBAAoC,IAAP6Q,GAAyBA,EAAG1R,SAEhEwR,IACAhW,KAAK0O,oBAAoB4H,QACzBtW,KAAK4O,wBAAwB0H,SAE5BH,EAAQ,EAAGA,EAAQnW,KAAK2S,OAAOxL,OAAQgP,IAAS,CACjD,MAAMtD,EAAO7S,KAAK2S,OAAOwD,GACzB,IAAKtD,EAAKC,WAAuC,IAA1BD,EAAKC,UAAU3L,OAClC,SAIJ,IAAK0L,EAAKkD,SAAQ,GAAO,CACrBA,GAAU,EACV,QACJ,CACA,MAAMQ,EAA6B1D,EAAK2D,kBACZ,kBAAxB3D,EAAKJ,gBACmB,uBAAxBI,EAAKJ,gBACJzK,EAAOyO,UAAUC,iBAAmB7D,EAAK8D,UAAUxP,OAAS,EAEjE,IAAK,MAAMyP,KAAQ5W,KAAKwP,qBACfoH,EAAKC,OAAOhE,EAAM0D,KACnBR,GAAU,GAGlB,IAAKC,EACD,SAEJ,MAAMc,EAAMjE,EAAKiB,UAAY9T,KAAKmG,gBAClC,GAAI2Q,EACA,GAAIA,EAAIC,wBACJ,IAAK,MAAMC,KAAWnE,EAAKC,UAAW,CAClC,MAAMgB,EAAWkD,EAAQC,cACrBnD,GAAYA,EAASoD,yBAA+D,MAApCpD,EAASqD,0BACL,IAAhDnX,KAAK0O,oBAAoB0I,QAAQtD,KACjC9T,KAAK0O,oBAAoBlH,KAAKsM,GAC9B9T,KAAK4O,wBAAwByI,sBAAsBvD,EAASqD,2BAGxE,MAGIL,EAAII,yBAA0D,MAA/BJ,EAAIK,0BACY,IAA3CnX,KAAK0O,oBAAoB0I,QAAQN,KACjC9W,KAAK0O,oBAAoBlH,KAAKsP,GAC9B9W,KAAK4O,wBAAwByI,sBAAsBP,EAAIK,2BAK3E,CAEA,GAAInB,EACA,IAAKG,EAAQ,EAAGA,EAAQnW,KAAK4O,wBAAwBzH,SAAUgP,EAAO,CACtDnW,KAAK4O,wBAAwBiC,KAAKsF,GACrCmB,wBACLvB,GAAU,EAElB,CAGJ,IAAKI,EAAQ,EAAGA,EAAQnW,KAAKuX,WAAWpQ,OAAQgP,IAAS,CAErB,IADfnW,KAAKuX,WAAWpB,GACpBqB,iBACTzB,GAAU,EAElB,CAEA,GAAI/V,KAAK4F,eAAiB5F,KAAK4F,cAAcuB,OAAS,EAClD,IAAK,MAAMsQ,KAAUzX,KAAK4F,cACjB6R,EAAO1B,SAAQ,KAChBA,GAAU,QAIb/V,KAAKyD,eACLzD,KAAKyD,aAAasS,SAAQ,KAC3BA,GAAU,IAIlB,IAAK,MAAM2B,KAAkB1X,KAAK2X,gBACzBD,EAAe3B,YAChBA,GAAU,GAIlB,GAAI/V,KAAK4X,OACL,IAAK,MAAMC,KAAS7X,KAAK4X,OAChBC,EAAM9B,YACPA,GAAU,GAStB,OAJK/N,EAAO8P,uBACR/B,GAAU,GAEd/N,EAAOoO,oBAAsBA,EACtBL,CACX,CAEAgC,sBACI/X,KAAKwT,gBAAkB,KACvBxT,KAAK0T,cAAgB,KACrB1T,KAAK4T,kBAAoB,IAC7B,CAKAoE,qBAAqBC,GACjBjY,KAAKiC,yBAAyBH,IAAImW,EACtC,CAKAC,uBAAuBD,GACnBjY,KAAKiC,yBAAyBkW,eAAeF,EACjD,CAKAG,oBAAoBH,GAChBjY,KAAKoC,wBAAwBN,IAAImW,EACrC,CAKAI,sBAAsBJ,GAClBjY,KAAKoC,wBAAwB+V,eAAeF,EAChD,CACAK,yBAAyBL,GACrB,MAAMM,EAAW,KACbN,IACAO,YAAW,KACPxY,KAAKkY,uBAAuBK,EAAS,GACvC,EAENvY,KAAKgY,qBAAqBO,EAC9B,CAQAE,wBAAwBR,EAAMS,QACV9D,IAAZ8D,EACAF,YAAW,KACPxY,KAAKsY,yBAAyBL,EAAK,GACpCS,GAGH1Y,KAAKsY,yBAAyBL,EAEtC,CAKAU,eAAe9H,GACX7Q,KAAKsO,aAAa9G,KAAKqJ,EAC3B,CAKA+H,kBAAkB/H,GACd,MAAMgI,EAAa7Y,KAAK8Y,UAClB3C,EAAQnW,KAAKsO,aAAa8I,QAAQvG,IACzB,IAAXsF,GACAnW,KAAKsO,aAAayK,OAAO5C,EAAO,GAEhC0C,IAAe7Y,KAAK8Y,WACpB9Y,KAAKgK,uBAAuB/I,gBAAgBjB,KAEpD,CAKAgZ,uBACI,OAAOhZ,KAAKsO,aAAanH,MAC7B,CAII2R,gBACA,OAAO9Y,KAAKsO,aAAanH,OAAS,CACtC,CAMA8R,iBAAiBhB,EAAMjC,GAAqB,GACxChW,KAAK2J,kBAAkBuP,QAAQjB,GACS,OAApCjY,KAAK+N,4BAGT/N,KAAKmZ,cAAcnD,EACvB,CAMAoD,eAAepD,GAAqB,GAChC,OAAO,IAAIqD,SAASC,IAChBtZ,KAAKiZ,kBAAiB,KAClBK,GAAS,GACVtD,EAAmB,GAE9B,CAIAmD,cAAcnD,GAAqB,GAE/B,OADAhW,KAAKiH,+BACDjH,KAAK+V,QAAQC,IACbhW,KAAK2J,kBAAkB1I,gBAAgBjB,MACvCA,KAAK2J,kBAAkB4P,aACvBvZ,KAAK+N,2BAA6B,OAGlC/N,KAAKuO,aACLvO,KAAK2J,kBAAkB4P,aACvBvZ,KAAK+N,2BAA6B,YAGtC/N,KAAK+N,2BAA6ByK,YAAW,KAEzCxY,KAAKgV,oBACLhV,KAAKmZ,cAAcnD,EAAmB,GACvC,KACP,CAIIwD,kBACA,OAAOxZ,KAAKgP,kBAChB,CAKAyK,8BACIzZ,KAAK0Z,mBAAqB,OAC9B,CAMAC,gBACI,OAAO3Z,KAAK4Z,WAChB,CAKAC,sBACI,OAAO7Z,KAAK8Z,iBAChB,CAKAC,qBACI,OAAO/Z,KAAKiP,gBAChB,CAQA+K,mBAAmBC,EAAOC,EAAaC,EAAOC,GAErCD,GAAUC,IAAepa,KAAKqa,qBAC/Bra,KAAKqa,mBAAmBC,UACxBta,KAAKqa,mBAAqB,MAE1Bra,KAAKkO,kBAAoB+L,EAAMM,YAAcva,KAAKmO,wBAA0B+L,EAAYK,aAG5Fva,KAAKkO,gBAAkB+L,EAAMM,WAC7Bva,KAAKmO,sBAAwB+L,EAAYK,WACzCva,KAAK4Z,YAAcK,EACnBja,KAAK8Z,kBAAoBI,EACzBla,KAAK4Z,YAAYY,cAAcxa,KAAK8Z,kBAAmB9Z,KAAKiP,kBAEvDjP,KAAKgH,eAIN,mBAAuBhH,KAAKiP,iBAAkBjP,KAAKgH,gBAHnDhH,KAAKgH,eAAiB,cAAkBhH,KAAKiP,kBAK7CjP,KAAKqa,oBAAsBra,KAAKqa,mBAAmBI,OACnDza,KAAK0a,oBAAoBP,EAAOC,GAE3Bpa,KAAK2a,UAAUF,SACpBza,KAAK2a,UAAUC,aAAa,iBAAkB5a,KAAKiP,kBACnDjP,KAAK2a,UAAUC,aAAa,OAAQ5a,KAAK4Z,aACzC5Z,KAAK2a,UAAUC,aAAa,aAAc5a,KAAK8Z,oBAEvD,CAKAzV,wBACI,OAAOrE,KAAKqa,mBAAqBra,KAAKqa,mBAAqBra,KAAK2a,SACpE,CAMAzF,yBAAyBpN,GACrB,MAAM+S,EAAW,IAAI,IAAc7a,KAAKqR,aAASuD,GAAW,EAAO9M,QAAmCA,EAAO,SAK7G,OAJA+S,EAASC,WAAW,iBAAkB,IACtCD,EAASC,WAAW,OAAQ,IAC5BD,EAASC,WAAW,aAAc,IAClCD,EAASC,WAAW,eAAgB,GAC7BD,CACX,CAKA5F,sBAAsB7Q,GAClBpE,KAAK2a,UAAYvW,EACjBpE,KAAKkO,iBAAmB,EACxBlO,KAAKmO,uBAAyB,CAClC,CAKA4M,cACI,OAAO,IAAAC,QACX,CAMAC,QAAQC,EAASC,GAAY,GACrBnb,KAAKqI,yBAGTrI,KAAK2S,OAAOnL,KAAK0T,GACjBA,EAAQE,sBACHF,EAAQG,QACTH,EAAQI,uBAEZtb,KAAKyK,yBAAyBxJ,gBAAgBia,GAC1CC,GACAD,EAAQK,iBAAiBC,SAASC,IAC9Bzb,KAAKib,QAAQQ,EAAE,IAG3B,CAOAC,WAAWC,EAAUR,GAAY,GAC7B,MAAMhF,EAAQnW,KAAK2S,OAAOyE,QAAQuE,GAgBlC,OAfe,IAAXxF,IAEAnW,KAAK2S,OAAOwD,GAASnW,KAAK2S,OAAO3S,KAAK2S,OAAOxL,OAAS,GACtDnH,KAAK2S,OAAOiJ,MACPD,EAASN,QACVM,EAASE,6BAGjB7b,KAAK4C,cAAckZ,gBAAgBH,GACnC3b,KAAK0K,wBAAwBzJ,gBAAgB0a,GACzCR,GACAQ,EAASJ,iBAAiBC,SAASC,IAC/Bzb,KAAK0b,WAAWD,EAAE,IAGnBtF,CACX,CAKA4F,iBAAiBC,GACThc,KAAKqI,wBAGL2T,EAAiBC,aAAejc,OAA+D,IAAvDgc,EAAiBE,mCAI7DF,EAAiBE,iCAAmClc,KAAKmc,eAAehV,OACxEnH,KAAKmc,eAAe3U,KAAKwU,GACpBA,EAAiBX,QAClBW,EAAiBV,uBAErBtb,KAAKuK,kCAAkCtJ,gBAAgB+a,GAC3D,CAMAI,oBAAoBT,GAChB,MAAMxF,EAAQwF,EAASO,iCACvB,IAAe,IAAX/F,EAAc,CACd,GAAIA,IAAUnW,KAAKmc,eAAehV,OAAS,EAAG,CAC1C,MAAMkV,EAAWrc,KAAKmc,eAAenc,KAAKmc,eAAehV,OAAS,GAClEnH,KAAKmc,eAAehG,GAASkG,EAC7BA,EAASH,iCAAmC/F,CAChD,CACAwF,EAASO,kCAAoC,EAC7Clc,KAAKmc,eAAeP,MACfD,EAASN,QACVM,EAASE,2BAEjB,CAEA,OADA7b,KAAKwK,iCAAiCvJ,gBAAgB0a,GAC/CxF,CACX,CAMAmG,eAAeX,GACX,MAAMxF,EAAQnW,KAAKuc,UAAUnF,QAAQuE,GAQrC,OAPe,IAAXxF,IAEAnW,KAAKuc,UAAUxD,OAAO5C,EAAO,GAC7BnW,KAAK4K,4BAA4B3J,gBAAgB0a,GAEjD3b,KAAKwc,+BAA+Bxc,KAAK8O,mBAEtCqH,CACX,CAMAsG,yBAAyBd,GACrB,MAAMxF,EAAQnW,KAAK0c,oBAAoBtF,QAAQuE,GAK/C,OAJe,IAAXxF,GAEAnW,KAAK0c,oBAAoB3D,OAAO5C,EAAO,GAEpCA,CACX,CAMAwG,YAAYhB,GACR,MAAMxF,EAAQnW,KAAK4c,OAAOxF,QAAQuE,GAClC,IAAe,IAAXxF,EAAc,CAEd,IAAK,MAAMtD,KAAQ7S,KAAK2S,OACpBE,EAAKgK,mBAAmBlB,GAAU,GAGtC3b,KAAK4c,OAAO7D,OAAO5C,EAAO,GAC1BnW,KAAK8c,uBACAnB,EAASN,QACVM,EAASE,2BAEjB,CAEA,OADA7b,KAAKoK,yBAAyBnJ,gBAAgB0a,GACvCxF,CACX,CAMA4G,aAAapB,GACT,MAAMxF,EAAQnW,KAAK8F,QAAQsR,QAAQuE,GASnC,IARe,IAAXxF,IAEAnW,KAAK8F,QAAQiT,OAAO5C,EAAO,GACtBwF,EAASN,QACVM,EAASE,6BAIb7b,KAAK4F,cAAe,CACpB,MAAMoX,EAAShd,KAAK4F,cAAcwR,QAAQuE,IAC1B,IAAZqB,GAEAhd,KAAK4F,cAAcmT,OAAOiE,EAAQ,EAE1C,CAWA,OATIhd,KAAKyD,eAAiBkY,IAClB3b,KAAK8F,QAAQqB,OAAS,EACtBnH,KAAKyD,aAAezD,KAAK8F,QAAQ,GAGjC9F,KAAKyD,aAAe,MAG5BzD,KAAKkK,0BAA0BjJ,gBAAgB0a,GACxCxF,CACX,CAMA8G,qBAAqBtB,GACjB,MAAMxF,EAAQnW,KAAK2X,gBAAgBP,QAAQuE,GAM3C,OALe,IAAXxF,IACAnW,KAAK2X,gBAAgBoB,OAAO5C,EAAO,GAEnCnW,KAAKwc,+BAA+Bxc,KAAK6O,yBAEtCsH,CACX,CAMA+G,gBAAgBvB,GACZ,MAAMxF,EAAQnW,KAAKmd,WAAW/F,QAAQuE,GAItC,OAHe,IAAXxF,GACAnW,KAAKmd,WAAWpE,OAAO5C,EAAO,GAE3BA,CACX,CAOAiH,cAAcC,EAAQC,EAAeC,GAErC,CAMAC,qBAAqB7B,GACjB,MAAMxF,EAAQnW,KAAKyd,gBAAgBrG,QAAQuE,GAI3C,OAHe,IAAXxF,GACAnW,KAAKyd,gBAAgB1E,OAAO5C,EAAO,GAEhCA,CACX,CAMAuH,oBAAoB/B,GAChB,MAAMxF,EAAQnW,KAAK2d,eAAevG,QAAQuE,GAK1C,OAJe,IAAXxF,GACAnW,KAAK2d,eAAe5E,OAAO5C,EAAO,GAEtCnW,KAAKgL,iCAAiC/J,gBAAgB0a,GAC/CxF,CACX,CAMAyH,eAAejC,GACX,MAAMxF,EAAQwF,EAASkC,2BACvB,IAAe,IAAX1H,GAAgBA,EAAQnW,KAAK8d,UAAU3W,OAAQ,CAC/C,GAAIgP,IAAUnW,KAAK8d,UAAU3W,OAAS,EAAG,CACrC,MAAM4W,EAAe/d,KAAK8d,UAAU9d,KAAK8d,UAAU3W,OAAS,GAC5DnH,KAAK8d,UAAU3H,GAAS4H,EACxBA,EAAaF,2BAA6B1H,CAC9C,CACAwF,EAASkC,4BAA8B,EACvC7d,KAAK8d,UAAUlC,KACnB,CAEA,OADA5b,KAAK+K,4BAA4B9J,gBAAgB0a,GAC1CxF,CACX,CAOA6H,oBAAoBrC,GAChB,MAAMxF,EAAQnW,KAAKie,eAAe7G,QAAQuE,GAI1C,OAHe,IAAXxF,GACAnW,KAAKie,eAAelF,OAAO5C,EAAO,GAE/BA,CACX,CAMA+H,cAAcvC,GACV,MAAMxF,EAAQnW,KAAKme,SAAS/G,QAAQuE,GAKpC,OAJe,IAAXxF,GACAnW,KAAKme,SAASpF,OAAO5C,EAAO,GAEhCnW,KAAKkL,2BAA2BjK,gBAAgB0a,GACzCxF,CACX,CAKAiI,SAASC,GACL,IAAIre,KAAKqI,uBAAT,CAGArI,KAAK4c,OAAOpV,KAAK6W,GACjBre,KAAK8c,uBACAuB,EAAShD,QACVgD,EAAS/C,uBAGb,IAAK,MAAMzI,KAAQ7S,KAAK2S,QACyB,IAAzCE,EAAKyL,aAAalH,QAAQiH,KAC1BxL,EAAKyL,aAAa9W,KAAK6W,GACvBxL,EAAKuI,uBAGbpb,KAAKmK,0BAA0BlJ,gBAAgBod,EAb/C,CAcJ,CAIAvB,uBACQ9c,KAAKkP,qBACLlP,KAAK4c,OAAO2B,KAAK,0BAEzB,CAKAC,UAAUC,GACFze,KAAKqI,yBAGTrI,KAAK8F,QAAQ0B,KAAKiX,GAClBze,KAAKiK,2BAA2BhJ,gBAAgBwd,GAC3CA,EAAUpD,QACXoD,EAAUnD,uBAElB,CAKAoD,YAAYC,GACJ3e,KAAKqI,yBAGTrI,KAAKuc,UAAU/U,KAAKmX,GACpB3e,KAAK2K,6BAA6B1J,gBAAgB0d,GACtD,CAKAC,kBAAkBC,GACV7e,KAAKqI,wBAGTrI,KAAK2X,gBAAgBnQ,KAAKqX,EAC9B,CAKAC,aAAaC,GACL/e,KAAKqI,wBAGTrI,KAAKmd,WAAW3V,KAAKuX,EACzB,CAKAC,kBAAkBC,GACVjf,KAAKqI,wBAGTrI,KAAKyd,gBAAgBjW,KAAKyX,EAC9B,CAKAC,iBAAiBC,GACTnf,KAAKqI,yBAGTrI,KAAK2d,eAAenW,KAAK2X,GACzBnf,KAAK8K,kCAAkC7J,gBAAgBke,GAC3D,CAKAC,YAAYC,GACJrf,KAAKqI,wBAGLgX,EAAYpD,aAAejc,OAAoD,IAA5Cqf,EAAYxB,6BAInDwB,EAAYxB,2BAA6B7d,KAAK8d,UAAU3W,OACxDnH,KAAK8d,UAAUtW,KAAK6X,GACpBrf,KAAK6K,6BAA6B5J,gBAAgBoe,GACtD,CAKAC,sBAAsBC,GACdvf,KAAKqI,wBAGTrI,KAAK0c,oBAAoBlV,KAAK+X,EAClC,CAKAC,YAAYC,GACJzf,KAAKqI,yBAGLrI,KAAK2Q,wBACL3Q,KAAK2Q,sBAAsB8O,EAAYC,UAAY1f,KAAKuX,WAAWpQ,QAEvEnH,KAAKuX,WAAW/P,KAAKiY,GACzB,CAMAE,iBAAiBC,GACb5f,KAAKie,eAAezW,KAAKoY,EAC7B,CAKAC,WAAWC,GACH9f,KAAKqI,yBAGTrI,KAAKme,SAAS3W,KAAKsY,GACnB9f,KAAKiL,4BAA4BhK,gBAAgB6e,GACrD,CAMAC,mBAAmBtB,EAAWpM,GAAgB,GAC3BrS,KAAKqR,QAAQ2O,oBAIxBhgB,KAAKyD,cACLzD,KAAKyD,aAAaqS,gBAEtB9V,KAAKyD,aAAegb,EAChBpM,GACAoM,EAAUpM,gBAElB,CAMA4N,oBAAoBC,GAChB,MAAMzI,EAASzX,KAAKmgB,cAAcD,GAClC,OAAIzI,GACAzX,KAAKyD,aAAegU,EACbA,GAEJ,IACX,CAMA2I,sBAAsBtY,GAClB,MAAM2P,EAASzX,KAAKqgB,gBAAgBvY,GACpC,OAAI2P,GACAzX,KAAKyD,aAAegU,EACbA,GAEJ,IACX,CAMA6I,wBAAwBxY,GACpB,IAAK,IAAIqO,EAAQ,EAAGA,EAAQnW,KAAKyd,gBAAgBtW,OAAQgP,IACrD,GAAInW,KAAKyd,gBAAgBtH,GAAOrO,OAASA,EACrC,OAAO9H,KAAKyd,gBAAgBtH,GAGpC,OAAO,IACX,CACAoK,aAAaC,EAAqBC,GAC9B,IAAK,IAAItK,EAAQ,EAAGA,EAAQnW,KAAK8d,UAAU3W,OAAQgP,IAAS,CACxD,MAAMrC,EAAW9T,KAAK8d,UAAU3H,GAChC,GAAIsK,EAAU3M,GACV,OAAOA,CAEf,CACA,GAAI0M,EACA,IAAK,IAAIrK,EAAQ,EAAGA,EAAQnW,KAAK2d,eAAexW,OAAQgP,IAAS,CAC7D,MAAMrC,EAAW9T,KAAK2d,eAAexH,GACrC,GAAIsK,EAAU3M,GACV,OAAOA,CAEf,CAEJ,OAAO,IACX,CAOA4M,sBAAsBhB,EAAUc,GAAsB,GAClD,OAAOxgB,KAAKugB,aAAaC,GAAsB/E,GAAMA,EAAEiE,WAAaA,GACxE,CAOAiB,gBAAgBT,EAAIM,GAAsB,GACtC,OAAOxgB,KAAKugB,aAAaC,GAAsB/E,GAAMA,EAAEyE,KAAOA,GAClE,CAOAU,kBAAkB9Y,EAAM0Y,GAAsB,GAC1C,OAAOxgB,KAAKugB,aAAaC,GAAsB/E,GAAMA,EAAE3T,OAASA,GACpE,CAOA+Y,oBAAoBX,EAAIM,GAAsB,GAC1C,IAAK,IAAIrK,EAAQnW,KAAK8d,UAAU3W,OAAS,EAAGgP,GAAS,EAAGA,IACpD,GAAInW,KAAK8d,UAAU3H,GAAO+J,KAAOA,EAC7B,OAAOlgB,KAAK8d,UAAU3H,GAG9B,GAAIqK,EACA,IAAK,IAAIrK,EAAQnW,KAAK2d,eAAexW,OAAS,EAAGgP,GAAS,EAAGA,IACzD,GAAInW,KAAK2d,eAAexH,GAAO+J,KAAOA,EAClC,OAAOlgB,KAAK2d,eAAexH,GAIvC,OAAO,IACX,CAMA2K,qBAAqBpB,GACjB,IAAK,IAAIvJ,EAAQ,EAAGA,EAAQnW,KAAKme,SAAShX,OAAQgP,IAC9C,GAAInW,KAAKme,SAAShI,GAAOuJ,WAAaA,EAClC,OAAO1f,KAAKme,SAAShI,GAG7B,OAAO,IACX,CAMA4K,iBAAiBjZ,GACb,IAAK,IAAIqO,EAAQ,EAAGA,EAAQnW,KAAKme,SAAShX,OAAQgP,IAC9C,GAAInW,KAAKme,SAAShI,GAAOrO,OAASA,EAC9B,OAAO9H,KAAKme,SAAShI,GAG7B,OAAO,IACX,CAMAgK,cAAcD,GACV,IAAK,IAAI/J,EAAQ,EAAGA,EAAQnW,KAAK8F,QAAQqB,OAAQgP,IAC7C,GAAInW,KAAK8F,QAAQqQ,GAAO+J,KAAOA,EAC3B,OAAOlgB,KAAK8F,QAAQqQ,GAG5B,OAAO,IACX,CAMA6K,oBAAoBtB,GAChB,IAAK,IAAIvJ,EAAQ,EAAGA,EAAQnW,KAAK8F,QAAQqB,OAAQgP,IAC7C,GAAInW,KAAK8F,QAAQqQ,GAAOuJ,WAAaA,EACjC,OAAO1f,KAAK8F,QAAQqQ,GAG5B,OAAO,IACX,CAMAkK,gBAAgBvY,GACZ,IAAK,IAAIqO,EAAQ,EAAGA,EAAQnW,KAAK8F,QAAQqB,OAAQgP,IAC7C,GAAInW,KAAK8F,QAAQqQ,GAAOrO,OAASA,EAC7B,OAAO9H,KAAK8F,QAAQqQ,GAG5B,OAAO,IACX,CAMA8K,YAAYf,GACR,IAAK,IAAIgB,EAAgB,EAAGA,EAAgBlhB,KAAKuc,UAAUpV,OAAQ+Z,IAAiB,CAChF,MAAMC,EAAWnhB,KAAKuc,UAAU2E,GAChC,IAAK,IAAIE,EAAY,EAAGA,EAAYD,EAASE,MAAMla,OAAQia,IACvD,GAAID,EAASE,MAAMD,GAAWlB,KAAOA,EACjC,OAAOiB,EAASE,MAAMD,EAGlC,CACA,OAAO,IACX,CAMAE,cAAcxZ,GACV,IAAK,IAAIoZ,EAAgB,EAAGA,EAAgBlhB,KAAKuc,UAAUpV,OAAQ+Z,IAAiB,CAChF,MAAMC,EAAWnhB,KAAKuc,UAAU2E,GAChC,IAAK,IAAIE,EAAY,EAAGA,EAAYD,EAASE,MAAMla,OAAQia,IACvD,GAAID,EAASE,MAAMD,GAAWtZ,OAASA,EACnC,OAAOqZ,EAASE,MAAMD,EAGlC,CACA,OAAO,IACX,CAMAG,eAAezZ,GACX,IAAK,IAAIqO,EAAQ,EAAGA,EAAQnW,KAAK4c,OAAOzV,OAAQgP,IAC5C,GAAInW,KAAK4c,OAAOzG,GAAOrO,OAASA,EAC5B,OAAO9H,KAAK4c,OAAOzG,GAG3B,OAAO,IACX,CAMAqL,aAAatB,GACT,IAAK,IAAI/J,EAAQ,EAAGA,EAAQnW,KAAK4c,OAAOzV,OAAQgP,IAC5C,GAAInW,KAAK4c,OAAOzG,GAAO+J,KAAOA,EAC1B,OAAOlgB,KAAK4c,OAAOzG,GAG3B,OAAO,IACX,CAMAsL,mBAAmB/B,GACf,IAAK,IAAIvJ,EAAQ,EAAGA,EAAQnW,KAAK4c,OAAOzV,OAAQgP,IAC5C,GAAInW,KAAK4c,OAAOzG,GAAOuJ,WAAaA,EAChC,OAAO1f,KAAK4c,OAAOzG,GAG3B,OAAO,IACX,CAMAuL,sBAAsBxB,GAClB,IAAK,IAAI/J,EAAQ,EAAGA,EAAQnW,KAAK2X,gBAAgBxQ,OAAQgP,IACrD,GAAInW,KAAK2X,gBAAgBxB,GAAO+J,KAAOA,EACnC,OAAOlgB,KAAK2X,gBAAgBxB,GAGpC,OAAO,IACX,CAMAwL,gBAAgBzB,GACZ,IAAK,IAAI/J,EAAQ,EAAGA,EAAQnW,KAAKuX,WAAWpQ,OAAQgP,IAChD,GAAInW,KAAKuX,WAAWpB,GAAO+J,KAAOA,EAC9B,OAAOlgB,KAAKuX,WAAWpB,GAG/B,OAAO,IACX,CACAyL,uBAAuBlC,GACnB,GAAI1f,KAAK2Q,sBAAuB,CAC5B,MAAMwF,EAAQnW,KAAK2Q,sBAAsB+O,GACzC,QAAc9K,IAAVuB,EACA,OAAOnW,KAAKuX,WAAWpB,EAE/B,MAEI,IAAK,IAAIA,EAAQ,EAAGA,EAAQnW,KAAKuX,WAAWpQ,OAAQgP,IAChD,GAAInW,KAAKuX,WAAWpB,GAAOuJ,WAAaA,EACpC,OAAO1f,KAAKuX,WAAWpB,GAInC,OAAO,IACX,CAOA0L,aAAaC,EAAUC,GACnB,SAAKA,GAAS/hB,KAAK4hB,uBAAuBE,EAASpC,aAGnD1f,KAAKwf,YAAYsC,GACjB9hB,KAAKqK,6BAA6BpJ,gBAAgB6gB,IAC3C,EACX,CAMAE,eAAeF,GACX,IAAI3L,EACJ,GAAInW,KAAK2Q,uBAEL,GADAwF,EAAQnW,KAAK2Q,sBAAsBmR,EAASpC,eAC9B9K,IAAVuB,EACA,OAAO,OAKX,GADAA,EAAQnW,KAAKuX,WAAWH,QAAQ0K,GAC5B3L,EAAQ,EACR,OAAO,EAGf,GAAIA,IAAUnW,KAAKuX,WAAWpQ,OAAS,EAAG,CACtC,MAAM8a,EAAejiB,KAAKuX,WAAWvX,KAAKuX,WAAWpQ,OAAS,GAC1D8a,IACAjiB,KAAKuX,WAAWpB,GAAS8L,EACrBjiB,KAAK2Q,wBACL3Q,KAAK2Q,sBAAsBsR,EAAavC,UAAYvJ,GAGhE,CAMA,OALInW,KAAK2Q,wBACL3Q,KAAK2Q,sBAAsBmR,EAASpC,eAAY9K,GAEpD5U,KAAKuX,WAAWqE,MAChB5b,KAAKsK,4BAA4BrJ,gBAAgB6gB,IAC1C,CACX,CAKAI,gBACI,OAAOliB,KAAKuX,UAChB,CAMA4K,YAAYjC,GACR,IAAK,IAAI/J,EAAQ,EAAGA,EAAQnW,KAAK2S,OAAOxL,OAAQgP,IAC5C,GAAInW,KAAK2S,OAAOwD,GAAO+J,KAAOA,EAC1B,OAAOlgB,KAAK2S,OAAOwD,GAG3B,OAAO,IACX,CAMAiM,cAAclC,GACV,OAAOlgB,KAAK2S,OAAO0P,QAAO,SAAU5G,GAChC,OAAOA,EAAEyE,KAAOA,CACpB,GACJ,CAMAoC,qBAAqBpC,GACjB,IAAK,IAAI/J,EAAQ,EAAGA,EAAQnW,KAAKmc,eAAehV,OAAQgP,IACpD,GAAInW,KAAKmc,eAAehG,GAAO+J,KAAOA,EAClC,OAAOlgB,KAAKmc,eAAehG,GAGnC,OAAO,IACX,CAMAoM,2BAA2B7C,GACvB,IAAK,IAAIvJ,EAAQ,EAAGA,EAAQnW,KAAKmc,eAAehV,OAAQgP,IACpD,GAAInW,KAAKmc,eAAehG,GAAOuJ,WAAaA,EACxC,OAAO1f,KAAKmc,eAAehG,GAGnC,OAAO,IACX,CAMAqM,sBAAsBtC,GAClB,OAAOlgB,KAAKmc,eAAekG,QAAO,SAAU5G,GACxC,OAAOA,EAAEyE,KAAOA,CACpB,GACJ,CAMAuC,kBAAkB/C,GACd,IAAK,IAAIvJ,EAAQ,EAAGA,EAAQnW,KAAK2S,OAAOxL,OAAQgP,IAC5C,GAAInW,KAAK2S,OAAOwD,GAAOuJ,WAAaA,EAChC,OAAO1f,KAAK2S,OAAOwD,GAG3B,OAAO,IACX,CAMAuM,gBAAgBxC,GACZ,IAAK,IAAI/J,EAAQnW,KAAK2S,OAAOxL,OAAS,EAAGgP,GAAS,EAAGA,IACjD,GAAInW,KAAK2S,OAAOwD,GAAO+J,KAAOA,EAC1B,OAAOlgB,KAAK2S,OAAOwD,GAG3B,OAAO,IACX,CAMAwM,iBAAiBzC,GACb,IAAI/J,EACJ,IAAKA,EAAQnW,KAAK2S,OAAOxL,OAAS,EAAGgP,GAAS,EAAGA,IAC7C,GAAInW,KAAK2S,OAAOwD,GAAO+J,KAAOA,EAC1B,OAAOlgB,KAAK2S,OAAOwD,GAG3B,IAAKA,EAAQnW,KAAKmc,eAAehV,OAAS,EAAGgP,GAAS,EAAGA,IACrD,GAAInW,KAAKmc,eAAehG,GAAO+J,KAAOA,EAClC,OAAOlgB,KAAKmc,eAAehG,GAGnC,IAAKA,EAAQnW,KAAK8F,QAAQqB,OAAS,EAAGgP,GAAS,EAAGA,IAC9C,GAAInW,KAAK8F,QAAQqQ,GAAO+J,KAAOA,EAC3B,OAAOlgB,KAAK8F,QAAQqQ,GAG5B,IAAKA,EAAQnW,KAAK4c,OAAOzV,OAAS,EAAGgP,GAAS,EAAGA,IAC7C,GAAInW,KAAK4c,OAAOzG,GAAO+J,KAAOA,EAC1B,OAAOlgB,KAAK4c,OAAOzG,GAG3B,OAAO,IACX,CAMAyM,YAAY1C,GACR,MAAMrN,EAAO7S,KAAKmiB,YAAYjC,GAC9B,GAAIrN,EACA,OAAOA,EAEX,MAAMgQ,EAAgB7iB,KAAKsiB,qBAAqBpC,GAChD,GAAI2C,EACA,OAAOA,EAEX,MAAMC,EAAQ9iB,KAAKwhB,aAAatB,GAChC,GAAI4C,EACA,OAAOA,EAEX,MAAMrL,EAASzX,KAAKmgB,cAAcD,GAClC,GAAIzI,EACA,OAAOA,EAEX,MAAMsL,EAAO/iB,KAAKihB,YAAYf,GAC9B,OAAI6C,GAGG,IACX,CAMAC,cAAclb,GACV,MAAM+K,EAAO7S,KAAKijB,cAAcnb,GAChC,GAAI+K,EACA,OAAOA,EAEX,MAAMgQ,EAAgB7iB,KAAKkjB,uBAAuBpb,GAClD,GAAI+a,EACA,OAAOA,EAEX,MAAMC,EAAQ9iB,KAAKuhB,eAAezZ,GAClC,GAAIgb,EACA,OAAOA,EAEX,MAAMrL,EAASzX,KAAKqgB,gBAAgBvY,GACpC,GAAI2P,EACA,OAAOA,EAEX,MAAMsL,EAAO/iB,KAAKshB,cAAcxZ,GAChC,OAAIib,GAGG,IACX,CAMAE,cAAcnb,GACV,IAAK,IAAIqO,EAAQ,EAAGA,EAAQnW,KAAK2S,OAAOxL,OAAQgP,IAC5C,GAAInW,KAAK2S,OAAOwD,GAAOrO,OAASA,EAC5B,OAAO9H,KAAK2S,OAAOwD,GAG3B,OAAO,IACX,CAMA+M,uBAAuBpb,GACnB,IAAK,IAAIqO,EAAQ,EAAGA,EAAQnW,KAAKmc,eAAehV,OAAQgP,IACpD,GAAInW,KAAKmc,eAAehG,GAAOrO,OAASA,EACpC,OAAO9H,KAAKmc,eAAehG,GAGnC,OAAO,IACX,CAMAgN,oBAAoBjD,GAChB,IAAK,IAAI/J,EAAQnW,KAAKuc,UAAUpV,OAAS,EAAGgP,GAAS,EAAGA,IACpD,GAAInW,KAAKuc,UAAUpG,GAAO+J,KAAOA,EAC7B,OAAOlgB,KAAKuc,UAAUpG,GAG9B,OAAO,IACX,CAMAiN,sBAAsB1D,GAClB,IAAK,IAAIvJ,EAAQ,EAAGA,EAAQnW,KAAKuc,UAAUpV,OAAQgP,IAC/C,GAAInW,KAAKuc,UAAUpG,GAAOuJ,WAAaA,EACnC,OAAO1f,KAAKuc,UAAUpG,GAG9B,OAAO,IACX,CAMAkN,gBAAgBnD,GACZ,IAAK,IAAI/J,EAAQ,EAAGA,EAAQnW,KAAKuc,UAAUpV,OAAQgP,IAC/C,GAAInW,KAAKuc,UAAUpG,GAAO+J,KAAOA,EAC7B,OAAOlgB,KAAKuc,UAAUpG,GAG9B,OAAO,IACX,CAMAmN,kBAAkBxb,GACd,IAAK,IAAIqO,EAAQ,EAAGA,EAAQnW,KAAKuc,UAAUpV,OAAQgP,IAC/C,GAAInW,KAAKuc,UAAUpG,GAAOrO,OAASA,EAC/B,OAAO9H,KAAKuc,UAAUpG,GAG9B,OAAO,IACX,CAMAoN,0BAA0BrD,GACtB,IAAK,IAAI/J,EAAQ,EAAGA,EAAQnW,KAAK0c,oBAAoBvV,OAAQgP,IACzD,GAAInW,KAAK0c,oBAAoBvG,GAAOuJ,WAAaQ,EAC7C,OAAOlgB,KAAK0c,oBAAoBvG,GAGxC,OAAO,IACX,CAMAqN,mBAAmBtD,GACf,IAAK,IAAIuD,EAAe,EAAGA,EAAezjB,KAAK0c,oBAAoBvV,SAAUsc,EAAc,CACvF,MAAMC,EAAqB1jB,KAAK0c,oBAAoB+G,GACpD,IAAK,IAAItN,EAAQ,EAAGA,EAAQuN,EAAmBC,aAAcxN,EAAO,CAChE,MAAMkH,EAASqG,EAAmBE,UAAUzN,GAC5C,GAAIkH,EAAO6C,KAAOA,EACd,OAAO7C,CAEf,CACJ,CACA,OAAO,IACX,CAMAwG,qBAAqB/b,GACjB,IAAK,IAAI2b,EAAe,EAAGA,EAAezjB,KAAK0c,oBAAoBvV,SAAUsc,EAAc,CACvF,MAAMC,EAAqB1jB,KAAK0c,oBAAoB+G,GACpD,IAAK,IAAItN,EAAQ,EAAGA,EAAQuN,EAAmBC,aAAcxN,EAAO,CAChE,MAAMkH,EAASqG,EAAmBE,UAAUzN,GAC5C,GAAIkH,EAAOvV,OAASA,EAChB,OAAOuV,CAEf,CACJ,CACA,OAAO,IACX,CAMAyG,qBAAqBhc,GACjB,IAAK,IAAIic,EAAmB,EAAGA,EAAmB/jB,KAAKgkB,cAAc7c,SAAU4c,EAAkB,CAC7F,MAAME,EAAcjkB,KAAKgkB,cAAcD,GACvC,GAAIE,EAAYnc,OAASA,EACrB,OAAOmc,CAEf,CACA,OAAO,IACX,CAMAC,aAAarR,GACT,OAA6C,IAAtC7S,KAAKyO,cAAc2I,QAAQvE,EACtC,CAIIsR,UAIA,OAHKnkB,KAAKmS,OACNnS,KAAKmS,KAAO,iBAETnS,KAAKmS,IAChB,CASAiS,gBAAgBC,EAAKxT,GAIjB,OAHK7Q,KAAKskB,gBACNtkB,KAAKskB,cAAgB,IAAI,KAEtBtkB,KAAKskB,cAAcxiB,IAAIuiB,EAAKxT,EACvC,CAMA0T,gBAAgBF,GACZ,OAAKrkB,KAAKskB,cAGHtkB,KAAKskB,cAAcE,IAAIH,GAFnB,IAGf,CAOAI,gCAAgCJ,EAAKK,GAIjC,OAHK1kB,KAAKskB,gBACNtkB,KAAKskB,cAAgB,IAAI,KAEtBtkB,KAAKskB,cAAcK,oBAAoBN,EAAKK,EACvD,CAMAE,mBAAmBP,GACf,OAAOrkB,KAAKskB,cAAcziB,OAAOwiB,EACrC,CACAQ,iBAAiB7N,EAASnE,EAAMiS,EAAaC,GACzC,GAAIA,GAAa/N,EAAQgO,YAAYhlB,KAAKgH,gBAAiB,CACvD,IAAK,MAAM4P,KAAQ5W,KAAK0P,sBACpBkH,EAAKC,OAAOhE,EAAMmE,GAEtB,MAAMlD,EAAWkD,EAAQC,cACrBnD,UAEIA,EAASoD,yBAA+D,MAApCpD,EAASqD,0BACO,IAAhDnX,KAAK0O,oBAAoB0I,QAAQtD,KACjC9T,KAAK0O,oBAAoBlH,KAAKsM,GAC9B9T,KAAK4O,wBAAwByI,sBAAsBvD,EAASqD,4BAIpEnX,KAAKU,kBAAkBukB,SAASjO,EAASnE,EAAMiB,GAEvD,CACJ,CAIAoR,yBACIllB,KAAK0O,oBAAoB4L,SAC7B,CAMI6K,8CACA,OAAOnlB,KAAK+Q,0CAChB,CACIoU,4CAAwCjlB,GACpCF,KAAK+Q,6CAA+C7Q,IAGpDA,IACAF,KAAKolB,mBACLplB,KAAKqlB,uBAETrlB,KAAK+Q,2CAA6C7Q,EACtD,CAIAklB,mBACI,IAAIplB,KAAKmlB,0CAGTnlB,KAAKyO,cAAc6L,UACfta,KAAKyD,cAAgBzD,KAAKyD,aAAagL,eACvCzO,KAAKyD,aAAagL,cAAc6L,UAEhCta,KAAK4F,eACL,IAAK,IAAI0f,EAAI,EAAGA,EAAItlB,KAAK4F,cAAcuB,OAAQme,IAAK,CAChD,MAAM7hB,EAAezD,KAAK4F,cAAc0f,GACpC7hB,GAAgBA,EAAagL,eAC7BhL,EAAagL,cAAc6L,SAEnC,CAER,CAIA+K,sBACI,IAAIrlB,KAAKmlB,0CAGLnlB,KAAKU,mBACLV,KAAKU,kBAAkB2kB,sBAEvBrlB,KAAKme,UACL,IAAK,IAAImH,EAAI,EAAGA,EAAItlB,KAAKme,SAAShX,OAAQme,IAAK,CAC3C,MAAMC,EAAUvlB,KAAKme,SAASmH,GAC1BC,GAAWA,EAAQC,YACnBD,EAAQF,qBAEhB,CAER,CAEAI,6BACI,OAAOzlB,KAAKgO,sBAChB,CAUA0X,mBAAmBC,GAA2B,EAAOC,EAAWC,EAASC,GAAe,EAAMC,GAAqB,GAoB/G,OAnBA/lB,KAAKiZ,kBAAiB,KAClB,GAAKjZ,KAAKyD,aAAV,CAWA,GAPKzD,KAAKgH,gBACNhH,KAAKgmB,wBAEThmB,KAAKimB,wBACLjmB,KAAKgR,qBAAsB,EAC3BhR,KAAKiR,mCAAqC8U,EAC1C/lB,KAAKkR,oCAAsCyU,EACvCG,EACA,IAAK,IAAI3P,EAAQ,EAAGA,EAAQnW,KAAKyO,cAActH,OAAQgP,IACnDnW,KAAKyO,cAAcoC,KAAKsF,GAAO+P,UAGvCN,GAAaA,GAbb,MAFIC,GAAWA,EAAQ,yBAeC,IAErB7lB,IACX,CAKAmmB,uBACI,IAAK,IAAIhQ,EAAQ,EAAGA,EAAQnW,KAAK2S,OAAOxL,OAAQgP,IAAS,CACrD,MAAMtD,EAAO7S,KAAK2S,OAAOwD,GACrBtD,EAAKuT,gCACLvT,EAAKuT,8BAA8BC,WAAY,EAEvD,CACA,IAAK,IAAIlQ,EAAQ,EAAGA,EAAQnW,KAAKyO,cAActH,OAAQgP,IACnDnW,KAAKyO,cAAcoC,KAAKsF,GAAOmQ,YAGnC,OADAtmB,KAAKgR,qBAAsB,EACpBhR,IACX,CACAwc,+BAA+B+J,KACNvmB,KAAKqR,QAAQmV,mBAA4D,IAAvCxmB,KAAKqR,QAAQoV,wBAC/CzmB,KAAKgR,qBAAuBhR,KAAKyO,cAActH,QAIpEnH,KAAKiC,yBAAyBiX,SAAQ,IAAMqN,EAAUjM,WAC1D,CACA2L,wBACI,IAAI5iB,EACJ,GAAIrD,KAAKqR,QAAQmV,mBAA4D,IAAvCxmB,KAAKqR,QAAQoV,sBAU/C,YATIzmB,KAAKyO,cAActH,OAAS,IACC,QAA5B9D,EAAKrD,KAAKyD,oBAAiC,IAAPJ,GAAyBA,EAAGoL,cAAc6H,QAC/EtW,KAAKyO,cAAc6H,QACnBtW,KAAKU,kBAAkB4V,QACvBtW,KAAK0O,oBAAoB4H,QACzBtW,KAAK6O,uBAAuByH,QAC5BtW,KAAK8O,iBAAiBwH,QACtBtW,KAAK+O,uBAAuBuH,UAIpC,GAAItW,KAAKgR,qBAAuBhR,KAAKyO,cAActH,OAAQ,CACvD,IAAKnH,KAAKkR,oCAAqC,CAC3C,MAAMwV,EAAM1mB,KAAKyO,cAActH,OAC/B,IAAK,IAAIme,EAAI,EAAGA,EAAIoB,EAAKpB,IAAK,CACbtlB,KAAKyO,cAAcoC,KAAKyU,GAChCqB,oBACT,CACJ,CACA,GAAI3mB,KAAK6O,uBAAwB,CAC7B,MAAM+X,EAAW5mB,KAAK6O,uBAAuB1H,OAC7C,IAAK,IAAIme,EAAI,EAAGA,EAAIsB,EAAUtB,IAC1BtlB,KAAK6O,uBAAuBgC,KAAKyU,GAAGuB,SAE5C,CAEA,YADA7mB,KAAKU,kBAAkBomB,cAE3B,CACA,IAAK9mB,KAAKyD,aACN,OAEJzD,KAAK4J,yCAAyC3I,gBAAgBjB,MAC9DA,KAAKyD,aAAagL,cAAc6H,QAChCtW,KAAKyO,cAAc6H,QACnBtW,KAAKU,kBAAkB4V,QACvBtW,KAAK0O,oBAAoB4H,QACzBtW,KAAK6O,uBAAuByH,QAC5BtW,KAAK8O,iBAAiBwH,QACtBtW,KAAK+O,uBAAuBuH,QAC5BtW,KAAK4O,wBAAwB0H,QAC7B,IAAK,MAAMM,KAAQ5W,KAAKyP,+BACpBmH,EAAKC,SAGT,MAAMlE,EAAS3S,KAAK+S,0BAEd2T,EAAM/T,EAAOxL,OACnB,IAAK,IAAIme,EAAI,EAAGA,EAAIoB,EAAKpB,IAAK,CAC1B,MAAMzS,EAAOF,EAAO9B,KAAKyU,GAEzB,GADAzS,EAAKuT,8BAA8BW,uBAAwB,EACvDlU,EAAKmU,UACL,SAGJ,GADAhnB,KAAKuN,eAAe0Z,SAASpU,EAAKoB,oBAAoB,IACjDpB,EAAKkD,YAAclD,EAAKqU,aAAerU,EAAKsU,QAAQC,kBACrD,SAEJvU,EAAK8T,qBAED9T,EAAKwU,eAAiBxU,EAAKwU,cAAcC,qBAAqB,GAAI,KAClEtnB,KAAKqN,wBAAwBka,gBAAgB1U,GAGjD,IAAI2U,EAAexnB,KAAKynB,kBAAoBznB,KAAKynB,kBAAkB5U,EAAM7S,KAAKyD,cAAgBoP,EAAK6U,OAAO1nB,KAAKyD,cAG/G,GAFAoP,EAAKuT,8BAA8BuB,YAAcH,EACjD3U,EAAKuT,8BAA8BW,uBAAwB,EACvDS,UAIAA,IAAiB3U,GAAuC,IAA/B2U,EAAaI,eACtCJ,EAAab,qBAEjB9T,EAAKgV,eACDhV,EAAKiV,WACLjV,EAAKkB,WAAa,GACiC,IAAlDlB,EAAKkV,UAAY/nB,KAAKyD,aAAaskB,aACnC/nB,KAAKoB,sBAAwByR,EAAKmV,0BAA4BnV,EAAKmS,YAAYhlB,KAAKgH,kBAAkB,CACvGhH,KAAKyO,cAAcjH,KAAKqL,GACxB7S,KAAKyD,aAAagL,cAAcjH,KAAKqL,GACjC2U,IAAiB3U,GACjB2U,EAAaS,UAAUjoB,KAAK6N,WAAW,GAE3C,IAAK,MAAM+I,KAAQ5W,KAAK2P,oBACpBiH,EAAKC,OAAOhE,GAEZA,EAAKoV,UAAUjoB,KAAK6N,WAAW,KAC1BgF,EAAKqV,aAIFrV,EAAKuT,8BAA8B+B,oBACnCX,EAAe3U,GAJnB2U,EAAapB,8BAA8BgC,mBAAoB,EAOnEZ,EAAapB,8BAA8BC,WAAY,EACvDrmB,KAAKqoB,YAAYxV,EAAM2U,IAE3B3U,EAAKyV,eACT,CACJ,CAGA,GAFAtoB,KAAK6J,wCAAwC5I,gBAAgBjB,MAEzDA,KAAK0M,iBAAkB,CACvB1M,KAAK8J,qCAAqC7I,gBAAgBjB,MAC1D,IAAK,IAAIuoB,EAAgB,EAAGA,EAAgBvoB,KAAK2X,gBAAgBxQ,OAAQohB,IAAiB,CACtF,MAAM7Q,EAAiB1X,KAAK2X,gBAAgB4Q,GAC5C,IAAK7Q,EAAe8Q,cAAgB9Q,EAAe+Q,QAC/C,SAEJ,MAAMA,EAAU/Q,EAAe+Q,QAC1BA,EAAQC,WAAYD,EAAQvB,cAC7BlnB,KAAK6O,uBAAuBrH,KAAKkQ,GACjCA,EAAemP,UACf7mB,KAAKU,kBAAkBioB,kBAAkBjR,GAEjD,CACA1X,KAAK+J,oCAAoC9I,gBAAgBjB,KAC7D,CACJ,CACAqoB,YAAYO,EAAY/V,GAChB7S,KAAKyG,mBAAuC,OAAlBoM,EAAKsO,eAAuCvM,IAAlB/B,EAAKsO,WACrDnhB,KAAK8O,iBAAiByY,gBAAgB1U,EAAKsO,YAC3CtO,EAAKsO,SAAS0H,UACd7oB,KAAK0N,aAAauZ,SAASpU,EAAKsO,SAASE,MAAMla,QAAQ,IAEtD0L,EAAKiW,0BACN9oB,KAAK+O,uBAAuBwY,gBAAgB1U,IAGpD,IAAIkS,EAAY6D,EAAWG,cAAgBH,EAAWV,cAAgBloB,KAAKwO,oCAAsCxO,KAAKoB,sBAAwByR,EAAKmV,yBACnJ,GAAInV,GAAQA,EAAKC,WAAaD,EAAKC,UAAU3L,OAAS,EAAG,CACrD,MAAM2L,EAAY9S,KAAKiT,2BAA2BJ,GAC5C6T,EAAM5T,EAAU3L,OACtB4d,EAAYA,GAAqB,IAAR2B,EACzB,IAAK,IAAIpB,EAAI,EAAGA,EAAIoB,EAAKpB,IAAK,CAC1B,MAAMtO,EAAUlE,EAAUjC,KAAKyU,GAC/BtlB,KAAK6kB,iBAAiB7N,EAASnE,EAAM+V,EAAY7D,EACrD,CACJ,CACJ,CAKAiB,sBAAsBjE,GAClB,GAAK/hB,KAAKyD,aAGV,GAAIzD,KAAKyD,aAAaulB,oBAAqB,CACvC,MAAMC,EAAajpB,KAAKyD,aAAaylB,YAAY,GAC3CC,EAAcnpB,KAAKyD,aAAaylB,YAAY,GAClDlpB,KAAKga,mBAAmBiP,EAAWtP,gBAAiBsP,EAAWpP,oBAAoBkI,GAAQoH,EAAYxP,gBAAiBwP,EAAYtP,oBAAoBkI,GAC5J,MAEI/hB,KAAKga,mBAAmBha,KAAKyD,aAAakW,gBAAiB3Z,KAAKyD,aAAaoW,oBAAoBkI,GAEzG,CACAqH,iBAAiB3R,EAAQ8B,GAAQ,GACzB9B,GAAUA,EAAO4R,kBACjB5R,EAAO4R,kBAAkBD,mBAEpB3R,GAAUA,EAAO6R,mBACtB7R,EAAO6R,mBAAmBF,mBAGrBppB,KAAKqR,QAAQkY,2CACdvpB,KAAKqR,QAAQmY,4BAGjBjQ,GACAvZ,KAAKypB,kBAAkBhS,EAE/B,CACAgS,kBAAkBhS,GAEd,GAAIA,GAAUA,EAAO4R,wBAGhB,GAAI5R,GAAUA,EAAO6R,qBAAuB7R,EAAOuR,oBAAqB,CACzE,MAAMU,EAAMjS,EAAO6R,mBACfI,EAAIC,kBAAkBC,eACtBF,EAAIC,kBAAkB1oB,gBAAgBjB,KAAKqR,SAErCqY,EAAIG,mBACN7pB,KAAKa,WACLb,KAAKqR,QAAQkI,MAAMmQ,EAAInhB,YAAcvI,KAAKuI,YAAamhB,EAAII,UAAU,GAAM,GAE/EJ,EAAII,UAAW,EAEvB,MAES9pB,KAAKiO,2BAKNjO,KAAKqR,QAAQkI,MAAM,MAAM,GAAO,GAAM,IAJtCvZ,KAAKiO,4BAA6B,EAClCjO,KAAK+pB,SAMjB,CAIAC,iBAAiBvS,EAAQwS,EAAWC,GAAkB,GAClD,IAAI7mB,EAAI4S,EAAIC,EACZ,GAAIuB,GAAUA,EAAO0S,eACjB,OAEJ,MAAMniB,EAAShI,KAAKqR,QAGpB,GADArR,KAAKiG,cAAgBwR,GAChBzX,KAAKyD,aACN,MAAM,IAAI2mB,MAAM,yBAOpB,GAJApiB,EAAOqiB,YAAYrqB,KAAKyD,aAAa6mB,UAErCtqB,KAAK+X,sBACL/X,KAAK6N,aACA7N,KAAKoF,SAAW8kB,EAAiB,CAClC,IAAIL,GAAmB,EACnBpS,EAAOuR,qBAAuBvR,EAAO6R,qBACrCO,EAAmBpS,EAAO6R,mBAAmBO,iBACzC7pB,KAAKa,YACLb,KAAKiO,4BAA6B,EAClCwJ,EAAO6R,mBAAmBO,kBAAmB,IAGrD7pB,KAAKopB,iBAAiBppB,KAAKiG,eACvBwR,EAAOuR,qBAAuBvR,EAAO6R,qBACrC7R,EAAO6R,mBAAmBO,iBAAmBA,EAErD,CACA7pB,KAAKgmB,wBACLhmB,KAAKuC,+BAA+BtB,gBAAgBjB,KAAKyD,cAEzDzD,KAAKimB,wBAEL,IAAK,IAAIsE,EAA2B,EAAGA,EAA2BvqB,KAAK+O,uBAAuB5H,OAAQojB,IAA4B,CAC9H,MAAM1X,EAAO7S,KAAK+O,uBAAuB8B,KAAK0Z,GAC9C1X,EAAK2X,cAAc3X,EAAKsO,SAC5B,CAEAnhB,KAAKmL,sCAAsClK,gBAAgBjB,MAC3DA,KAAK2O,eAAe0I,sBAAsBrX,KAAK4O,yBAC3C6I,EAAOvK,qBAAuBuK,EAAOvK,oBAAoB/F,OAAS,GAClEnH,KAAK2O,eAAe0I,sBAAsBI,EAAOvK,qBAEjD+c,GAAaA,EAAU/c,qBAAuB+c,EAAU/c,oBAAoB/F,OAAS,GACrFnH,KAAK2O,eAAe0I,sBAAsB4S,EAAU/c,qBAEpDlN,KAAKD,oBAAsBC,KAAKD,mBAAmB0qB,gBACnDzqB,KAAK2O,eAAe4Y,gBAAgBvnB,KAAKD,oBAG7C,IAAK,MAAM6W,KAAQ5W,KAAKuP,sCACpBqH,EAAKC,OAAO7W,KAAK2O,gBAErB,IAAI+b,GAAa,EACjB,GAAI1qB,KAAKgN,qBAAsB,CAE3B,GADAhN,KAAKgO,wBAAyB,EAC1BhO,KAAK2O,eAAexH,OAAS,EAAG,CAChC,6BAA8B,iBAAkBnH,KAAK2O,eAAexH,OAAS,GAC7E,IAAK,IAAIwjB,EAAc,EAAGA,EAAc3qB,KAAK2O,eAAexH,OAAQwjB,IAAe,CAC/E,MAAMC,EAAe5qB,KAAK2O,eAAekC,KAAK8Z,GAC9C,GAAIC,EAAaC,gBAAiB,CAC9B7qB,KAAK6N,YACL,MAAMid,EAA+BF,EAAannB,cAAgBmnB,EAAannB,eAAiBzD,KAAKyD,aACrGmnB,EAAaG,OAAOD,EAA8B9qB,KAAKiN,uBACvDyd,GAAa,CACjB,CACJ,CACA,2BAA4B,iBAAkB1qB,KAAK2O,eAAexH,OAAS,GAC3EnH,KAAK6N,WACT,CACA,IAAK,MAAM+I,KAAQ5W,KAAK4P,6BACpB8a,EAAa9T,EAAKC,OAAO7W,KAAKyD,eAAiBinB,EAEnD1qB,KAAKgO,wBAAyB,CAClC,CACAhO,KAAKqR,QAAQ+E,oBAAmL,QAA5JF,EAAsG,QAAhGD,EAA0C,QAApC5S,EAAKoU,EAAO6R,0BAAuC,IAAPjmB,OAAgB,EAASA,EAAGgT,oBAAiC,IAAPJ,EAAgBA,EAAKwB,EAAOpB,oBAAiC,IAAPH,EAAgBA,EAAK,EAEzNwU,IAAe1qB,KAAKoF,SACpBpF,KAAKopB,iBAAiBppB,KAAKiG,eAAe,GAE9CjG,KAAKoL,qCAAqCnK,gBAAgBjB,OAEtDA,KAAKoS,oBAAuBqF,EAAO4R,mBAAsBrpB,KAAKoF,SAC9DpF,KAAKoS,mBAAmB4Y,gBAG5B,IAAK,MAAMpU,KAAQ5W,KAAK6P,uBACpB+G,EAAKC,OAAO7W,KAAKyD,cAGrBzD,KAAKyJ,4BAA4BxI,gBAAgBjB,MAC7CgI,EAAOwe,mBAAsD,IAAjCxe,EAAOye,uBACnCzmB,KAAKmE,mBAETnE,KAAKU,kBAAkBqqB,OAAO,KAAM,MAAM,GAAM,GAChD/qB,KAAK0J,2BAA2BzI,gBAAgBjB,MAEhD,IAAK,MAAM4W,KAAQ5W,KAAKmQ,sBACpByG,EAAKC,OAAO7W,KAAKyD,cAGrB,GAAIzD,KAAKoS,qBAAuBqF,EAAO4R,kBAAmB,CAEtD,MAAM9D,EAAU9N,EAAO6R,mBAAqB7R,EAAO6R,mBAAmBsB,kBAAehW,EACrF5U,KAAKoS,mBAAmB6Y,eAAexT,EAAOyT,eAAgB3F,EAClE,CAEA,IAAK,MAAM3O,KAAQ5W,KAAKoQ,6BACpBwG,EAAKC,OAAO7W,KAAKyD,cAGrBzD,KAAK2O,eAAe2H,QACpBtW,KAAK0C,8BAA8BzB,gBAAgBjB,KAAKyD,aAC5D,CACA0nB,mBAAmB1T,EAAQyS,GAAkB,GACzC,GAA6B,IAAzBzS,EAAO2T,eAAuB3T,EAAOuR,oBAMrC,OALIvR,EAAOuR,sBAAwBhpB,KAAKqa,oBACpCra,KAAKqrB,sBAETrrB,KAAKgqB,iBAAiBvS,OAAQ7C,EAAWsV,QACzClqB,KAAKsJ,8BAA8BrI,gBAAgBwW,GAGvD,GAAIA,EAAO6T,0BACPtrB,KAAKurB,6BAA6B9T,OAEjC,CAEDzX,KAAKuC,+BAA+BtB,gBAAgBwW,GACpD,IAAK,IAAItB,EAAQ,EAAGA,EAAQsB,EAAOyR,YAAY/hB,OAAQgP,IACnDnW,KAAKgqB,iBAAiBvS,EAAOyR,YAAY/S,GAAQsB,EAEzD,CAEAzX,KAAKiG,cAAgBwR,EACrBzX,KAAKgmB,wBACLhmB,KAAKsJ,8BAA8BrI,gBAAgBwW,EACvD,CACA+T,sBACI,IAAK,IAAIrV,EAAQ,EAAGA,EAAQnW,KAAKqN,wBAAwBlG,OAAQgP,IAAS,CACtE,MAAMyS,EAAa5oB,KAAKqN,wBAAwBwD,KAAKsF,GACrD,GAAKyS,EAAWvB,cAGhB,IAAK,IAAIoE,EAAc,EAAG7C,EAAWvB,eAAiBoE,EAAc7C,EAAWvB,cAAcqE,QAAQvkB,OAAQskB,IAAe,CACxH,MAAM5U,EAAS+R,EAAWvB,cAAcqE,QAAQD,GAChD,GAAuB,KAAnB5U,EAAO8U,SAAqC,KAAnB9U,EAAO8U,QAAgB,CAChD,MAAMC,EAAa/U,EAAOgV,sBACpBC,EAAYF,EAAW/Y,KAAO+Y,EAAW/Y,KAAO+Y,EAChDG,EAAkBD,EAAUE,eAAepD,EAAYgD,EAAWK,wBAClEC,EAAgCtD,EAAWuD,yBAAyB/U,QAAQ0U,GAC9EC,IAAsD,IAAnCG,EACI,KAAnBrV,EAAO8U,SACP9U,EAAOuV,gBAAgB,cAAsBxD,OAAYhU,EAAWkX,IACpElD,EAAWuD,yBAAyB3kB,KAAKskB,IAEjB,KAAnBjV,EAAO8U,SACZ/C,EAAWuD,yBAAyB3kB,KAAKskB,IAGvCC,GAAmBG,GAAiC,IAGnC,KAAnBrV,EAAO8U,SACP9U,EAAOuV,gBAAgB,cAAsBxD,OAAYhU,EAAWkX,IAGnElD,EAAWvB,cAAcgF,mBAAmB,IAAKC,IAClD,MAAMC,EAAgBD,EAAUzZ,KAAOyZ,EAAUzZ,KAAOyZ,EACxD,OAAOR,IAAcS,CAAa,KAEf,KAAnB1V,EAAO8U,SACP/C,EAAWuD,yBAAyBpT,OAAOmT,EAA+B,GAGtF,CACJ,CACJ,CACJ,CAIAM,0BAA0B5V,GAE1B,CAEA6V,WAEA,CAEA5F,UACI,GAAI7mB,KAAKqR,QAAQqb,0BAA2B,CACxC,IAAIC,EAAYC,KAAKC,IAAIjtB,EAAMktB,aAAcF,KAAKG,IAAI/sB,KAAKqR,QAAQ2b,eAAgBptB,EAAMqtB,eAAiBjtB,KAAKkM,iBAC/G,MAAMghB,EAAmBltB,KAAKqR,QAAQC,cAChC6b,EAAa,IAASD,EAAmB,IAC/C,IAAIE,EAAa,EACjB,MAAMC,EAAcrtB,KAAKqR,QAAQic,sBACjC,IAAIC,EAAgBX,KAAKY,MAAMb,EAAYO,GAE3C,IADAK,EAAgBX,KAAKG,IAAIQ,EAAeF,GACjCV,EAAY,GAAKS,EAAaG,GACjCvtB,KAAKqL,uBAAuBpK,gBAAgBjB,MAE5CA,KAAK6U,gBAAkBqY,EAAmBC,EAC1CntB,KAAKysB,WACLzsB,KAAKwJ,4BAA4BvI,gBAAgBjB,MAE7CA,KAAKyM,gBACLzM,KAAKwsB,0BAA0BU,GAEnCltB,KAAKsL,sBAAsBrK,gBAAgBjB,MAC3CA,KAAK4E,iBACLwoB,IACAT,GAAaO,EAEjBltB,KAAKkM,iBAAmBygB,EAAY,EAAI,EAAIA,CAChD,KACK,CAED,MAAMA,EAAY3sB,KAAK2I,8BAAgC,GAAKikB,KAAKC,IAAIjtB,EAAMktB,aAAcF,KAAKG,IAAI/sB,KAAKqR,QAAQ2b,eAAgBptB,EAAMqtB,eACrIjtB,KAAK6U,gBAA8B,IAAZ8X,EACvB3sB,KAAKysB,WACLzsB,KAAKwJ,4BAA4BvI,gBAAgBjB,MAE7CA,KAAKyM,gBACLzM,KAAKwsB,0BAA0BG,EAEvC,CACJ,CACA5C,UACQ/pB,KAAKsI,0BAA4BtI,KAAKa,YACtCb,KAAKqR,QAAQkI,MAAMvZ,KAAKuI,WAAYvI,KAAKa,WAAab,KAAKkB,gBAAkBlB,KAAKqB,iBAAkBrB,KAAKsI,yBAA0BtI,KAAKsI,yBAEhJ,CACAmlB,yBAAyBhW,GACrB,IAAIpU,EAIJ,IAHKoU,aAAuC,EAASA,EAAO6R,uBAAyB7R,aAAuC,EAASA,EAAOiW,eACxIjW,EAAO6R,mBAAmBQ,UAAW,GAEwC,QAA5EzmB,EAAKoU,aAAuC,EAASA,EAAOkW,kBAA+B,IAAPtqB,OAAgB,EAASA,EAAG8D,OACjH,IAAK,IAAIme,EAAI,EAAGA,EAAI7N,EAAOkW,WAAWxmB,SAAUme,EAAG,CAC/C,MAAMoE,EAAMjS,EAAOkW,WAAWrI,GAAGgE,mBAC7BI,IACAA,EAAII,UAAW,EAEvB,CAER,CAKA8D,eAAeC,GACX,GAAK7tB,KAAK2S,OAGV,IAAK,MAAME,KAAQ7S,KAAK2S,OACpBE,EAAK+a,eAAeC,EAE5B,CAMA9C,OAAO+C,GAAgB,EAAMC,GAAmB,GAC5C,IAAI1qB,EAAI4S,EAAIC,EACZ,GAAIlW,KAAKguB,WACL,OAEAhuB,KAAK2J,kBAAkBigB,gBAAsD,OAApC5pB,KAAK+N,4BAC9C/N,KAAKmZ,gBAETnZ,KAAK8N,WACL9N,KAAKiO,4BAA6B,EAClCjO,KAAKytB,yBAAyBztB,KAAKyD,eACD,QAA7BJ,EAAKrD,KAAK4F,qBAAkC,IAAPvC,OAAgB,EAASA,EAAG8D,SAClEnH,KAAK4F,cAAc4V,QAAQxb,KAAKytB,0BAGpCztB,KAAKiH,+BACLjH,KAAKyN,iBAAiBwgB,gBACtBjuB,KAAKuN,eAAe0gB,gBACpBjuB,KAAKwN,eAAeygB,gBACpBjuB,KAAK0N,aAAaugB,gBAClBjuB,KAAKqN,wBAAwBiJ,QAC7BtW,KAAK+X,sBACL/X,KAAKuJ,6BAA6BtI,gBAAgBjB,MAE9CA,KAAKqnB,eACLrnB,KAAKqnB,cAAc6G,eAAe,IAGjCH,GACD/tB,KAAK6mB,UAGT,IAAK,MAAMjQ,KAAQ5W,KAAKmP,yBACpByH,EAAKC,SAGT,GAAIiX,EACA,GAAI9tB,KAAK4F,eAAiB5F,KAAK4F,cAAcuB,OAAS,EAClD,IAAK,IAAIgnB,EAAc,EAAGA,EAAcnuB,KAAK4F,cAAcuB,OAAQgnB,IAAe,CAC9E,MAAM1W,EAASzX,KAAK4F,cAAcuoB,GAElC,GADA1W,EAAOjT,SACsB,IAAzBiT,EAAO2T,cAEP,IAAK,IAAIjV,EAAQ,EAAGA,EAAQsB,EAAOyR,YAAY/hB,OAAQgP,IACnDsB,EAAOyR,YAAY/S,GAAO3R,QAGtC,MAEC,GAAIxE,KAAKyD,eACVzD,KAAKyD,aAAae,SACsB,IAApCxE,KAAKyD,aAAa2nB,eAElB,IAAK,IAAIjV,EAAQ,EAAGA,EAAQnW,KAAKyD,aAAaylB,YAAY/hB,OAAQgP,IAC9DnW,KAAKyD,aAAaylB,YAAY/S,GAAO3R,SAMrDxE,KAAKiC,yBAAyBhB,gBAAgBjB,MAC9C,MAAMgI,EAAShI,KAAKgU,YAEpBhU,KAAKmL,sCAAsClK,gBAAgBjB,MAC3D,MAAMouB,GAAqD,QAA7BnY,EAAKjW,KAAK4F,qBAAkC,IAAPqQ,OAAgB,EAASA,EAAG9O,QAAUnH,KAAK4F,cAAc,GAAK5F,KAAKyD,aACtI,GAAIzD,KAAKgN,qBAAsB,CAC3B,6BAA8B,wBAAyBhN,KAAKkN,oBAAoB/F,OAAS,GACzFnH,KAAKgO,wBAAyB,EAC9B,IAAK,IAAIqgB,EAAc,EAAGA,EAAcruB,KAAKkN,oBAAoB/F,OAAQknB,IAAe,CACpF,MAAMzD,EAAe5qB,KAAKkN,oBAAoBmhB,GAC9C,GAAIzD,EAAaC,gBAAiB,CAG9B,GAFA7qB,KAAK6N,YACL7N,KAAKyD,aAAemnB,EAAannB,cAAgBzD,KAAKyD,cACjDzD,KAAKyD,aACN,MAAM,IAAI2mB,MAAM,yBAGpBpiB,EAAOqiB,YAAYrqB,KAAKyD,aAAa6mB,UAErCtqB,KAAKgmB,wBACL4E,EAAaG,OAAOqD,IAAwBpuB,KAAKyD,aAAczD,KAAKiN,sBACxE,CACJ,CACA,2BAA4B,wBAAyBjN,KAAKkN,oBAAoB/F,OAAS,GACvFnH,KAAKgO,wBAAyB,EAC9BhO,KAAK6N,WACT,CACA7N,KAAKqR,QAAQ+E,oBAA4I,QAArHF,EAAKkY,aAAiE,EAASA,EAAoB/X,oBAAiC,IAAPH,EAAgBA,EAAK,EAEtLlW,KAAKyD,aAAe2qB,EAChBpuB,KAAKiG,eAAsD,KAArCjG,KAAKiG,cAAcmlB,gBAAyBprB,KAAKoF,SACvEpF,KAAKopB,iBAAiBppB,KAAKiG,eAAe,GAE9CjG,KAAKoL,qCAAqCnK,gBAAgBjB,MAC1D,IAAK,MAAM4W,KAAQ5W,KAAKoP,kBACpBwH,EAAKC,SAGT7W,KAAKypB,kBAAkBzpB,KAAKyD,cAE5B,IAAK,MAAMmT,KAAQ5W,KAAKsP,0BACpBsH,EAAKC,OAAO7W,KAAK2O,gBAGrB,GAAI3O,KAAK4F,eAAiB5F,KAAK4F,cAAcuB,OAAS,EAClD,IAAK,IAAIgnB,EAAc,EAAGA,EAAcnuB,KAAK4F,cAAcuB,OAAQgnB,IAC/DnuB,KAAKmrB,mBAAmBnrB,KAAK4F,cAAcuoB,GAAcA,EAAc,OAG1E,CACD,IAAKnuB,KAAKyD,aACN,MAAM,IAAI2mB,MAAM,qBAEpBpqB,KAAKmrB,mBAAmBnrB,KAAKyD,eAAgBzD,KAAKyD,aAAa6lB,mBACnE,CAEAtpB,KAAKwrB,sBAEL,IAAK,MAAM5U,KAAQ5W,KAAKuQ,kBACpBqG,EAAKC,SAQT,GALI7W,KAAKkC,aACLlC,KAAKkC,cAETlC,KAAKoC,wBAAwBnB,gBAAgBjB,MAEzCA,KAAKoO,cAAcjH,OAAQ,CAC3B,IAAK,IAAIgP,EAAQ,EAAGA,EAAQnW,KAAKoO,cAAcjH,OAAQgP,IAAS,CAC5D,MAAMtF,EAAO7Q,KAAKoO,cAAc+H,GAC5BtF,GACAA,EAAKyJ,SAEb,CACAta,KAAKoO,cAAcjH,OAAS,CAChC,CACInH,KAAKiN,wBACLjN,KAAKiN,uBAAwB,GAEjCjN,KAAK0N,aAAauZ,SAAS,GAAG,GAC9BjnB,KAAKwN,eAAeyZ,SAAS,GAAG,GAChCjnB,KAAKyN,iBAAiBwZ,SAAS,GAAG,GAClCjnB,KAAKqR,QAAQmY,2BACjB,CAMA8E,kBACI,IAAK,IAAIhJ,EAAI,EAAGA,EAAItlB,KAAK8d,UAAU3W,OAAQme,IACvCtlB,KAAK8d,UAAUwH,GAAGiJ,QAE1B,CAKAC,oBACI,IAAK,IAAIlJ,EAAI,EAAGA,EAAItlB,KAAK8d,UAAU3W,OAAQme,IACvCtlB,KAAK8d,UAAUwH,GAAGmJ,UAE1B,CAIAnU,UACI,GAAIta,KAAKguB,WACL,OAEJhuB,KAAK+B,aAAe,KACpB/B,KAAKkC,YAAc,KACnBlC,KAAKkJ,SAAW,KAChBlJ,KAAKuc,UAAUpV,OAAS,EACxBnH,KAAK0c,oBAAoBvV,OAAS,EAClCnH,KAAKkH,qBAAqBC,OAAS,EACnCnH,KAAKwP,qBAAqB+J,QAC1BvZ,KAAKyP,+BAA+B8J,QACpCvZ,KAAK0P,sBAAsB6J,QAC3BvZ,KAAK2P,oBAAoB4J,QACzBvZ,KAAK4P,6BAA6B2J,QAClCvZ,KAAK6P,uBAAuB0J,QAC5BvZ,KAAK8P,6BAA6ByJ,QAClCvZ,KAAK+P,+BAA+BwJ,QACpCvZ,KAAKgQ,0BAA0BuJ,QAC/BvZ,KAAKiQ,yBAAyBsJ,QAC9BvZ,KAAKkQ,8BAA8BqJ,QACnCvZ,KAAKmQ,sBAAsBoJ,QAC3BvZ,KAAKqQ,4BAA4BkJ,QACjCvZ,KAAKuQ,kBAAkBgJ,QACvBvZ,KAAKmP,yBAAyBoK,QAC9BvZ,KAAKoP,kBAAkBmK,QACvBvZ,KAAKsP,0BAA0BiK,QAC/BvZ,KAAKuP,sCAAsCgK,QAC3CvZ,KAAKwQ,kBAAkB+I,QACvBvZ,KAAKyQ,kBAAkB8I,QACvBvZ,KAAK0Q,gBAAgB6I,QACrBvZ,KAAKmN,oBAAsB,IAAI9D,MAC3BrJ,KAAK0uB,mBACL1uB,KAAK0uB,oBAET1uB,KAAK+X,sBAED/X,KAAKyD,eACLzD,KAAKyD,aAAagL,cAAc6L,UAChCta,KAAKyD,aAAe,MAExBzD,KAAK4F,cAAgB,KACrB5F,KAAKyO,cAAc6L,UACnBta,KAAKU,kBAAkB4Z,UACvBta,KAAK0O,oBAAoB4L,UACzBta,KAAK6O,uBAAuByL,UAC5Bta,KAAK8O,iBAAiBwL,UACtBta,KAAK+O,uBAAuBuL,UAC5Bta,KAAK2O,eAAe2L,UACpBta,KAAK4O,wBAAwB0L,UAC7Bta,KAAK2L,oCAAoC2O,UACzCta,KAAKqN,wBAAwBiN,UAC7Bta,KAAKoO,cAAcjH,OAAS,EAE5B,MAAMwnB,EAAiB3uB,KAAKqO,gBAAgBugB,QAC5C,IAAK,MAAMC,KAAWF,EAClBE,EAAQC,QAEZ9uB,KAAKqO,gBAAgBlH,OAAS,EAE9B,IACInH,KAAK4B,oBAAoBX,gBAAgBjB,KAC7C,CACA,MAAO+uB,GACHC,QAAQC,MAAM,uDAAwDF,EAC1E,CACA/uB,KAAK8V,gBAGL,GADe9V,KAAKqR,QAAQ2O,kBAExB,IAAK,IAAI7J,EAAQ,EAAGA,EAAQnW,KAAK8F,QAAQqB,OAAQgP,IAC7CnW,KAAK8F,QAAQqQ,GAAOL,gBAI5B9V,KAAKkvB,aAAalvB,KAAKyd,iBAEvBzd,KAAKkvB,aAAalvB,KAAK4c,QAEvB5c,KAAKkvB,aAAalvB,KAAK2S,QAASwc,GAASA,EAAK7U,SAAQ,KACtDta,KAAKkvB,aAAalvB,KAAKmc,gBAAiBgT,GAASA,EAAK7U,SAAQ,KAE9D,MAAMxU,EAAU9F,KAAK8F,QACrB9F,KAAKkvB,aAAappB,GAEd9F,KAAKoG,kBACLpG,KAAKoG,iBAAiBkU,UAE1Bta,KAAKkvB,aAAalvB,KAAK2d,gBACvB3d,KAAKkvB,aAAalvB,KAAK8d,WAEvB9d,KAAKkvB,aAAalvB,KAAK2X,iBAEvB3X,KAAKkvB,aAAalvB,KAAKgkB,eAEvBhkB,KAAKkvB,aAAalvB,KAAKme,UAEvBne,KAAKkvB,aAAalvB,KAAK0c,qBAEvB1c,KAAK2a,UAAUL,UACXta,KAAKqa,oBACLra,KAAKqa,mBAAmBC,UAG5Bta,KAAKoS,mBAAmBkI,UAExBta,KAAKkvB,aAAalvB,KAAKuH,aAEvB,IAAI4O,EAAQnW,KAAKqR,QAAQa,OAAOkF,QAAQpX,MACpCmW,GAAS,GACTnW,KAAKqR,QAAQa,OAAO6G,OAAO5C,EAAO,GAElC,wBAAkCnW,OAC9BA,KAAKqR,QAAQa,OAAO/K,OAAS,EAC7B,sBAAgCnH,KAAKqR,QAAQa,OAAOlS,KAAKqR,QAAQa,OAAO/K,OAAS,GAGjF,sBAAgC,MAGxCgP,EAAQnW,KAAKqR,QAAQY,eAAemF,QAAQpX,MACxCmW,GAAS,GACTnW,KAAKqR,QAAQY,eAAe8G,OAAO5C,EAAO,GAE9CnW,KAAKqR,QAAQ+d,YAAW,GACxBpvB,KAAK4B,oBAAoB2X,QACzBvZ,KAAKiC,yBAAyBsX,QAC9BvZ,KAAKoC,wBAAwBmX,QAC7BvZ,KAAKmL,sCAAsCoO,QAC3CvZ,KAAKoL,qCAAqCmO,QAC1CvZ,KAAKsL,sBAAsBiO,QAC3BvZ,KAAKqL,uBAAuBkO,QAC5BvZ,KAAK4J,yCAAyC2P,QAC9CvZ,KAAK6J,wCAAwC0P,QAC7CvZ,KAAK8J,qCAAqCyP,QAC1CvZ,KAAK+J,oCAAoCwP,QACzCvZ,KAAKyJ,4BAA4B8P,QACjCvZ,KAAK0J,2BAA2B6P,QAChCvZ,KAAKuJ,6BAA6BgQ,QAClCvZ,KAAKwJ,4BAA4B+P,QACjCvZ,KAAKgK,uBAAuBuP,QAC5BvZ,KAAKuL,iCAAiCgO,QACtCvZ,KAAKwL,gCAAgC+N,QACrCvZ,KAAKyL,yBAAyB8N,QAC9BvZ,KAAKuC,+BAA+BgX,QACpCvZ,KAAK0C,8BAA8B6W,QACnCvZ,KAAKsJ,8BAA8BiQ,QACnCvZ,KAAK2J,kBAAkB4P,QACvBvZ,KAAKiK,2BAA2BsP,QAChCvZ,KAAKkK,0BAA0BqP,QAC/BvZ,KAAKmK,0BAA0BoP,QAC/BvZ,KAAKoK,yBAAyBmP,QAC9BvZ,KAAKqK,6BAA6BkP,QAClCvZ,KAAKsK,4BAA4BiP,QACjCvZ,KAAKuK,kCAAkCgP,QACvCvZ,KAAKwK,iCAAiC+O,QACtCvZ,KAAKyK,yBAAyB8O,QAC9BvZ,KAAK0K,wBAAwB6O,QAC7BvZ,KAAK2K,6BAA6B4O,QAClCvZ,KAAK4K,4BAA4B2O,QACjCvZ,KAAK6K,6BAA6B0O,QAClCvZ,KAAK8K,kCAAkCyO,QACvCvZ,KAAK+K,4BAA4BwO,QACjCvZ,KAAKgL,iCAAiCuO,QACtCvZ,KAAKiL,4BAA4BsO,QACjCvZ,KAAKkL,2BAA2BqO,QAChCvZ,KAAK8L,uBAAuByN,QAC5BvZ,KAAK+L,oBAAoBwN,QACzBvZ,KAAKgM,wBAAwBuN,QAC7BvZ,KAAKiM,qBAAqBsN,QAC1BvZ,KAAKkG,sBAAsBqT,QAC3BvZ,KAAKgB,4CAA4CuY,QACjDvZ,KAAKuO,aAAc,CACvB,CACA2gB,aAAaG,EAAO3tB,GAChB,MAAM4tB,EAAYD,EAAMT,MAAM,GAC9BltB,EAAWA,QAA2CA,EAAaytB,GAASA,EAAK7U,UACjF,IAAK,MAAM6U,KAAQG,EACf5tB,EAASytB,GAEbE,EAAMloB,OAAS,CACnB,CAII6mB,iBACA,OAAOhuB,KAAKuO,WAChB,CAKAghB,wBACI,IAAK,IAAIC,EAAY,EAAGA,EAAYxvB,KAAK2S,OAAOxL,OAAQqoB,IAAa,CACjE,MACM1N,EADO9hB,KAAK2S,OAAO6c,GACH1N,SAClBA,GACAA,EAAS2N,iBAEjB,CACJ,CAKAC,2BACI,IAAK,MAAMC,KAAe3vB,KAAKme,SAAU,CACtBwR,EAAYC,UAEvBD,EAAYC,QAAU,KAE9B,CACJ,CAOAC,gBAAgBC,GACZ,MAAM/C,EAAM,IAAI,IAAQgD,OAAOC,UAAWD,OAAOC,UAAWD,OAAOC,WAC7DnD,EAAM,IAAI,KAASkD,OAAOC,WAAYD,OAAOC,WAAYD,OAAOC,WAatE,OAZAF,EAAkBA,GAAmB,MAAO,GAC5C9vB,KAAK2S,OAAO0P,OAAOyN,GAAiBtU,SAAS3I,IAEzC,GADAA,EAAK8T,oBAAmB,IACnB9T,EAAKC,WAAuC,IAA1BD,EAAKC,UAAU3L,QAAgB0L,EAAKod,iBACvD,OAEJ,MAAMC,EAAerd,EAAKsd,kBACpBC,EAASF,EAAaG,YAAYC,aAClCC,EAASL,EAAaG,YAAYG,aACxC,iBAAqBJ,EAAQrD,EAAKF,GAClC,iBAAqB0D,EAAQxD,EAAKF,EAAI,IAEnC,CACHE,IAAKA,EACLF,IAAKA,EAEb,CAWA4D,iBAAiB3sB,EAAGC,EAAG2sB,EAAOjZ,EAAQkZ,GAAkB,GACpD,MAAM,OAAY,MACtB,CAYAC,sBAAsB9sB,EAAGC,EAAG2sB,EAAOG,EAAQpZ,EAAQkZ,GAAkB,EAAOG,GAAuB,GAC/F,MAAM,OAAY,MACtB,CAQAC,8BAA8BjtB,EAAGC,EAAG0T,GAChC,MAAM,OAAY,MACtB,CASAuZ,mCAAmCltB,EAAGC,EAAG8sB,EAAQpZ,GAC7C,MAAM,OAAY,MACtB,CAEIwZ,wBACA,OAAO,CACX,CAUAC,KAAKptB,EAAGC,EAAG0c,EAAW0Q,EAAW1Z,EAAQ2Z,GAErC,OAAO,IAAI,GACf,CASAC,qBAAqBvtB,EAAGC,EAAG0c,EAAW0Q,EAAW1Z,GAE7C,OAAO,IAAI,GACf,CAUA6Z,YAAYC,EAAK9Q,EAAW0Q,EAAWC,GACnC,MAAM,OAAY,MACtB,CAWAI,UAAU1tB,EAAGC,EAAG0c,EAAWhJ,EAAQ2Z,GAC/B,MAAM,OAAY,MACtB,CAQAK,iBAAiBF,EAAK9Q,EAAW2Q,GAC7B,MAAM,OAAY,MACtB,CAOAM,mBAAmB7e,EAAM6C,EAAWN,GAChCpV,KAAK4C,cAAc8uB,mBAAmB7e,EAAM6C,EAAWN,EAC3D,CAKAuc,qBACI,OAAO3xB,KAAK4C,cAAc+uB,oBAC9B,CAGAC,qBACI,IAAK,MAAM9P,KAAY9hB,KAAKuX,WACxBuK,EAAS+P,WAEb,IAAK,MAAMhf,KAAQ7S,KAAK2S,OACpBE,EAAKgf,WAEL7xB,KAAKoS,oBACLpS,KAAKoS,mBAAmByf,WAE5B,IAAK,MAAMzqB,KAAapH,KAAKuH,YACzBH,EAAU0qB,UAEd,IAAK,MAAMC,KAAU/xB,KAAK2X,gBACtBoa,EAAOD,UAEX,GAAI9xB,KAAKgyB,eACL,IAAK,MAAMC,KAAajyB,KAAKgyB,eACzBC,EAAUH,SAGtB,CAEAI,mBACI,IAAK,MAAM3M,KAAWvlB,KAAKme,SACvBoH,EAAQsM,WAEZ7xB,KAAKG,wBAAwB,EACjC,CAEAgyB,WAAWC,EAAMC,EAAW7W,GACxB,QAAkB5G,IAAdyd,EAEA,OAAOD,EAEX,MAAME,EAAa,GACnB9W,EACIA,GACI,CAAE2T,IAED,GACT,IAAK,MAAM7J,KAAK8M,EAAM,CAClB,MAAMjD,EAAOiD,EAAK9M,GACd,KAAQ,iBAAkB6J,EAAMkD,KAChCC,EAAW9qB,KAAK2nB,GAChB3T,EAAQ2T,GAEhB,CACA,OAAOmD,CACX,CAOAC,gBAAgBF,EAAW7W,GACvB,OAAOxb,KAAKmyB,WAAWnyB,KAAK2S,OAAQ0f,EAAW7W,EACnD,CAOAgX,iBAAiBH,EAAW7W,GACxB,OAAOxb,KAAKmyB,WAAWnyB,KAAK8F,QAASusB,EAAW7W,EACpD,CAOAiX,gBAAgBJ,EAAW7W,GACvB,OAAOxb,KAAKmyB,WAAWnyB,KAAK4c,OAAQyV,EAAW7W,EACnD,CAOAkX,kBAAkBL,EAAW7W,GACzB,OAAOxb,KAAKmyB,WAAWnyB,KAAK8d,UAAWuU,EAAW7W,GAASmX,OAAO3yB,KAAKmyB,WAAWnyB,KAAK2d,eAAgB0U,EAAW7W,GACtH,CAOAoX,wBAAwBP,EAAW7W,GAC/B,OAAOxb,KAAKmyB,WAAWnyB,KAAKmc,eAAgBkW,EAAW7W,EAC3D,CAUAqX,kBAAkBC,EAAkBC,EAAsB,KAAMC,EAAyB,KAAMC,EAA2B,MACtHjzB,KAAKU,kBAAkBmyB,kBAAkBC,EAAkBC,EAAqBC,EAAwBC,EAC5G,CASAC,kCAAkCJ,EAAkBK,EAAuBC,GAAQ,EAAMC,GAAU,GAC/FrzB,KAAKU,kBAAkBwyB,kCAAkCJ,EAAkBK,EAAuBC,EAAOC,EAC7G,CAOAC,8BAA8Bnd,GAC1B,OAAOnW,KAAKU,kBAAkB4yB,8BAA8Bnd,EAChE,CAEIod,kCACA,OAAOvzB,KAAKwR,4BAChB,CACI+hB,gCAA4BrzB,GACxBF,KAAKwR,+BAAiCtR,IAG1CF,KAAKwR,6BAA+BtR,EAC/BA,GAEDF,KAAKG,wBAAwB,IAErC,CAMAA,wBAAwBqzB,EAAM/S,GAC1B,IAAIzgB,KAAKwR,6BAGT,IAAK,MAAMsC,KAAY9T,KAAK8d,UACpB2C,IAAcA,EAAU3M,IAG5BA,EAAS2f,YAAYD,EAE7B,CAIAE,UAAUC,EAAW/N,EAAWgO,EAAYC,EAAmBC,EAAgBjO,EAASkO,GACpF,MAAMlF,GAAU,QAAS8E,EAAW/N,EAAWgO,EAAYC,EAAoB7zB,KAAKg0B,qBAAkBpf,EAAWkf,EAAgBjO,EAASkO,GAK1I,OAJA/zB,KAAKqO,gBAAgB7G,KAAKqnB,GAC1BA,EAAQoF,qBAAqBnyB,KAAK+sB,IAC9B7uB,KAAKqO,gBAAgB0K,OAAO/Y,KAAKqO,gBAAgB+I,QAAQyX,GAAU,EAAE,IAElEA,CACX,CAIAqF,eAAeP,EAAWC,EAAYC,EAAmBC,EAAgBC,GACrE,OAAO,IAAI1a,SAAQ,CAACC,EAAS6a,KACzBn0B,KAAK0zB,UAAUC,GAAY9iB,IACvByI,EAAQzI,EAAK,GACd+iB,EAAYC,EAAmBC,GAAgB,CAACjF,EAASuF,KACxDD,EAAOC,EAAU,GAClBL,EAAS,GAEpB,CAIAM,aAAaC,EAAK1O,EAAWgO,EAAYC,EAAmBC,EAAgBjO,EAASkO,GACjF,MAAMlF,GAAU,QAAYyF,EAAK1O,EAAWgO,EAAYC,EAAoB7zB,KAAKg0B,qBAAkBpf,EAAWkf,EAAgBjO,EAASkO,GAKvI,OAJA/zB,KAAKqO,gBAAgB7G,KAAKqnB,GAC1BA,EAAQoF,qBAAqBnyB,KAAK+sB,IAC9B7uB,KAAKqO,gBAAgB0K,OAAO/Y,KAAKqO,gBAAgB+I,QAAQyX,GAAU,EAAE,IAElEA,CACX,CAIA0F,kBAAkBD,EAAKV,EAAYC,EAAmBC,EAAgBC,GAClE,OAAO,IAAI1a,SAAQ,CAACC,EAAS6a,KACzBn0B,KAAKq0B,aAAaC,GAAMzjB,IACpByI,EAAQzI,EAAK,GACd+iB,EAAYC,EAAmBC,GAAiB7E,IAC/CkF,EAAOlF,EAAM,GACd8E,EAAS,GAEpB,CAIAS,UAAUC,EAAM7O,EAAWgO,EAAYE,EAAgBjO,GACnD,MAAMgJ,GAAU,QAAS4F,EAAM7O,EAAWgO,EAAYE,EAAgBjO,GAKtE,OAJA7lB,KAAKqO,gBAAgB7G,KAAKqnB,GAC1BA,EAAQoF,qBAAqBnyB,KAAK+sB,IAC9B7uB,KAAKqO,gBAAgB0K,OAAO/Y,KAAKqO,gBAAgB+I,QAAQyX,GAAU,EAAE,IAElEA,CACX,CAIA6F,eAAeD,EAAMb,EAAYE,GAC7B,OAAO,IAAIza,SAAQ,CAACC,EAAS6a,KACzBn0B,KAAKw0B,UAAUC,GAAO5jB,IAClByI,EAAQzI,EAAK,GACd+iB,EAAYE,GAAiB7E,IAC5BkF,EAAOlF,EAAM,GACf,GAEV,CAKA0F,mBACI,MAAM,OAAY,kCACtB,EAGJ/0B,EAAMuM,aAAe,EAErBvM,EAAMg1B,YAAc,EAEpBh1B,EAAMi1B,aAAe,EAErBj1B,EAAMk1B,eAAiB,EAKvBl1B,EAAMktB,aAAe,EAKrBltB,EAAMqtB,aAAe,IAIrBrtB,EAAMm1B,UAAUC,oBAAsB,SAAU9U,GAC5C,OAAOlgB,KAAKigB,oBAAoBC,EACpC,EACAtgB,EAAMm1B,UAAUE,oBAAsB,SAAU/U,GAC5C,OAAOlgB,KAAK6gB,oBAAoBX,EACpC,EACAtgB,EAAMm1B,UAAUG,gBAAkB,SAAUhV,GACxC,OAAOlgB,KAAK2gB,gBAAgBT,EAChC,EACAtgB,EAAMm1B,UAAUI,qBAAuB,SAAUzV,GAC7C,OAAO1f,KAAK8gB,qBAAqBpB,EACrC,EACA9f,EAAMm1B,UAAUK,cAAgB,SAAUlV,GACtC,OAAOlgB,KAAKmgB,cAAcD,EAC9B,EACAtgB,EAAMm1B,UAAUM,oBAAsB,SAAU3V,GAC5C,OAAO1f,KAAKghB,oBAAoBtB,EACpC,EACA9f,EAAMm1B,UAAUO,YAAc,SAAUpV,GACpC,OAAOlgB,KAAKihB,YAAYf,EAC5B,EACAtgB,EAAMm1B,UAAUQ,aAAe,SAAUrV,GACrC,OAAOlgB,KAAKwhB,aAAatB,EAC7B,EACAtgB,EAAMm1B,UAAUS,mBAAqB,SAAU9V,GAC3C,OAAO1f,KAAKyhB,mBAAmB/B,EACnC,EACA9f,EAAMm1B,UAAUU,sBAAwB,SAAUvV,GAC9C,OAAOlgB,KAAK0hB,sBAAsBxB,EACtC,EACAtgB,EAAMm1B,UAAUW,gBAAkB,SAAUxV,GACxC,OAAOlgB,KAAK2hB,gBAAgBzB,EAChC,EACAtgB,EAAMm1B,UAAUY,YAAc,SAAUzV,GACpC,OAAOlgB,KAAKmiB,YAAYjC,EAC5B,EACAtgB,EAAMm1B,UAAUa,cAAgB,SAAU1V,GACtC,OAAOlgB,KAAKoiB,cAAclC,EAC9B,EACAtgB,EAAMm1B,UAAUc,qBAAuB,SAAU3V,GAC7C,OAAOlgB,KAAKsiB,qBAAqBpC,EACrC,EACAtgB,EAAMm1B,UAAUe,2BAA6B,SAAUpW,GACnD,OAAO1f,KAAKuiB,2BAA2B7C,EAC3C,EACA9f,EAAMm1B,UAAUgB,sBAAwB,SAAU7V,GAC9C,OAAOlgB,KAAKwiB,sBAAsBtC,EACtC,EACAtgB,EAAMm1B,UAAUiB,kBAAoB,SAAUtW,GAC1C,OAAO1f,KAAKyiB,kBAAkB/C,EAClC,EACA9f,EAAMm1B,UAAUkB,gBAAkB,SAAU/V,GACxC,OAAOlgB,KAAK0iB,gBAAgBxC,EAChC,EACAtgB,EAAMm1B,UAAUmB,iBAAmB,SAAUhW,GACzC,OAAOlgB,KAAK2iB,iBAAiBzC,EACjC,EACAtgB,EAAMm1B,UAAUoB,YAAc,SAAUjW,GACpC,OAAOlgB,KAAK4iB,YAAY1C,EAC5B,EACAtgB,EAAMm1B,UAAUqB,oBAAsB,SAAUlW,GAC5C,OAAOlgB,KAAKmjB,oBAAoBjD,EACpC,C","sources":["webpack://code-cave/./node_modules/@babylonjs/core/scene.js"],"sourcesContent":["import { Tools } from \"./Misc/tools.js\";\nimport { PrecisionDate } from \"./Misc/precisionDate.js\";\nimport { Observable } from \"./Misc/observable.js\";\nimport { SmartArrayNoDuplicate, SmartArray } from \"./Misc/smartArray.js\";\nimport { StringDictionary } from \"./Misc/stringDictionary.js\";\nimport { Tags } from \"./Misc/tags.js\";\nimport { Vector3, Matrix, TmpVectors } from \"./Maths/math.vector.js\";\nimport { AbstractScene } from \"./abstractScene.js\";\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration.js\";\nimport { UniformBuffer } from \"./Materials/uniformBuffer.js\";\nimport { PickingInfo } from \"./Collisions/pickingInfo.js\";\nimport { ActionEvent } from \"./Actions/actionEvent.js\";\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager.js\";\nimport { RenderingManager } from \"./Rendering/renderingManager.js\";\nimport { Stage } from \"./sceneComponent.js\";\n\nimport { IsWindowObjectExist } from \"./Misc/domManagement.js\";\nimport { EngineStore } from \"./Engines/engineStore.js\";\nimport { _WarnImport } from \"./Misc/devTools.js\";\nimport { InputManager } from \"./Inputs/scene.inputManager.js\";\nimport { PerfCounter } from \"./Misc/perfCounter.js\";\nimport { Color4, Color3 } from \"./Maths/math.color.js\";\nimport { Frustum } from \"./Maths/math.frustum.js\";\nimport { UniqueIdGenerator } from \"./Misc/uniqueIdGenerator.js\";\nimport { ReadFile, RequestFile, LoadFile } from \"./Misc/fileTools.js\";\nimport { LightConstants } from \"./Lights/lightConstants.js\";\nimport { _ObserveArray } from \"./Misc/arrayTools.js\";\n/**\n * Define how the scene should favor performance over ease of use\n */\nexport var ScenePerformancePriority;\n(function (ScenePerformancePriority) {\n    /** Default mode. No change. Performance will be treated as less important than backward compatibility */\n    ScenePerformancePriority[ScenePerformancePriority[\"BackwardCompatible\"] = 0] = \"BackwardCompatible\";\n    /** Some performance options will be turned on trying to strike a balance between perf and ease of use */\n    ScenePerformancePriority[ScenePerformancePriority[\"Intermediate\"] = 1] = \"Intermediate\";\n    /** Performance will be top priority */\n    ScenePerformancePriority[ScenePerformancePriority[\"Aggressive\"] = 2] = \"Aggressive\";\n})(ScenePerformancePriority || (ScenePerformancePriority = {}));\n/**\n * Represents a scene to be rendered by the engine.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene\n */\nexport class Scene extends AbstractScene {\n    /**\n     * Factory used to create the default material.\n     * @param scene The scene to create the material for\n     * @returns The default material\n     */\n    static DefaultMaterialFactory(scene) {\n        throw _WarnImport(\"StandardMaterial\");\n    }\n    /**\n     * Factory used to create the a collision coordinator.\n     * @returns The collision coordinator\n     */\n    static CollisionCoordinatorFactory() {\n        throw _WarnImport(\"DefaultCollisionCoordinator\");\n    }\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n    get environmentTexture() {\n        return this._environmentTexture;\n    }\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to set here than in all the materials.\n     */\n    set environmentTexture(value) {\n        if (this._environmentTexture === value) {\n            return;\n        }\n        this._environmentTexture = value;\n        this.markAllMaterialsAsDirty(1);\n    }\n    /**\n     * Default image processing configuration used either in the rendering\n     * Forward main pass or through the imageProcessingPostProcess if present.\n     * As in the majority of the scene they are the same (exception for multi camera),\n     * this is easier to reference from here than from all the materials and post process.\n     *\n     * No setter as we it is a shared configuration, you can set the values instead.\n     */\n    get imageProcessingConfiguration() {\n        return this._imageProcessingConfiguration;\n    }\n    /**\n     * Gets or sets a value indicating how to treat performance relatively to ease of use and backward compatibility\n     */\n    get performancePriority() {\n        return this._performancePriority;\n    }\n    set performancePriority(value) {\n        if (value === this._performancePriority) {\n            return;\n        }\n        this._performancePriority = value;\n        switch (value) {\n            case ScenePerformancePriority.BackwardCompatible:\n                this.skipFrustumClipping = false;\n                this._renderingManager.maintainStateBetweenFrames = false;\n                this.skipPointerMovePicking = false;\n                this.autoClear = true;\n                break;\n            case ScenePerformancePriority.Intermediate:\n                this.skipFrustumClipping = false;\n                this._renderingManager.maintainStateBetweenFrames = false;\n                this.skipPointerMovePicking = true;\n                this.autoClear = false;\n                break;\n            case ScenePerformancePriority.Aggressive:\n                this.skipFrustumClipping = true;\n                this._renderingManager.maintainStateBetweenFrames = true;\n                this.skipPointerMovePicking = true;\n                this.autoClear = false;\n                break;\n        }\n        this.onScenePerformancePriorityChangedObservable.notifyObservers(value);\n    }\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in wireframe\n     */\n    set forceWireframe(value) {\n        if (this._forceWireframe === value) {\n            return;\n        }\n        this._forceWireframe = value;\n        this.markAllMaterialsAsDirty(16);\n    }\n    get forceWireframe() {\n        return this._forceWireframe;\n    }\n    /**\n     * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\n     */\n    set skipFrustumClipping(value) {\n        if (this._skipFrustumClipping === value) {\n            return;\n        }\n        this._skipFrustumClipping = value;\n    }\n    get skipFrustumClipping() {\n        return this._skipFrustumClipping;\n    }\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in point cloud\n     */\n    set forcePointsCloud(value) {\n        if (this._forcePointsCloud === value) {\n            return;\n        }\n        this._forcePointsCloud = value;\n        this.markAllMaterialsAsDirty(16);\n    }\n    get forcePointsCloud() {\n        return this._forcePointsCloud;\n    }\n    /**\n     * Gets or sets the animation properties override\n     */\n    get animationPropertiesOverride() {\n        return this._animationPropertiesOverride;\n    }\n    set animationPropertiesOverride(value) {\n        this._animationPropertiesOverride = value;\n    }\n    /** Sets a function to be executed when this scene is disposed. */\n    set onDispose(callback) {\n        if (this._onDisposeObserver) {\n            this.onDisposeObservable.remove(this._onDisposeObserver);\n        }\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    }\n    /** Sets a function to be executed before rendering this scene */\n    set beforeRender(callback) {\n        if (this._onBeforeRenderObserver) {\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n        }\n        if (callback) {\n            this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n        }\n    }\n    /** Sets a function to be executed after rendering this scene */\n    set afterRender(callback) {\n        if (this._onAfterRenderObserver) {\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n        }\n        if (callback) {\n            this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n        }\n    }\n    /** Sets a function to be executed before rendering a camera*/\n    set beforeCameraRender(callback) {\n        if (this._onBeforeCameraRenderObserver) {\n            this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n        }\n        this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\n    }\n    /** Sets a function to be executed after rendering a camera*/\n    set afterCameraRender(callback) {\n        if (this._onAfterCameraRenderObserver) {\n            this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n        }\n        this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\n    }\n    /**\n     * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\n     */\n    get unTranslatedPointer() {\n        return this._inputManager.unTranslatedPointer;\n    }\n    /**\n     * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\n     */\n    static get DragMovementThreshold() {\n        return InputManager.DragMovementThreshold;\n    }\n    static set DragMovementThreshold(value) {\n        InputManager.DragMovementThreshold = value;\n    }\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\n     */\n    static get LongPressDelay() {\n        return InputManager.LongPressDelay;\n    }\n    static set LongPressDelay(value) {\n        InputManager.LongPressDelay = value;\n    }\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\n     */\n    static get DoubleClickDelay() {\n        return InputManager.DoubleClickDelay;\n    }\n    static set DoubleClickDelay(value) {\n        InputManager.DoubleClickDelay = value;\n    }\n    /** If you need to check double click without raising a single click at first click, enable this flag */\n    static get ExclusiveDoubleClickMode() {\n        return InputManager.ExclusiveDoubleClickMode;\n    }\n    static set ExclusiveDoubleClickMode(value) {\n        InputManager.ExclusiveDoubleClickMode = value;\n    }\n    /**\n     * Bind the current view position to an effect.\n     * @param effect The effect to be bound\n     * @param variableName name of the shader variable that will hold the eye position\n     * @param isVector3 true to indicates that variableName is a Vector3 and not a Vector4\n     * @returns the computed eye position\n     */\n    bindEyePosition(effect, variableName = \"vEyePosition\", isVector3 = false) {\n        var _a;\n        const eyePosition = this._forcedViewPosition\n            ? this._forcedViewPosition\n            : this._mirroredCameraPosition\n                ? this._mirroredCameraPosition\n                : (_a = this.activeCamera.globalPosition) !== null && _a !== void 0 ? _a : this.activeCamera.devicePosition;\n        const invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);\n        TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);\n        if (effect) {\n            if (isVector3) {\n                effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);\n            }\n            else {\n                effect.setVector4(variableName, TmpVectors.Vector4[0]);\n            }\n        }\n        return TmpVectors.Vector4[0];\n    }\n    /**\n     * Update the scene ubo before it can be used in rendering processing\n     * @returns the scene UniformBuffer\n     */\n    finalizeSceneUbo() {\n        const ubo = this.getSceneUniformBuffer();\n        const eyePosition = this.bindEyePosition(null);\n        ubo.updateFloat4(\"vEyePosition\", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);\n        ubo.update();\n        return ubo;\n    }\n    /**\n     * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\n     */\n    set useRightHandedSystem(value) {\n        if (this._useRightHandedSystem === value) {\n            return;\n        }\n        this._useRightHandedSystem = value;\n        this.markAllMaterialsAsDirty(16);\n    }\n    get useRightHandedSystem() {\n        return this._useRightHandedSystem;\n    }\n    /**\n     * Sets the step Id used by deterministic lock step\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     * @param newStepId defines the step Id\n     */\n    setStepId(newStepId) {\n        this._currentStepId = newStepId;\n    }\n    /**\n     * Gets the step Id used by deterministic lock step\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     * @returns the step Id\n     */\n    getStepId() {\n        return this._currentStepId;\n    }\n    /**\n     * Gets the internal step used by deterministic lock step\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     * @returns the internal step\n     */\n    getInternalStep() {\n        return this._currentInternalStep;\n    }\n    /**\n     * Gets or sets a boolean indicating if fog is enabled on this scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is true)\n     */\n    set fogEnabled(value) {\n        if (this._fogEnabled === value) {\n            return;\n        }\n        this._fogEnabled = value;\n        this.markAllMaterialsAsDirty(16);\n    }\n    get fogEnabled() {\n        return this._fogEnabled;\n    }\n    /**\n     * Gets or sets the fog mode to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * | mode | value |\n     * | --- | --- |\n     * | FOGMODE_NONE | 0 |\n     * | FOGMODE_EXP | 1 |\n     * | FOGMODE_EXP2 | 2 |\n     * | FOGMODE_LINEAR | 3 |\n     */\n    set fogMode(value) {\n        if (this._fogMode === value) {\n            return;\n        }\n        this._fogMode = value;\n        this.markAllMaterialsAsDirty(16);\n    }\n    get fogMode() {\n        return this._fogMode;\n    }\n    /**\n     * Flag indicating that the frame buffer binding is handled by another component\n     */\n    get prePass() {\n        return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;\n    }\n    /**\n     * Gets or sets a boolean indicating if shadows are enabled on this scene\n     */\n    set shadowsEnabled(value) {\n        if (this._shadowsEnabled === value) {\n            return;\n        }\n        this._shadowsEnabled = value;\n        this.markAllMaterialsAsDirty(2);\n    }\n    get shadowsEnabled() {\n        return this._shadowsEnabled;\n    }\n    /**\n     * Gets or sets a boolean indicating if lights are enabled on this scene\n     */\n    set lightsEnabled(value) {\n        if (this._lightsEnabled === value) {\n            return;\n        }\n        this._lightsEnabled = value;\n        this.markAllMaterialsAsDirty(2);\n    }\n    get lightsEnabled() {\n        return this._lightsEnabled;\n    }\n    /** All of the active cameras added to this scene. */\n    get activeCameras() {\n        return this._activeCameras;\n    }\n    set activeCameras(cameras) {\n        if (this._unObserveActiveCameras) {\n            this._unObserveActiveCameras();\n            this._unObserveActiveCameras = null;\n        }\n        if (cameras) {\n            this._unObserveActiveCameras = _ObserveArray(cameras, () => {\n                this.onActiveCamerasChanged.notifyObservers(this);\n            });\n        }\n        this._activeCameras = cameras;\n    }\n    /** Gets or sets the current active camera */\n    get activeCamera() {\n        return this._activeCamera;\n    }\n    set activeCamera(value) {\n        if (value === this._activeCamera) {\n            return;\n        }\n        this._activeCamera = value;\n        this.onActiveCameraChanged.notifyObservers(this);\n    }\n    /** The default material used on meshes when no material is affected */\n    get defaultMaterial() {\n        if (!this._defaultMaterial) {\n            this._defaultMaterial = Scene.DefaultMaterialFactory(this);\n        }\n        return this._defaultMaterial;\n    }\n    /** The default material used on meshes when no material is affected */\n    set defaultMaterial(value) {\n        this._defaultMaterial = value;\n    }\n    /**\n     * Gets or sets a boolean indicating if textures are enabled on this scene\n     */\n    set texturesEnabled(value) {\n        if (this._texturesEnabled === value) {\n            return;\n        }\n        this._texturesEnabled = value;\n        this.markAllMaterialsAsDirty(1);\n    }\n    get texturesEnabled() {\n        return this._texturesEnabled;\n    }\n    /**\n     * Gets or sets a boolean indicating if skeletons are enabled on this scene\n     */\n    set skeletonsEnabled(value) {\n        if (this._skeletonsEnabled === value) {\n            return;\n        }\n        this._skeletonsEnabled = value;\n        this.markAllMaterialsAsDirty(8);\n    }\n    get skeletonsEnabled() {\n        return this._skeletonsEnabled;\n    }\n    /** @internal */\n    get collisionCoordinator() {\n        if (!this._collisionCoordinator) {\n            this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\n            this._collisionCoordinator.init(this);\n        }\n        return this._collisionCoordinator;\n    }\n    /**\n     * Gets the scene's rendering manager\n     */\n    get renderingManager() {\n        return this._renderingManager;\n    }\n    /**\n     * Gets the list of frustum planes (built from the active camera)\n     */\n    get frustumPlanes() {\n        return this._frustumPlanes;\n    }\n    /**\n     * Registers the transient components if needed.\n     */\n    _registerTransientComponents() {\n        // Register components that have been associated lately to the scene.\n        if (this._transientComponents.length > 0) {\n            for (const component of this._transientComponents) {\n                component.register();\n            }\n            this._transientComponents.length = 0;\n        }\n    }\n    /**\n     * @internal\n     * Add a component to the scene.\n     * Note that the ccomponent could be registered on th next frame if this is called after\n     * the register component stage.\n     * @param component Defines the component to add to the scene\n     */\n    _addComponent(component) {\n        this._components.push(component);\n        this._transientComponents.push(component);\n        const serializableComponent = component;\n        if (serializableComponent.addFromContainer && serializableComponent.serialize) {\n            this._serializableComponents.push(serializableComponent);\n        }\n    }\n    /**\n     * @internal\n     * Gets a component from the scene.\n     * @param name defines the name of the component to retrieve\n     * @returns the component or null if not present\n     */\n    _getComponent(name) {\n        for (const component of this._components) {\n            if (component.name === name) {\n                return component;\n            }\n        }\n        return null;\n    }\n    /**\n     * Creates a new Scene\n     * @param engine defines the engine to use to render this scene\n     * @param options defines the scene options\n     */\n    constructor(engine, options) {\n        super();\n        // Members\n        /** @internal */\n        this._inputManager = new InputManager(this);\n        /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\n        this.cameraToUseForPointers = null;\n        /** @internal */\n        this._isScene = true;\n        /** @internal */\n        this._blockEntityCollection = false;\n        /**\n         * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\n         */\n        this.autoClear = true;\n        /**\n         * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\n         */\n        this.autoClearDepthAndStencil = true;\n        /**\n         * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\n         */\n        this.clearColor = new Color4(0.2, 0.2, 0.3, 1.0);\n        /**\n         * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\n         */\n        this.ambientColor = new Color3(0, 0, 0);\n        /**\n         * Intensity of the environment in all pbr material.\n         * This dims or reinforces the IBL lighting overall (reflection and diffuse).\n         * As in the majority of the scene they are the same (exception for multi room and so on),\n         * this is easier to reference from here than from all the materials.\n         */\n        this.environmentIntensity = 1;\n        this._performancePriority = ScenePerformancePriority.BackwardCompatible;\n        /**\n         * Observable triggered when the performance priority is changed\n         */\n        this.onScenePerformancePriorityChangedObservable = new Observable();\n        this._forceWireframe = false;\n        this._skipFrustumClipping = false;\n        this._forcePointsCloud = false;\n        /**\n         * Gets or sets a boolean indicating if animations are enabled\n         */\n        this.animationsEnabled = true;\n        this._animationPropertiesOverride = null;\n        /**\n         * Gets or sets a boolean indicating if a constant deltatime has to be used\n         * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\n         */\n        this.useConstantAnimationDeltaTime = false;\n        /**\n         * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\n         * Please note that it requires to run a ray cast through the scene on every frame\n         */\n        this.constantlyUpdateMeshUnderPointer = false;\n        /**\n         * Defines the HTML cursor to use when hovering over interactive elements\n         */\n        this.hoverCursor = \"pointer\";\n        /**\n         * Defines the HTML default cursor to use (empty by default)\n         */\n        this.defaultCursor = \"\";\n        /**\n         * Defines whether cursors are handled by the scene.\n         */\n        this.doNotHandleCursors = false;\n        /**\n         * This is used to call preventDefault() on pointer down\n         * in order to block unwanted artifacts like system double clicks\n         */\n        this.preventDefaultOnPointerDown = true;\n        /**\n         * This is used to call preventDefault() on pointer up\n         * in order to block unwanted artifacts like system double clicks\n         */\n        this.preventDefaultOnPointerUp = true;\n        // Metadata\n        /**\n         * Gets or sets user defined metadata\n         */\n        this.metadata = null;\n        /**\n         * For internal use only. Please do not use.\n         */\n        this.reservedDataStore = null;\n        /**\n         * Use this array to add regular expressions used to disable offline support for specific urls\n         */\n        this.disableOfflineSupportExceptionRules = new Array();\n        /**\n         * An event triggered when the scene is disposed.\n         */\n        this.onDisposeObservable = new Observable();\n        this._onDisposeObserver = null;\n        /**\n         * An event triggered before rendering the scene (right after animations and physics)\n         */\n        this.onBeforeRenderObservable = new Observable();\n        this._onBeforeRenderObserver = null;\n        /**\n         * An event triggered after rendering the scene\n         */\n        this.onAfterRenderObservable = new Observable();\n        /**\n         * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\n         * This is triggered for each \"sub\" camera in a Camera Rig unlike onAfterCameraRenderObservable\n         */\n        this.onAfterRenderCameraObservable = new Observable();\n        this._onAfterRenderObserver = null;\n        /**\n         * An event triggered before animating the scene\n         */\n        this.onBeforeAnimationsObservable = new Observable();\n        /**\n         * An event triggered after animations processing\n         */\n        this.onAfterAnimationsObservable = new Observable();\n        /**\n         * An event triggered before draw calls are ready to be sent\n         */\n        this.onBeforeDrawPhaseObservable = new Observable();\n        /**\n         * An event triggered after draw calls have been sent\n         */\n        this.onAfterDrawPhaseObservable = new Observable();\n        /**\n         * An event triggered when the scene is ready\n         */\n        this.onReadyObservable = new Observable();\n        /**\n         * An event triggered before rendering a camera\n         */\n        this.onBeforeCameraRenderObservable = new Observable();\n        this._onBeforeCameraRenderObserver = null;\n        /**\n         * An event triggered after rendering a camera\n         * This is triggered for the full rig Camera only unlike onAfterRenderCameraObservable\n         */\n        this.onAfterCameraRenderObservable = new Observable();\n        this._onAfterCameraRenderObserver = null;\n        /**\n         * An event triggered when active meshes evaluation is about to start\n         */\n        this.onBeforeActiveMeshesEvaluationObservable = new Observable();\n        /**\n         * An event triggered when active meshes evaluation is done\n         */\n        this.onAfterActiveMeshesEvaluationObservable = new Observable();\n        /**\n         * An event triggered when particles rendering is about to start\n         * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n         */\n        this.onBeforeParticlesRenderingObservable = new Observable();\n        /**\n         * An event triggered when particles rendering is done\n         * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n         */\n        this.onAfterParticlesRenderingObservable = new Observable();\n        /**\n         * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\n         */\n        this.onDataLoadedObservable = new Observable();\n        /**\n         * An event triggered when a camera is created\n         */\n        this.onNewCameraAddedObservable = new Observable();\n        /**\n         * An event triggered when a camera is removed\n         */\n        this.onCameraRemovedObservable = new Observable();\n        /**\n         * An event triggered when a light is created\n         */\n        this.onNewLightAddedObservable = new Observable();\n        /**\n         * An event triggered when a light is removed\n         */\n        this.onLightRemovedObservable = new Observable();\n        /**\n         * An event triggered when a geometry is created\n         */\n        this.onNewGeometryAddedObservable = new Observable();\n        /**\n         * An event triggered when a geometry is removed\n         */\n        this.onGeometryRemovedObservable = new Observable();\n        /**\n         * An event triggered when a transform node is created\n         */\n        this.onNewTransformNodeAddedObservable = new Observable();\n        /**\n         * An event triggered when a transform node is removed\n         */\n        this.onTransformNodeRemovedObservable = new Observable();\n        /**\n         * An event triggered when a mesh is created\n         */\n        this.onNewMeshAddedObservable = new Observable();\n        /**\n         * An event triggered when a mesh is removed\n         */\n        this.onMeshRemovedObservable = new Observable();\n        /**\n         * An event triggered when a skeleton is created\n         */\n        this.onNewSkeletonAddedObservable = new Observable();\n        /**\n         * An event triggered when a skeleton is removed\n         */\n        this.onSkeletonRemovedObservable = new Observable();\n        /**\n         * An event triggered when a material is created\n         */\n        this.onNewMaterialAddedObservable = new Observable();\n        /**\n         * An event triggered when a multi material is created\n         */\n        this.onNewMultiMaterialAddedObservable = new Observable();\n        /**\n         * An event triggered when a material is removed\n         */\n        this.onMaterialRemovedObservable = new Observable();\n        /**\n         * An event triggered when a multi material is removed\n         */\n        this.onMultiMaterialRemovedObservable = new Observable();\n        /**\n         * An event triggered when a texture is created\n         */\n        this.onNewTextureAddedObservable = new Observable();\n        /**\n         * An event triggered when a texture is removed\n         */\n        this.onTextureRemovedObservable = new Observable();\n        /**\n         * An event triggered when render targets are about to be rendered\n         * Can happen multiple times per frame.\n         */\n        this.onBeforeRenderTargetsRenderObservable = new Observable();\n        /**\n         * An event triggered when render targets were rendered.\n         * Can happen multiple times per frame.\n         */\n        this.onAfterRenderTargetsRenderObservable = new Observable();\n        /**\n         * An event triggered before calculating deterministic simulation step\n         */\n        this.onBeforeStepObservable = new Observable();\n        /**\n         * An event triggered after calculating deterministic simulation step\n         */\n        this.onAfterStepObservable = new Observable();\n        /**\n         * An event triggered when the activeCamera property is updated\n         */\n        this.onActiveCameraChanged = new Observable();\n        /**\n         * An event triggered when the activeCameras property is updated\n         */\n        this.onActiveCamerasChanged = new Observable();\n        /**\n         * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\n         * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n         * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n         */\n        this.onBeforeRenderingGroupObservable = new Observable();\n        /**\n         * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\n         * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n         * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n         */\n        this.onAfterRenderingGroupObservable = new Observable();\n        /**\n         * This Observable will when a mesh has been imported into the scene.\n         */\n        this.onMeshImportedObservable = new Observable();\n        /**\n         * This Observable will when an animation file has been imported into the scene.\n         */\n        this.onAnimationFileImportedObservable = new Observable();\n        // Animations\n        /** @internal */\n        this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);\n        /**\n         * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer move event occurs.\n         */\n        this.skipPointerMovePicking = false;\n        /**\n         * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer down event occurs.\n         */\n        this.skipPointerDownPicking = false;\n        /**\n         * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer up event occurs.  Off by default.\n         */\n        this.skipPointerUpPicking = false;\n        /**\n         * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\n         * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\n         */\n        this.onPrePointerObservable = new Observable();\n        /**\n         * Observable event triggered each time an input event is received from the rendering canvas\n         */\n        this.onPointerObservable = new Observable();\n        // Keyboard\n        /**\n         * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\n         * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\n         */\n        this.onPreKeyboardObservable = new Observable();\n        /**\n         * Observable event triggered each time an keyboard event is received from the hosting window\n         */\n        this.onKeyboardObservable = new Observable();\n        // Coordinates system\n        this._useRightHandedSystem = false;\n        // Deterministic lockstep\n        this._timeAccumulator = 0;\n        this._currentStepId = 0;\n        this._currentInternalStep = 0;\n        // Fog\n        this._fogEnabled = true;\n        this._fogMode = Scene.FOGMODE_NONE;\n        /**\n         * Gets or sets the fog color to use\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n         * (Default is Color3(0.2, 0.2, 0.3))\n         */\n        this.fogColor = new Color3(0.2, 0.2, 0.3);\n        /**\n         * Gets or sets the fog density to use\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n         * (Default is 0.1)\n         */\n        this.fogDensity = 0.1;\n        /**\n         * Gets or sets the fog start distance to use\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n         * (Default is 0)\n         */\n        this.fogStart = 0;\n        /**\n         * Gets or sets the fog end distance to use\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n         * (Default is 1000)\n         */\n        this.fogEnd = 1000.0;\n        /**\n         * Flag indicating if we need to store previous matrices when rendering\n         */\n        this.needsPreviousWorldMatrices = false;\n        // Lights\n        this._shadowsEnabled = true;\n        this._lightsEnabled = true;\n        this._unObserveActiveCameras = null;\n        // Textures\n        this._texturesEnabled = true;\n        // Physics\n        /**\n         * Gets or sets a boolean indicating if physic engines are enabled on this scene\n         */\n        this.physicsEnabled = true;\n        // Particles\n        /**\n         * Gets or sets a boolean indicating if particles are enabled on this scene\n         */\n        this.particlesEnabled = true;\n        // Sprites\n        /**\n         * Gets or sets a boolean indicating if sprites are enabled on this scene\n         */\n        this.spritesEnabled = true;\n        // Skeletons\n        this._skeletonsEnabled = true;\n        // Lens flares\n        /**\n         * Gets or sets a boolean indicating if lens flares are enabled on this scene\n         */\n        this.lensFlaresEnabled = true;\n        // Collisions\n        /**\n         * Gets or sets a boolean indicating if collisions are enabled on this scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n         */\n        this.collisionsEnabled = true;\n        /**\n         * Defines the gravity applied to this scene (used only for collisions)\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n         */\n        this.gravity = new Vector3(0, -9.807, 0);\n        // Postprocesses\n        /**\n         * Gets or sets a boolean indicating if postprocesses are enabled on this scene\n         */\n        this.postProcessesEnabled = true;\n        // Customs render targets\n        /**\n         * Gets or sets a boolean indicating if render targets are enabled on this scene\n         */\n        this.renderTargetsEnabled = true;\n        /**\n         * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\n         * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\n         */\n        this.dumpNextRenderTargets = false;\n        /**\n         * The list of user defined render targets added to the scene\n         */\n        this.customRenderTargets = new Array();\n        /**\n         * Gets the list of meshes imported to the scene through SceneLoader\n         */\n        this.importedMeshesFiles = new Array();\n        // Probes\n        /**\n         * Gets or sets a boolean indicating if probes are enabled on this scene\n         */\n        this.probesEnabled = true;\n        this._meshesForIntersections = new SmartArrayNoDuplicate(256);\n        // Procedural textures\n        /**\n         * Gets or sets a boolean indicating if procedural textures are enabled on this scene\n         */\n        this.proceduralTexturesEnabled = true;\n        // Performance counters\n        this._totalVertices = new PerfCounter();\n        /** @internal */\n        this._activeIndices = new PerfCounter();\n        /** @internal */\n        this._activeParticles = new PerfCounter();\n        /** @internal */\n        this._activeBones = new PerfCounter();\n        /** @internal */\n        this._animationTime = 0;\n        /**\n         * Gets or sets a general scale for animation speed\n         * @see https://www.babylonjs-playground.com/#IBU2W7#3\n         */\n        this.animationTimeScale = 1;\n        this._renderId = 0;\n        this._frameId = 0;\n        this._executeWhenReadyTimeoutId = null;\n        this._intermediateRendering = false;\n        this._defaultFrameBufferCleared = false;\n        this._viewUpdateFlag = -1;\n        this._projectionUpdateFlag = -1;\n        /** @internal */\n        this._toBeDisposed = new Array(256);\n        this._activeRequests = new Array();\n        /** @internal */\n        this._pendingData = new Array();\n        this._isDisposed = false;\n        /**\n         * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\n         * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\n         */\n        this.dispatchAllSubMeshesOfActiveMeshes = false;\n        this._activeMeshes = new SmartArray(256);\n        this._processedMaterials = new SmartArray(256);\n        this._renderTargets = new SmartArrayNoDuplicate(256);\n        this._materialsRenderTargets = new SmartArrayNoDuplicate(256);\n        /** @internal */\n        this._activeParticleSystems = new SmartArray(256);\n        this._activeSkeletons = new SmartArrayNoDuplicate(32);\n        this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);\n        /** @internal */\n        this._activeAnimatables = new Array();\n        this._transformMatrix = Matrix.Zero();\n        /**\n         * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\n         * This is useful if there are more lights that the maximum simulteanous authorized\n         */\n        this.requireLightSorting = false;\n        /**\n         * @internal\n         * Backing store of defined scene components.\n         */\n        this._components = [];\n        /**\n         * @internal\n         * Backing store of defined scene components.\n         */\n        this._serializableComponents = [];\n        /**\n         * List of components to register on the next registration step.\n         */\n        this._transientComponents = [];\n        /**\n         * @internal\n         * Defines the actions happening before camera updates.\n         */\n        this._beforeCameraUpdateStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening before clear the canvas.\n         */\n        this._beforeClearStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening before clear the canvas.\n         */\n        this._beforeRenderTargetClearStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions when collecting render targets for the frame.\n         */\n        this._gatherRenderTargetsStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening for one camera in the frame.\n         */\n        this._gatherActiveCameraRenderTargetsStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening during the per mesh ready checks.\n         */\n        this._isReadyForMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening before evaluate active mesh checks.\n         */\n        this._beforeEvaluateActiveMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening during the evaluate sub mesh checks.\n         */\n        this._evaluateSubMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening during the active mesh stage.\n         */\n        this._preActiveMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening during the per camera render target step.\n         */\n        this._cameraDrawRenderTargetStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just before the active camera is drawing.\n         */\n        this._beforeCameraDrawStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just before a render target is drawing.\n         */\n        this._beforeRenderTargetDrawStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just before a rendering group is drawing.\n         */\n        this._beforeRenderingGroupDrawStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just before a mesh is drawing.\n         */\n        this._beforeRenderingMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after a mesh has been drawn.\n         */\n        this._afterRenderingMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after a rendering group has been drawn.\n         */\n        this._afterRenderingGroupDrawStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after the active camera has been drawn.\n         */\n        this._afterCameraDrawStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after the post processing\n         */\n        this._afterCameraPostProcessStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after a render target has been drawn.\n         */\n        this._afterRenderTargetDrawStage = Stage.Create();\n        /**\n         * Defines the actions happening just after the post processing on a render target\n         */\n        this._afterRenderTargetPostProcessStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after rendering all cameras and computing intersections.\n         */\n        this._afterRenderStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening when a pointer move event happens.\n         */\n        this._pointerMoveStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening when a pointer down event happens.\n         */\n        this._pointerDownStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening when a pointer up event happens.\n         */\n        this._pointerUpStage = Stage.Create();\n        /**\n         * an optional map from Geometry Id to Geometry index in the 'geometries' array\n         */\n        this._geometriesByUniqueId = null;\n        this._defaultMeshCandidates = {\n            data: [],\n            length: 0,\n        };\n        this._defaultSubMeshCandidates = {\n            data: [],\n            length: 0,\n        };\n        this._preventFreeActiveMeshesAndRenderingGroups = false;\n        /** @internal */\n        this._activeMeshesFrozen = false;\n        /** @internal */\n        this._activeMeshesFrozenButKeepClipping = false;\n        this._skipEvaluateActiveMeshesCompletely = false;\n        /** @internal */\n        this._allowPostProcessClearColor = true;\n        /**\n         * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\n         */\n        this.getDeterministicFrameTime = () => {\n            return this._engine.getTimeStep();\n        };\n        /** @internal */\n        this._registeredActions = 0;\n        this._blockMaterialDirtyMechanism = false;\n        /**\n         * Internal perfCollector instance used for sharing between inspector and playground.\n         * Marked as protected to allow sharing between prototype extensions, but disallow access at toplevel.\n         */\n        this._perfCollector = null;\n        this.activeCameras = new Array();\n        const fullOptions = Object.assign({ useGeometryUniqueIdsMap: true, useMaterialMeshMap: true, useClonedMeshMap: true, virtual: false }, options);\n        this._engine = engine || EngineStore.LastCreatedEngine;\n        if (!fullOptions.virtual) {\n            EngineStore._LastCreatedScene = this;\n            this._engine.scenes.push(this);\n        }\n        else {\n            this._engine._virtualScenes.push(this);\n        }\n        this._uid = null;\n        this._renderingManager = new RenderingManager(this);\n        if (PostProcessManager) {\n            this.postProcessManager = new PostProcessManager(this);\n        }\n        if (IsWindowObjectExist()) {\n            this.attachControl();\n        }\n        // Uniform Buffer\n        this._createUbo();\n        // Default Image processing definition\n        if (ImageProcessingConfiguration) {\n            this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n        }\n        this.setDefaultCandidateProviders();\n        if (fullOptions.useGeometryUniqueIdsMap) {\n            this._geometriesByUniqueId = {};\n        }\n        this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\n        this.useClonedMeshMap = fullOptions.useClonedMeshMap;\n        if (!options || !options.virtual) {\n            this._engine.onNewSceneAddedObservable.notifyObservers(this);\n        }\n    }\n    /**\n     * Gets a string identifying the name of the class\n     * @returns \"Scene\" string\n     */\n    getClassName() {\n        return \"Scene\";\n    }\n    /**\n     * @internal\n     */\n    _getDefaultMeshCandidates() {\n        this._defaultMeshCandidates.data = this.meshes;\n        this._defaultMeshCandidates.length = this.meshes.length;\n        return this._defaultMeshCandidates;\n    }\n    /**\n     * @internal\n     */\n    _getDefaultSubMeshCandidates(mesh) {\n        this._defaultSubMeshCandidates.data = mesh.subMeshes;\n        this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\n        return this._defaultSubMeshCandidates;\n    }\n    /**\n     * Sets the default candidate providers for the scene.\n     * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\n     * and getCollidingSubMeshCandidates to their default function\n     */\n    setDefaultCandidateProviders() {\n        this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);\n        this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n        this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n        this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    }\n    /**\n     * Gets the mesh that is currently under the pointer\n     */\n    get meshUnderPointer() {\n        return this._inputManager.meshUnderPointer;\n    }\n    /**\n     * Gets or sets the current on-screen X position of the pointer\n     */\n    get pointerX() {\n        return this._inputManager.pointerX;\n    }\n    set pointerX(value) {\n        this._inputManager.pointerX = value;\n    }\n    /**\n     * Gets or sets the current on-screen Y position of the pointer\n     */\n    get pointerY() {\n        return this._inputManager.pointerY;\n    }\n    set pointerY(value) {\n        this._inputManager.pointerY = value;\n    }\n    /**\n     * Gets the cached material (ie. the latest rendered one)\n     * @returns the cached material\n     */\n    getCachedMaterial() {\n        return this._cachedMaterial;\n    }\n    /**\n     * Gets the cached effect (ie. the latest rendered one)\n     * @returns the cached effect\n     */\n    getCachedEffect() {\n        return this._cachedEffect;\n    }\n    /**\n     * Gets the cached visibility state (ie. the latest rendered one)\n     * @returns the cached visibility state\n     */\n    getCachedVisibility() {\n        return this._cachedVisibility;\n    }\n    /**\n     * Gets a boolean indicating if the current material / effect / visibility must be bind again\n     * @param material defines the current material\n     * @param effect defines the current effect\n     * @param visibility defines the current visibility state\n     * @returns true if one parameter is not cached\n     */\n    isCachedMaterialInvalid(material, effect, visibility = 1) {\n        return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\n    }\n    /**\n     * Gets the engine associated with the scene\n     * @returns an Engine\n     */\n    getEngine() {\n        return this._engine;\n    }\n    /**\n     * Gets the total number of vertices rendered per frame\n     * @returns the total number of vertices rendered per frame\n     */\n    getTotalVertices() {\n        return this._totalVertices.current;\n    }\n    /**\n     * Gets the performance counter for total vertices\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n    get totalVerticesPerfCounter() {\n        return this._totalVertices;\n    }\n    /**\n     * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\n     * @returns the total number of active indices rendered per frame\n     */\n    getActiveIndices() {\n        return this._activeIndices.current;\n    }\n    /**\n     * Gets the performance counter for active indices\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n    get totalActiveIndicesPerfCounter() {\n        return this._activeIndices;\n    }\n    /**\n     * Gets the total number of active particles rendered per frame\n     * @returns the total number of active particles rendered per frame\n     */\n    getActiveParticles() {\n        return this._activeParticles.current;\n    }\n    /**\n     * Gets the performance counter for active particles\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n    get activeParticlesPerfCounter() {\n        return this._activeParticles;\n    }\n    /**\n     * Gets the total number of active bones rendered per frame\n     * @returns the total number of active bones rendered per frame\n     */\n    getActiveBones() {\n        return this._activeBones.current;\n    }\n    /**\n     * Gets the performance counter for active bones\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n    get activeBonesPerfCounter() {\n        return this._activeBones;\n    }\n    /**\n     * Gets the array of active meshes\n     * @returns an array of AbstractMesh\n     */\n    getActiveMeshes() {\n        return this._activeMeshes;\n    }\n    /**\n     * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\n     * @returns a number\n     */\n    getAnimationRatio() {\n        return this._animationRatio !== undefined ? this._animationRatio : 1;\n    }\n    /**\n     * Gets an unique Id for the current render phase\n     * @returns a number\n     */\n    getRenderId() {\n        return this._renderId;\n    }\n    /**\n     * Gets an unique Id for the current frame\n     * @returns a number\n     */\n    getFrameId() {\n        return this._frameId;\n    }\n    /** Call this function if you want to manually increment the render Id*/\n    incrementRenderId() {\n        this._renderId++;\n    }\n    _createUbo() {\n        this.setSceneUniformBuffer(this.createSceneUniformBuffer());\n    }\n    /**\n     * Use this method to simulate a pointer move on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @returns the current scene\n     */\n    simulatePointerMove(pickResult, pointerEventInit) {\n        this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\n        return this;\n    }\n    /**\n     * Use this method to simulate a pointer down on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @returns the current scene\n     */\n    simulatePointerDown(pickResult, pointerEventInit) {\n        this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\n        return this;\n    }\n    /**\n     * Use this method to simulate a pointer up on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\n     * @returns the current scene\n     */\n    simulatePointerUp(pickResult, pointerEventInit, doubleTap) {\n        this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\n        return this;\n    }\n    /**\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n     * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\n     * @returns true if the pointer was captured\n     */\n    isPointerCaptured(pointerId = 0) {\n        return this._inputManager.isPointerCaptured(pointerId);\n    }\n    /**\n     * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n     * @param attachUp defines if you want to attach events to pointerup\n     * @param attachDown defines if you want to attach events to pointerdown\n     * @param attachMove defines if you want to attach events to pointermove\n     */\n    attachControl(attachUp = true, attachDown = true, attachMove = true) {\n        this._inputManager.attachControl(attachUp, attachDown, attachMove);\n    }\n    /** Detaches all event handlers*/\n    detachControl() {\n        this._inputManager.detachControl();\n    }\n    /**\n     * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\n     * Delay loaded resources are not taking in account\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: true)\n     * @returns true if all required resources are ready\n     */\n    isReady(checkRenderTargets = true) {\n        var _a, _b, _c;\n        if (this._isDisposed) {\n            return false;\n        }\n        let index;\n        const engine = this.getEngine();\n        const currentRenderPassId = engine.currentRenderPassId;\n        engine.currentRenderPassId = (_b = (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : currentRenderPassId;\n        let isReady = true;\n        // Pending data\n        if (this._pendingData.length > 0) {\n            isReady = false;\n        }\n        // Ensures that the pre-pass renderer is enabled if it is to be enabled.\n        (_c = this.prePassRenderer) === null || _c === void 0 ? void 0 : _c.update();\n        // Meshes\n        if (checkRenderTargets) {\n            this._processedMaterials.reset();\n            this._materialsRenderTargets.reset();\n        }\n        for (index = 0; index < this.meshes.length; index++) {\n            const mesh = this.meshes[index];\n            if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n                continue;\n            }\n            // Do not stop at the first encountered \"unready\" object as we want to ensure\n            // all materials are starting off their compilation in parallel.\n            if (!mesh.isReady(true)) {\n                isReady = false;\n                continue;\n            }\n            const hardwareInstancedRendering = mesh.hasThinInstances ||\n                mesh.getClassName() === \"InstancedMesh\" ||\n                mesh.getClassName() === \"InstancedLinesMesh\" ||\n                (engine.getCaps().instancedArrays && mesh.instances.length > 0);\n            // Is Ready For Mesh\n            for (const step of this._isReadyForMeshStage) {\n                if (!step.action(mesh, hardwareInstancedRendering)) {\n                    isReady = false;\n                }\n            }\n            if (!checkRenderTargets) {\n                continue;\n            }\n            const mat = mesh.material || this.defaultMaterial;\n            if (mat) {\n                if (mat._storeEffectOnSubMeshes) {\n                    for (const subMesh of mesh.subMeshes) {\n                        const material = subMesh.getMaterial();\n                        if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n                            if (this._processedMaterials.indexOf(material) === -1) {\n                                this._processedMaterials.push(material);\n                                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {\n                        if (this._processedMaterials.indexOf(mat) === -1) {\n                            this._processedMaterials.push(mat);\n                            this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());\n                        }\n                    }\n                }\n            }\n        }\n        // Render targets\n        if (checkRenderTargets) {\n            for (index = 0; index < this._materialsRenderTargets.length; ++index) {\n                const rtt = this._materialsRenderTargets.data[index];\n                if (!rtt.isReadyForRendering()) {\n                    isReady = false;\n                }\n            }\n        }\n        // Geometries\n        for (index = 0; index < this.geometries.length; index++) {\n            const geometry = this.geometries[index];\n            if (geometry.delayLoadState === 2) {\n                isReady = false;\n            }\n        }\n        // Post-processes\n        if (this.activeCameras && this.activeCameras.length > 0) {\n            for (const camera of this.activeCameras) {\n                if (!camera.isReady(true)) {\n                    isReady = false;\n                }\n            }\n        }\n        else if (this.activeCamera) {\n            if (!this.activeCamera.isReady(true)) {\n                isReady = false;\n            }\n        }\n        // Particles\n        for (const particleSystem of this.particleSystems) {\n            if (!particleSystem.isReady()) {\n                isReady = false;\n            }\n        }\n        // Layers\n        if (this.layers) {\n            for (const layer of this.layers) {\n                if (!layer.isReady()) {\n                    isReady = false;\n                }\n            }\n        }\n        // Effects\n        if (!engine.areAllEffectsReady()) {\n            isReady = false;\n        }\n        engine.currentRenderPassId = currentRenderPassId;\n        return isReady;\n    }\n    /** Resets all cached information relative to material (including effect and visibility) */\n    resetCachedMaterial() {\n        this._cachedMaterial = null;\n        this._cachedEffect = null;\n        this._cachedVisibility = null;\n    }\n    /**\n     * Registers a function to be called before every frame render\n     * @param func defines the function to register\n     */\n    registerBeforeRender(func) {\n        this.onBeforeRenderObservable.add(func);\n    }\n    /**\n     * Unregisters a function called before every frame render\n     * @param func defines the function to unregister\n     */\n    unregisterBeforeRender(func) {\n        this.onBeforeRenderObservable.removeCallback(func);\n    }\n    /**\n     * Registers a function to be called after every frame render\n     * @param func defines the function to register\n     */\n    registerAfterRender(func) {\n        this.onAfterRenderObservable.add(func);\n    }\n    /**\n     * Unregisters a function called after every frame render\n     * @param func defines the function to unregister\n     */\n    unregisterAfterRender(func) {\n        this.onAfterRenderObservable.removeCallback(func);\n    }\n    _executeOnceBeforeRender(func) {\n        const execFunc = () => {\n            func();\n            setTimeout(() => {\n                this.unregisterBeforeRender(execFunc);\n            });\n        };\n        this.registerBeforeRender(execFunc);\n    }\n    /**\n     * The provided function will run before render once and will be disposed afterwards.\n     * A timeout delay can be provided so that the function will be executed in N ms.\n     * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\n     * @param func The function to be executed.\n     * @param timeout optional delay in ms\n     */\n    executeOnceBeforeRender(func, timeout) {\n        if (timeout !== undefined) {\n            setTimeout(() => {\n                this._executeOnceBeforeRender(func);\n            }, timeout);\n        }\n        else {\n            this._executeOnceBeforeRender(func);\n        }\n    }\n    /**\n     * This function can help adding any object to the list of data awaited to be ready in order to check for a complete scene loading.\n     * @param data defines the object to wait for\n     */\n    addPendingData(data) {\n        this._pendingData.push(data);\n    }\n    /**\n     * Remove a pending data from the loading list which has previously been added with addPendingData.\n     * @param data defines the object to remove from the pending list\n     */\n    removePendingData(data) {\n        const wasLoading = this.isLoading;\n        const index = this._pendingData.indexOf(data);\n        if (index !== -1) {\n            this._pendingData.splice(index, 1);\n        }\n        if (wasLoading && !this.isLoading) {\n            this.onDataLoadedObservable.notifyObservers(this);\n        }\n    }\n    /**\n     * Returns the number of items waiting to be loaded\n     * @returns the number of items waiting to be loaded\n     */\n    getWaitingItemsCount() {\n        return this._pendingData.length;\n    }\n    /**\n     * Returns a boolean indicating if the scene is still loading data\n     */\n    get isLoading() {\n        return this._pendingData.length > 0;\n    }\n    /**\n     * Registers a function to be executed when the scene is ready\n     * @param func - the function to be executed\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n     */\n    executeWhenReady(func, checkRenderTargets = false) {\n        this.onReadyObservable.addOnce(func);\n        if (this._executeWhenReadyTimeoutId !== null) {\n            return;\n        }\n        this._checkIsReady(checkRenderTargets);\n    }\n    /**\n     * Returns a promise that resolves when the scene is ready\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n     * @returns A promise that resolves when the scene is ready\n     */\n    whenReadyAsync(checkRenderTargets = false) {\n        return new Promise((resolve) => {\n            this.executeWhenReady(() => {\n                resolve();\n            }, checkRenderTargets);\n        });\n    }\n    /**\n     * @internal\n     */\n    _checkIsReady(checkRenderTargets = false) {\n        this._registerTransientComponents();\n        if (this.isReady(checkRenderTargets)) {\n            this.onReadyObservable.notifyObservers(this);\n            this.onReadyObservable.clear();\n            this._executeWhenReadyTimeoutId = null;\n            return;\n        }\n        if (this._isDisposed) {\n            this.onReadyObservable.clear();\n            this._executeWhenReadyTimeoutId = null;\n            return;\n        }\n        this._executeWhenReadyTimeoutId = setTimeout(() => {\n            // Ensure materials effects are checked outside render loops\n            this.incrementRenderId();\n            this._checkIsReady(checkRenderTargets);\n        }, 100);\n    }\n    /**\n     * Gets all animatable attached to the scene\n     */\n    get animatables() {\n        return this._activeAnimatables;\n    }\n    /**\n     * Resets the last animation time frame.\n     * Useful to override when animations start running when loading a scene for the first time.\n     */\n    resetLastAnimationTimeFrame() {\n        this._animationTimeLast = PrecisionDate.Now;\n    }\n    // Matrix\n    /**\n     * Gets the current view matrix\n     * @returns a Matrix\n     */\n    getViewMatrix() {\n        return this._viewMatrix;\n    }\n    /**\n     * Gets the current projection matrix\n     * @returns a Matrix\n     */\n    getProjectionMatrix() {\n        return this._projectionMatrix;\n    }\n    /**\n     * Gets the current transform matrix\n     * @returns a Matrix made of View * Projection\n     */\n    getTransformMatrix() {\n        return this._transformMatrix;\n    }\n    /**\n     * Sets the current transform matrix\n     * @param viewL defines the View matrix to use\n     * @param projectionL defines the Projection matrix to use\n     * @param viewR defines the right View matrix to use (if provided)\n     * @param projectionR defines the right Projection matrix to use (if provided)\n     */\n    setTransformMatrix(viewL, projectionL, viewR, projectionR) {\n        // clear the multiviewSceneUbo if no viewR and projectionR are defined\n        if (!viewR && !projectionR && this._multiviewSceneUbo) {\n            this._multiviewSceneUbo.dispose();\n            this._multiviewSceneUbo = null;\n        }\n        if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\n            return;\n        }\n        this._viewUpdateFlag = viewL.updateFlag;\n        this._projectionUpdateFlag = projectionL.updateFlag;\n        this._viewMatrix = viewL;\n        this._projectionMatrix = projectionL;\n        this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n        // Update frustum\n        if (!this._frustumPlanes) {\n            this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n        }\n        else {\n            Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n        }\n        if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\n            this._updateMultiviewUbo(viewR, projectionR);\n        }\n        else if (this._sceneUbo.useUbo) {\n            this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\n            this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\n            this._sceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\n        }\n    }\n    /**\n     * Gets the uniform buffer used to store scene data\n     * @returns a UniformBuffer\n     */\n    getSceneUniformBuffer() {\n        return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\n    }\n    /**\n     * Creates a scene UBO\n     * @param name name of the uniform buffer (optional, for debugging purpose only)\n     * @returns a new ubo\n     */\n    createSceneUniformBuffer(name) {\n        const sceneUbo = new UniformBuffer(this._engine, undefined, false, name !== null && name !== void 0 ? name : \"scene\");\n        sceneUbo.addUniform(\"viewProjection\", 16);\n        sceneUbo.addUniform(\"view\", 16);\n        sceneUbo.addUniform(\"projection\", 16);\n        sceneUbo.addUniform(\"vEyePosition\", 4);\n        return sceneUbo;\n    }\n    /**\n     * Sets the scene ubo\n     * @param ubo the ubo to set for the scene\n     */\n    setSceneUniformBuffer(ubo) {\n        this._sceneUbo = ubo;\n        this._viewUpdateFlag = -1;\n        this._projectionUpdateFlag = -1;\n    }\n    /**\n     * Gets an unique (relatively to the current scene) Id\n     * @returns an unique number for the scene\n     */\n    getUniqueId() {\n        return UniqueIdGenerator.UniqueId;\n    }\n    /**\n     * Add a mesh to the list of scene's meshes\n     * @param newMesh defines the mesh to add\n     * @param recursive if all child meshes should also be added to the scene\n     */\n    addMesh(newMesh, recursive = false) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.meshes.push(newMesh);\n        newMesh._resyncLightSources();\n        if (!newMesh.parent) {\n            newMesh._addToSceneRootNodes();\n        }\n        this.onNewMeshAddedObservable.notifyObservers(newMesh);\n        if (recursive) {\n            newMesh.getChildMeshes().forEach((m) => {\n                this.addMesh(m);\n            });\n        }\n    }\n    /**\n     * Remove a mesh for the list of scene's meshes\n     * @param toRemove defines the mesh to remove\n     * @param recursive if all child meshes should also be removed from the scene\n     * @returns the index where the mesh was in the mesh list\n     */\n    removeMesh(toRemove, recursive = false) {\n        const index = this.meshes.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if mesh found\n            this.meshes[index] = this.meshes[this.meshes.length - 1];\n            this.meshes.pop();\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        this._inputManager._invalidateMesh(toRemove);\n        this.onMeshRemovedObservable.notifyObservers(toRemove);\n        if (recursive) {\n            toRemove.getChildMeshes().forEach((m) => {\n                this.removeMesh(m);\n            });\n        }\n        return index;\n    }\n    /**\n     * Add a transform node to the list of scene's transform nodes\n     * @param newTransformNode defines the transform node to add\n     */\n    addTransformNode(newTransformNode) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {\n            // Already there?\n            return;\n        }\n        newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\n        this.transformNodes.push(newTransformNode);\n        if (!newTransformNode.parent) {\n            newTransformNode._addToSceneRootNodes();\n        }\n        this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\n    }\n    /**\n     * Remove a transform node for the list of scene's transform nodes\n     * @param toRemove defines the transform node to remove\n     * @returns the index where the transform node was in the transform node list\n     */\n    removeTransformNode(toRemove) {\n        const index = toRemove._indexInSceneTransformNodesArray;\n        if (index !== -1) {\n            if (index !== this.transformNodes.length - 1) {\n                const lastNode = this.transformNodes[this.transformNodes.length - 1];\n                this.transformNodes[index] = lastNode;\n                lastNode._indexInSceneTransformNodesArray = index;\n            }\n            toRemove._indexInSceneTransformNodesArray = -1;\n            this.transformNodes.pop();\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Remove a skeleton for the list of scene's skeletons\n     * @param toRemove defines the skeleton to remove\n     * @returns the index where the skeleton was in the skeleton list\n     */\n    removeSkeleton(toRemove) {\n        const index = this.skeletons.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if found\n            this.skeletons.splice(index, 1);\n            this.onSkeletonRemovedObservable.notifyObservers(toRemove);\n            // Clean active container\n            this._executeActiveContainerCleanup(this._activeSkeletons);\n        }\n        return index;\n    }\n    /**\n     * Remove a morph target for the list of scene's morph targets\n     * @param toRemove defines the morph target to remove\n     * @returns the index where the morph target was in the morph target list\n     */\n    removeMorphTargetManager(toRemove) {\n        const index = this.morphTargetManagers.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if found\n            this.morphTargetManagers.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Remove a light for the list of scene's lights\n     * @param toRemove defines the light to remove\n     * @returns the index where the light was in the light list\n     */\n    removeLight(toRemove) {\n        const index = this.lights.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from meshes\n            for (const mesh of this.meshes) {\n                mesh._removeLightSource(toRemove, false);\n            }\n            // Remove from the scene if mesh found\n            this.lights.splice(index, 1);\n            this.sortLightsByPriority();\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        this.onLightRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Remove a camera for the list of scene's cameras\n     * @param toRemove defines the camera to remove\n     * @returns the index where the camera was in the camera list\n     */\n    removeCamera(toRemove) {\n        const index = this.cameras.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if mesh found\n            this.cameras.splice(index, 1);\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        // Remove from activeCameras\n        if (this.activeCameras) {\n            const index2 = this.activeCameras.indexOf(toRemove);\n            if (index2 !== -1) {\n                // Remove from the scene if mesh found\n                this.activeCameras.splice(index2, 1);\n            }\n        }\n        // Reset the activeCamera\n        if (this.activeCamera === toRemove) {\n            if (this.cameras.length > 0) {\n                this.activeCamera = this.cameras[0];\n            }\n            else {\n                this.activeCamera = null;\n            }\n        }\n        this.onCameraRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Remove a particle system for the list of scene's particle systems\n     * @param toRemove defines the particle system to remove\n     * @returns the index where the particle system was in the particle system list\n     */\n    removeParticleSystem(toRemove) {\n        const index = this.particleSystems.indexOf(toRemove);\n        if (index !== -1) {\n            this.particleSystems.splice(index, 1);\n            // Clean active container\n            this._executeActiveContainerCleanup(this._activeParticleSystems);\n        }\n        return index;\n    }\n    /**\n     * Remove a animation for the list of scene's animations\n     * @param toRemove defines the animation to remove\n     * @returns the index where the animation was in the animation list\n     */\n    removeAnimation(toRemove) {\n        const index = this.animations.indexOf(toRemove);\n        if (index !== -1) {\n            this.animations.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Will stop the animation of the given target\n     * @param target - the target\n     * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n     */\n    stopAnimation(target, animationName, targetMask) {\n        // Do nothing as code will be provided by animation component\n    }\n    /**\n     * Removes the given animation group from this scene.\n     * @param toRemove The animation group to remove\n     * @returns The index of the removed animation group\n     */\n    removeAnimationGroup(toRemove) {\n        const index = this.animationGroups.indexOf(toRemove);\n        if (index !== -1) {\n            this.animationGroups.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Removes the given multi-material from this scene.\n     * @param toRemove The multi-material to remove\n     * @returns The index of the removed multi-material\n     */\n    removeMultiMaterial(toRemove) {\n        const index = this.multiMaterials.indexOf(toRemove);\n        if (index !== -1) {\n            this.multiMaterials.splice(index, 1);\n        }\n        this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Removes the given material from this scene.\n     * @param toRemove The material to remove\n     * @returns The index of the removed material\n     */\n    removeMaterial(toRemove) {\n        const index = toRemove._indexInSceneMaterialArray;\n        if (index !== -1 && index < this.materials.length) {\n            if (index !== this.materials.length - 1) {\n                const lastMaterial = this.materials[this.materials.length - 1];\n                this.materials[index] = lastMaterial;\n                lastMaterial._indexInSceneMaterialArray = index;\n            }\n            toRemove._indexInSceneMaterialArray = -1;\n            this.materials.pop();\n        }\n        this.onMaterialRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Removes the given action manager from this scene.\n     * @deprecated\n     * @param toRemove The action manager to remove\n     * @returns The index of the removed action manager\n     */\n    removeActionManager(toRemove) {\n        const index = this.actionManagers.indexOf(toRemove);\n        if (index !== -1) {\n            this.actionManagers.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Removes the given texture from this scene.\n     * @param toRemove The texture to remove\n     * @returns The index of the removed texture\n     */\n    removeTexture(toRemove) {\n        const index = this.textures.indexOf(toRemove);\n        if (index !== -1) {\n            this.textures.splice(index, 1);\n        }\n        this.onTextureRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Adds the given light to this scene\n     * @param newLight The light to add\n     */\n    addLight(newLight) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.lights.push(newLight);\n        this.sortLightsByPriority();\n        if (!newLight.parent) {\n            newLight._addToSceneRootNodes();\n        }\n        // Add light to all meshes (To support if the light is removed and then re-added)\n        for (const mesh of this.meshes) {\n            if (mesh.lightSources.indexOf(newLight) === -1) {\n                mesh.lightSources.push(newLight);\n                mesh._resyncLightSources();\n            }\n        }\n        this.onNewLightAddedObservable.notifyObservers(newLight);\n    }\n    /**\n     * Sorts the list list based on light priorities\n     */\n    sortLightsByPriority() {\n        if (this.requireLightSorting) {\n            this.lights.sort(LightConstants.CompareLightsPriority);\n        }\n    }\n    /**\n     * Adds the given camera to this scene\n     * @param newCamera The camera to add\n     */\n    addCamera(newCamera) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.cameras.push(newCamera);\n        this.onNewCameraAddedObservable.notifyObservers(newCamera);\n        if (!newCamera.parent) {\n            newCamera._addToSceneRootNodes();\n        }\n    }\n    /**\n     * Adds the given skeleton to this scene\n     * @param newSkeleton The skeleton to add\n     */\n    addSkeleton(newSkeleton) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.skeletons.push(newSkeleton);\n        this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\n    }\n    /**\n     * Adds the given particle system to this scene\n     * @param newParticleSystem The particle system to add\n     */\n    addParticleSystem(newParticleSystem) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.particleSystems.push(newParticleSystem);\n    }\n    /**\n     * Adds the given animation to this scene\n     * @param newAnimation The animation to add\n     */\n    addAnimation(newAnimation) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.animations.push(newAnimation);\n    }\n    /**\n     * Adds the given animation group to this scene.\n     * @param newAnimationGroup The animation group to add\n     */\n    addAnimationGroup(newAnimationGroup) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.animationGroups.push(newAnimationGroup);\n    }\n    /**\n     * Adds the given multi-material to this scene\n     * @param newMultiMaterial The multi-material to add\n     */\n    addMultiMaterial(newMultiMaterial) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.multiMaterials.push(newMultiMaterial);\n        this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\n    }\n    /**\n     * Adds the given material to this scene\n     * @param newMaterial The material to add\n     */\n    addMaterial(newMaterial) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {\n            // Already there??\n            return;\n        }\n        newMaterial._indexInSceneMaterialArray = this.materials.length;\n        this.materials.push(newMaterial);\n        this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\n    }\n    /**\n     * Adds the given morph target to this scene\n     * @param newMorphTargetManager The morph target to add\n     */\n    addMorphTargetManager(newMorphTargetManager) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.morphTargetManagers.push(newMorphTargetManager);\n    }\n    /**\n     * Adds the given geometry to this scene\n     * @param newGeometry The geometry to add\n     */\n    addGeometry(newGeometry) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        if (this._geometriesByUniqueId) {\n            this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\n        }\n        this.geometries.push(newGeometry);\n    }\n    /**\n     * Adds the given action manager to this scene\n     * @deprecated\n     * @param newActionManager The action manager to add\n     */\n    addActionManager(newActionManager) {\n        this.actionManagers.push(newActionManager);\n    }\n    /**\n     * Adds the given texture to this scene.\n     * @param newTexture The texture to add\n     */\n    addTexture(newTexture) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.textures.push(newTexture);\n        this.onNewTextureAddedObservable.notifyObservers(newTexture);\n    }\n    /**\n     * Switch active camera\n     * @param newCamera defines the new active camera\n     * @param attachControl defines if attachControl must be called for the new active camera (default: true)\n     */\n    switchActiveCamera(newCamera, attachControl = true) {\n        const canvas = this._engine.getInputElement();\n        if (!canvas) {\n            return;\n        }\n        if (this.activeCamera) {\n            this.activeCamera.detachControl();\n        }\n        this.activeCamera = newCamera;\n        if (attachControl) {\n            newCamera.attachControl();\n        }\n    }\n    /**\n     * sets the active camera of the scene using its Id\n     * @param id defines the camera's Id\n     * @returns the new active camera or null if none found.\n     */\n    setActiveCameraById(id) {\n        const camera = this.getCameraById(id);\n        if (camera) {\n            this.activeCamera = camera;\n            return camera;\n        }\n        return null;\n    }\n    /**\n     * sets the active camera of the scene using its name\n     * @param name defines the camera's name\n     * @returns the new active camera or null if none found.\n     */\n    setActiveCameraByName(name) {\n        const camera = this.getCameraByName(name);\n        if (camera) {\n            this.activeCamera = camera;\n            return camera;\n        }\n        return null;\n    }\n    /**\n     * get an animation group using its name\n     * @param name defines the material's name\n     * @returns the animation group or null if none found.\n     */\n    getAnimationGroupByName(name) {\n        for (let index = 0; index < this.animationGroups.length; index++) {\n            if (this.animationGroups[index].name === name) {\n                return this.animationGroups[index];\n            }\n        }\n        return null;\n    }\n    _getMaterial(allowMultiMaterials, predicate) {\n        for (let index = 0; index < this.materials.length; index++) {\n            const material = this.materials[index];\n            if (predicate(material)) {\n                return material;\n            }\n        }\n        if (allowMultiMaterials) {\n            for (let index = 0; index < this.multiMaterials.length; index++) {\n                const material = this.multiMaterials[index];\n                if (predicate(material)) {\n                    return material;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Get a material using its unique id\n     * @param uniqueId defines the material's unique id\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the material or null if none found.\n     */\n    getMaterialByUniqueID(uniqueId, allowMultiMaterials = false) {\n        return this._getMaterial(allowMultiMaterials, (m) => m.uniqueId === uniqueId);\n    }\n    /**\n     * get a material using its id\n     * @param id defines the material's Id\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the material or null if none found.\n     */\n    getMaterialById(id, allowMultiMaterials = false) {\n        return this._getMaterial(allowMultiMaterials, (m) => m.id === id);\n    }\n    /**\n     * Gets a material using its name\n     * @param name defines the material's name\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the material or null if none found.\n     */\n    getMaterialByName(name, allowMultiMaterials = false) {\n        return this._getMaterial(allowMultiMaterials, (m) => m.name === name);\n    }\n    /**\n     * Gets a last added material using a given id\n     * @param id defines the material's id\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the last material with the given id or null if none found.\n     */\n    getLastMaterialById(id, allowMultiMaterials = false) {\n        for (let index = this.materials.length - 1; index >= 0; index--) {\n            if (this.materials[index].id === id) {\n                return this.materials[index];\n            }\n        }\n        if (allowMultiMaterials) {\n            for (let index = this.multiMaterials.length - 1; index >= 0; index--) {\n                if (this.multiMaterials[index].id === id) {\n                    return this.multiMaterials[index];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Get a texture using its unique id\n     * @param uniqueId defines the texture's unique id\n     * @returns the texture or null if none found.\n     */\n    getTextureByUniqueId(uniqueId) {\n        for (let index = 0; index < this.textures.length; index++) {\n            if (this.textures[index].uniqueId === uniqueId) {\n                return this.textures[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a texture using its name\n     * @param name defines the texture's name\n     * @returns the texture or null if none found.\n     */\n    getTextureByName(name) {\n        for (let index = 0; index < this.textures.length; index++) {\n            if (this.textures[index].name === name) {\n                return this.textures[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a camera using its Id\n     * @param id defines the Id to look for\n     * @returns the camera or null if not found\n     */\n    getCameraById(id) {\n        for (let index = 0; index < this.cameras.length; index++) {\n            if (this.cameras[index].id === id) {\n                return this.cameras[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a camera using its unique Id\n     * @param uniqueId defines the unique Id to look for\n     * @returns the camera or null if not found\n     */\n    getCameraByUniqueId(uniqueId) {\n        for (let index = 0; index < this.cameras.length; index++) {\n            if (this.cameras[index].uniqueId === uniqueId) {\n                return this.cameras[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a camera using its name\n     * @param name defines the camera's name\n     * @returns the camera or null if none found.\n     */\n    getCameraByName(name) {\n        for (let index = 0; index < this.cameras.length; index++) {\n            if (this.cameras[index].name === name) {\n                return this.cameras[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a bone using its Id\n     * @param id defines the bone's Id\n     * @returns the bone or null if not found\n     */\n    getBoneById(id) {\n        for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n            const skeleton = this.skeletons[skeletonIndex];\n            for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n                if (skeleton.bones[boneIndex].id === id) {\n                    return skeleton.bones[boneIndex];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a bone using its id\n     * @param name defines the bone's name\n     * @returns the bone or null if not found\n     */\n    getBoneByName(name) {\n        for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n            const skeleton = this.skeletons[skeletonIndex];\n            for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n                if (skeleton.bones[boneIndex].name === name) {\n                    return skeleton.bones[boneIndex];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a light node using its name\n     * @param name defines the the light's name\n     * @returns the light or null if none found.\n     */\n    getLightByName(name) {\n        for (let index = 0; index < this.lights.length; index++) {\n            if (this.lights[index].name === name) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a light node using its Id\n     * @param id defines the light's Id\n     * @returns the light or null if none found.\n     */\n    getLightById(id) {\n        for (let index = 0; index < this.lights.length; index++) {\n            if (this.lights[index].id === id) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a light node using its scene-generated unique Id\n     * @param uniqueId defines the light's unique Id\n     * @returns the light or null if none found.\n     */\n    getLightByUniqueId(uniqueId) {\n        for (let index = 0; index < this.lights.length; index++) {\n            if (this.lights[index].uniqueId === uniqueId) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a particle system by Id\n     * @param id defines the particle system Id\n     * @returns the corresponding system or null if none found\n     */\n    getParticleSystemById(id) {\n        for (let index = 0; index < this.particleSystems.length; index++) {\n            if (this.particleSystems[index].id === id) {\n                return this.particleSystems[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a geometry using its Id\n     * @param id defines the geometry's Id\n     * @returns the geometry or null if none found.\n     */\n    getGeometryById(id) {\n        for (let index = 0; index < this.geometries.length; index++) {\n            if (this.geometries[index].id === id) {\n                return this.geometries[index];\n            }\n        }\n        return null;\n    }\n    _getGeometryByUniqueId(uniqueId) {\n        if (this._geometriesByUniqueId) {\n            const index = this._geometriesByUniqueId[uniqueId];\n            if (index !== undefined) {\n                return this.geometries[index];\n            }\n        }\n        else {\n            for (let index = 0; index < this.geometries.length; index++) {\n                if (this.geometries[index].uniqueId === uniqueId) {\n                    return this.geometries[index];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Add a new geometry to this scene\n     * @param geometry defines the geometry to be added to the scene.\n     * @param force defines if the geometry must be pushed even if a geometry with this id already exists\n     * @returns a boolean defining if the geometry was added or not\n     */\n    pushGeometry(geometry, force) {\n        if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {\n            return false;\n        }\n        this.addGeometry(geometry);\n        this.onNewGeometryAddedObservable.notifyObservers(geometry);\n        return true;\n    }\n    /**\n     * Removes an existing geometry\n     * @param geometry defines the geometry to be removed from the scene\n     * @returns a boolean defining if the geometry was removed or not\n     */\n    removeGeometry(geometry) {\n        let index;\n        if (this._geometriesByUniqueId) {\n            index = this._geometriesByUniqueId[geometry.uniqueId];\n            if (index === undefined) {\n                return false;\n            }\n        }\n        else {\n            index = this.geometries.indexOf(geometry);\n            if (index < 0) {\n                return false;\n            }\n        }\n        if (index !== this.geometries.length - 1) {\n            const lastGeometry = this.geometries[this.geometries.length - 1];\n            if (lastGeometry) {\n                this.geometries[index] = lastGeometry;\n                if (this._geometriesByUniqueId) {\n                    this._geometriesByUniqueId[lastGeometry.uniqueId] = index;\n                }\n            }\n        }\n        if (this._geometriesByUniqueId) {\n            this._geometriesByUniqueId[geometry.uniqueId] = undefined;\n        }\n        this.geometries.pop();\n        this.onGeometryRemovedObservable.notifyObservers(geometry);\n        return true;\n    }\n    /**\n     * Gets the list of geometries attached to the scene\n     * @returns an array of Geometry\n     */\n    getGeometries() {\n        return this.geometries;\n    }\n    /**\n     * Gets the first added mesh found of a given Id\n     * @param id defines the Id to search for\n     * @returns the mesh found or null if not found at all\n     */\n    getMeshById(id) {\n        for (let index = 0; index < this.meshes.length; index++) {\n            if (this.meshes[index].id === id) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a list of meshes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of meshes\n     */\n    getMeshesById(id) {\n        return this.meshes.filter(function (m) {\n            return m.id === id;\n        });\n    }\n    /**\n     * Gets the first added transform node found of a given Id\n     * @param id defines the Id to search for\n     * @returns the found transform node or null if not found at all.\n     */\n    getTransformNodeById(id) {\n        for (let index = 0; index < this.transformNodes.length; index++) {\n            if (this.transformNodes[index].id === id) {\n                return this.transformNodes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a transform node with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @returns the found transform node or null if not found at all.\n     */\n    getTransformNodeByUniqueId(uniqueId) {\n        for (let index = 0; index < this.transformNodes.length; index++) {\n            if (this.transformNodes[index].uniqueId === uniqueId) {\n                return this.transformNodes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a list of transform nodes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of transform nodes\n     */\n    getTransformNodesById(id) {\n        return this.transformNodes.filter(function (m) {\n            return m.id === id;\n        });\n    }\n    /**\n     * Gets a mesh with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @returns the found mesh or null if not found at all.\n     */\n    getMeshByUniqueId(uniqueId) {\n        for (let index = 0; index < this.meshes.length; index++) {\n            if (this.meshes[index].uniqueId === uniqueId) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a the last added mesh using a given Id\n     * @param id defines the Id to search for\n     * @returns the found mesh or null if not found at all.\n     */\n    getLastMeshById(id) {\n        for (let index = this.meshes.length - 1; index >= 0; index--) {\n            if (this.meshes[index].id === id) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a the last added node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @returns the found node or null if not found at all\n     */\n    getLastEntryById(id) {\n        let index;\n        for (index = this.meshes.length - 1; index >= 0; index--) {\n            if (this.meshes[index].id === id) {\n                return this.meshes[index];\n            }\n        }\n        for (index = this.transformNodes.length - 1; index >= 0; index--) {\n            if (this.transformNodes[index].id === id) {\n                return this.transformNodes[index];\n            }\n        }\n        for (index = this.cameras.length - 1; index >= 0; index--) {\n            if (this.cameras[index].id === id) {\n                return this.cameras[index];\n            }\n        }\n        for (index = this.lights.length - 1; index >= 0; index--) {\n            if (this.lights[index].id === id) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @returns the found node or null if not found at all\n     */\n    getNodeById(id) {\n        const mesh = this.getMeshById(id);\n        if (mesh) {\n            return mesh;\n        }\n        const transformNode = this.getTransformNodeById(id);\n        if (transformNode) {\n            return transformNode;\n        }\n        const light = this.getLightById(id);\n        if (light) {\n            return light;\n        }\n        const camera = this.getCameraById(id);\n        if (camera) {\n            return camera;\n        }\n        const bone = this.getBoneById(id);\n        if (bone) {\n            return bone;\n        }\n        return null;\n    }\n    /**\n     * Gets a node (Mesh, Camera, Light) using a given name\n     * @param name defines the name to search for\n     * @returns the found node or null if not found at all.\n     */\n    getNodeByName(name) {\n        const mesh = this.getMeshByName(name);\n        if (mesh) {\n            return mesh;\n        }\n        const transformNode = this.getTransformNodeByName(name);\n        if (transformNode) {\n            return transformNode;\n        }\n        const light = this.getLightByName(name);\n        if (light) {\n            return light;\n        }\n        const camera = this.getCameraByName(name);\n        if (camera) {\n            return camera;\n        }\n        const bone = this.getBoneByName(name);\n        if (bone) {\n            return bone;\n        }\n        return null;\n    }\n    /**\n     * Gets a mesh using a given name\n     * @param name defines the name to search for\n     * @returns the found mesh or null if not found at all.\n     */\n    getMeshByName(name) {\n        for (let index = 0; index < this.meshes.length; index++) {\n            if (this.meshes[index].name === name) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a transform node using a given name\n     * @param name defines the name to search for\n     * @returns the found transform node or null if not found at all.\n     */\n    getTransformNodeByName(name) {\n        for (let index = 0; index < this.transformNodes.length; index++) {\n            if (this.transformNodes[index].name === name) {\n                return this.transformNodes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n     * @param id defines the Id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n    getLastSkeletonById(id) {\n        for (let index = this.skeletons.length - 1; index >= 0; index--) {\n            if (this.skeletons[index].id === id) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given auto generated unique id\n     * @param  uniqueId defines the unique id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n    getSkeletonByUniqueId(uniqueId) {\n        for (let index = 0; index < this.skeletons.length; index++) {\n            if (this.skeletons[index].uniqueId === uniqueId) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given id (if many are found, this function will pick the first one)\n     * @param id defines the id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n    getSkeletonById(id) {\n        for (let index = 0; index < this.skeletons.length; index++) {\n            if (this.skeletons[index].id === id) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given name\n     * @param name defines the name to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n    getSkeletonByName(name) {\n        for (let index = 0; index < this.skeletons.length; index++) {\n            if (this.skeletons[index].name === name) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\n     * @param id defines the id to search for\n     * @returns the found morph target manager or null if not found at all.\n     */\n    getMorphTargetManagerById(id) {\n        for (let index = 0; index < this.morphTargetManagers.length; index++) {\n            if (this.morphTargetManagers[index].uniqueId === id) {\n                return this.morphTargetManagers[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a morph target using a given id (if many are found, this function will pick the first one)\n     * @param id defines the id to search for\n     * @returns the found morph target or null if not found at all.\n     */\n    getMorphTargetById(id) {\n        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n            const morphTargetManager = this.morphTargetManagers[managerIndex];\n            for (let index = 0; index < morphTargetManager.numTargets; ++index) {\n                const target = morphTargetManager.getTarget(index);\n                if (target.id === id) {\n                    return target;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a morph target using a given name (if many are found, this function will pick the first one)\n     * @param name defines the name to search for\n     * @returns the found morph target or null if not found at all.\n     */\n    getMorphTargetByName(name) {\n        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n            const morphTargetManager = this.morphTargetManagers[managerIndex];\n            for (let index = 0; index < morphTargetManager.numTargets; ++index) {\n                const target = morphTargetManager.getTarget(index);\n                if (target.name === name) {\n                    return target;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a post process using a given name (if many are found, this function will pick the first one)\n     * @param name defines the name to search for\n     * @returns the found post process or null if not found at all.\n     */\n    getPostProcessByName(name) {\n        for (let postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\n            const postProcess = this.postProcesses[postProcessIndex];\n            if (postProcess.name === name) {\n                return postProcess;\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a boolean indicating if the given mesh is active\n     * @param mesh defines the mesh to look for\n     * @returns true if the mesh is in the active list\n     */\n    isActiveMesh(mesh) {\n        return this._activeMeshes.indexOf(mesh) !== -1;\n    }\n    /**\n     * Return a unique id as a string which can serve as an identifier for the scene\n     */\n    get uid() {\n        if (!this._uid) {\n            this._uid = Tools.RandomId();\n        }\n        return this._uid;\n    }\n    /**\n     * Add an externally attached data from its key.\n     * This method call will fail and return false, if such key already exists.\n     * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\n     * @param key the unique key that identifies the data\n     * @param data the data object to associate to the key for this Engine instance\n     * @returns true if no such key were already present and the data was added successfully, false otherwise\n     */\n    addExternalData(key, data) {\n        if (!this._externalData) {\n            this._externalData = new StringDictionary();\n        }\n        return this._externalData.add(key, data);\n    }\n    /**\n     * Get an externally attached data from its key\n     * @param key the unique key that identifies the data\n     * @returns the associated data, if present (can be null), or undefined if not present\n     */\n    getExternalData(key) {\n        if (!this._externalData) {\n            return null;\n        }\n        return this._externalData.get(key);\n    }\n    /**\n     * Get an externally attached data from its key, create it using a factory if it's not already present\n     * @param key the unique key that identifies the data\n     * @param factory the factory that will be called to create the instance if and only if it doesn't exists\n     * @returns the associated data, can be null if the factory returned null.\n     */\n    getOrAddExternalDataWithFactory(key, factory) {\n        if (!this._externalData) {\n            this._externalData = new StringDictionary();\n        }\n        return this._externalData.getOrAddWithFactory(key, factory);\n    }\n    /**\n     * Remove an externally attached data from the Engine instance\n     * @param key the unique key that identifies the data\n     * @returns true if the data was successfully removed, false if it doesn't exist\n     */\n    removeExternalData(key) {\n        return this._externalData.remove(key);\n    }\n    _evaluateSubMesh(subMesh, mesh, initialMesh, forcePush) {\n        if (forcePush || subMesh.isInFrustum(this._frustumPlanes)) {\n            for (const step of this._evaluateSubMeshStage) {\n                step.action(mesh, subMesh);\n            }\n            const material = subMesh.getMaterial();\n            if (material !== null && material !== undefined) {\n                // Render targets\n                if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n                    if (this._processedMaterials.indexOf(material) === -1) {\n                        this._processedMaterials.push(material);\n                        this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n                    }\n                }\n                // Dispatch\n                this._renderingManager.dispatch(subMesh, mesh, material);\n            }\n        }\n    }\n    /**\n     * Clear the processed materials smart array preventing retention point in material dispose.\n     */\n    freeProcessedMaterials() {\n        this._processedMaterials.dispose();\n    }\n    /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\n     * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\n     * when disposing several meshes in a row or a hierarchy of meshes.\n     * When used, it is the responsibility of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\n     */\n    get blockfreeActiveMeshesAndRenderingGroups() {\n        return this._preventFreeActiveMeshesAndRenderingGroups;\n    }\n    set blockfreeActiveMeshesAndRenderingGroups(value) {\n        if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\n            return;\n        }\n        if (value) {\n            this.freeActiveMeshes();\n            this.freeRenderingGroups();\n        }\n        this._preventFreeActiveMeshesAndRenderingGroups = value;\n    }\n    /**\n     * Clear the active meshes smart array preventing retention point in mesh dispose.\n     */\n    freeActiveMeshes() {\n        if (this.blockfreeActiveMeshesAndRenderingGroups) {\n            return;\n        }\n        this._activeMeshes.dispose();\n        if (this.activeCamera && this.activeCamera._activeMeshes) {\n            this.activeCamera._activeMeshes.dispose();\n        }\n        if (this.activeCameras) {\n            for (let i = 0; i < this.activeCameras.length; i++) {\n                const activeCamera = this.activeCameras[i];\n                if (activeCamera && activeCamera._activeMeshes) {\n                    activeCamera._activeMeshes.dispose();\n                }\n            }\n        }\n    }\n    /**\n     * Clear the info related to rendering groups preventing retention points during dispose.\n     */\n    freeRenderingGroups() {\n        if (this.blockfreeActiveMeshesAndRenderingGroups) {\n            return;\n        }\n        if (this._renderingManager) {\n            this._renderingManager.freeRenderingGroups();\n        }\n        if (this.textures) {\n            for (let i = 0; i < this.textures.length; i++) {\n                const texture = this.textures[i];\n                if (texture && texture.renderList) {\n                    texture.freeRenderingGroups();\n                }\n            }\n        }\n    }\n    /** @internal */\n    _isInIntermediateRendering() {\n        return this._intermediateRendering;\n    }\n    /**\n     * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\n     * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\n     * @param onSuccess optional success callback\n     * @param onError optional error callback\n     * @param freezeMeshes defines if meshes should be frozen (true by default)\n     * @param keepFrustumCulling defines if you want to keep running the frustum clipping (false by default)\n     * @returns the current scene\n     */\n    freezeActiveMeshes(skipEvaluateActiveMeshes = false, onSuccess, onError, freezeMeshes = true, keepFrustumCulling = false) {\n        this.executeWhenReady(() => {\n            if (!this.activeCamera) {\n                onError && onError(\"No active camera found\");\n                return;\n            }\n            if (!this._frustumPlanes) {\n                this.updateTransformMatrix();\n            }\n            this._evaluateActiveMeshes();\n            this._activeMeshesFrozen = true;\n            this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;\n            this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\n            if (freezeMeshes) {\n                for (let index = 0; index < this._activeMeshes.length; index++) {\n                    this._activeMeshes.data[index]._freeze();\n                }\n            }\n            onSuccess && onSuccess();\n        });\n        return this;\n    }\n    /**\n     * Use this function to restart evaluating active meshes on every frame\n     * @returns the current scene\n     */\n    unfreezeActiveMeshes() {\n        for (let index = 0; index < this.meshes.length; index++) {\n            const mesh = this.meshes[index];\n            if (mesh._internalAbstractMeshDataInfo) {\n                mesh._internalAbstractMeshDataInfo._isActive = false;\n            }\n        }\n        for (let index = 0; index < this._activeMeshes.length; index++) {\n            this._activeMeshes.data[index]._unFreeze();\n        }\n        this._activeMeshesFrozen = false;\n        return this;\n    }\n    _executeActiveContainerCleanup(container) {\n        const isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;\n        if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {\n            return; // Do not execute in frozen mode\n        }\n        // We need to ensure we are not in the rendering loop\n        this.onBeforeRenderObservable.addOnce(() => container.dispose());\n    }\n    _evaluateActiveMeshes() {\n        var _a;\n        if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {\n            if (this._activeMeshes.length > 0) {\n                (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a._activeMeshes.reset();\n                this._activeMeshes.reset();\n                this._renderingManager.reset();\n                this._processedMaterials.reset();\n                this._activeParticleSystems.reset();\n                this._activeSkeletons.reset();\n                this._softwareSkinnedMeshes.reset();\n            }\n            return;\n        }\n        if (this._activeMeshesFrozen && this._activeMeshes.length) {\n            if (!this._skipEvaluateActiveMeshesCompletely) {\n                const len = this._activeMeshes.length;\n                for (let i = 0; i < len; i++) {\n                    const mesh = this._activeMeshes.data[i];\n                    mesh.computeWorldMatrix();\n                }\n            }\n            if (this._activeParticleSystems) {\n                const psLength = this._activeParticleSystems.length;\n                for (let i = 0; i < psLength; i++) {\n                    this._activeParticleSystems.data[i].animate();\n                }\n            }\n            this._renderingManager.resetSprites();\n            return;\n        }\n        if (!this.activeCamera) {\n            return;\n        }\n        this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\n        this.activeCamera._activeMeshes.reset();\n        this._activeMeshes.reset();\n        this._renderingManager.reset();\n        this._processedMaterials.reset();\n        this._activeParticleSystems.reset();\n        this._activeSkeletons.reset();\n        this._softwareSkinnedMeshes.reset();\n        this._materialsRenderTargets.reset();\n        for (const step of this._beforeEvaluateActiveMeshStage) {\n            step.action();\n        }\n        // Determine mesh candidates\n        const meshes = this.getActiveMeshCandidates();\n        // Check each mesh\n        const len = meshes.length;\n        for (let i = 0; i < len; i++) {\n            const mesh = meshes.data[i];\n            mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\n            if (mesh.isBlocked) {\n                continue;\n            }\n            this._totalVertices.addCount(mesh.getTotalVertices(), false);\n            if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {\n                continue;\n            }\n            mesh.computeWorldMatrix();\n            // Intersections\n            if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {\n                this._meshesForIntersections.pushNoDuplicate(mesh);\n            }\n            // Switch to current LOD\n            let meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);\n            mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\n            mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n            if (meshToRender === undefined || meshToRender === null) {\n                continue;\n            }\n            // Compute world matrix if LOD is billboard\n            if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {\n                meshToRender.computeWorldMatrix();\n            }\n            mesh._preActivate();\n            if (mesh.isVisible &&\n                mesh.visibility > 0 &&\n                (mesh.layerMask & this.activeCamera.layerMask) !== 0 &&\n                (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {\n                this._activeMeshes.push(mesh);\n                this.activeCamera._activeMeshes.push(mesh);\n                if (meshToRender !== mesh) {\n                    meshToRender._activate(this._renderId, false);\n                }\n                for (const step of this._preActiveMeshStage) {\n                    step.action(mesh);\n                }\n                if (mesh._activate(this._renderId, false)) {\n                    if (!mesh.isAnInstance) {\n                        meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\n                    }\n                    else {\n                        if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n                            meshToRender = mesh;\n                        }\n                    }\n                    meshToRender._internalAbstractMeshDataInfo._isActive = true;\n                    this._activeMesh(mesh, meshToRender);\n                }\n                mesh._postActivate();\n            }\n        }\n        this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);\n        // Particle systems\n        if (this.particlesEnabled) {\n            this.onBeforeParticlesRenderingObservable.notifyObservers(this);\n            for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n                const particleSystem = this.particleSystems[particleIndex];\n                if (!particleSystem.isStarted() || !particleSystem.emitter) {\n                    continue;\n                }\n                const emitter = particleSystem.emitter;\n                if (!emitter.position || emitter.isEnabled()) {\n                    this._activeParticleSystems.push(particleSystem);\n                    particleSystem.animate();\n                    this._renderingManager.dispatchParticles(particleSystem);\n                }\n            }\n            this.onAfterParticlesRenderingObservable.notifyObservers(this);\n        }\n    }\n    _activeMesh(sourceMesh, mesh) {\n        if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== undefined) {\n            if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\n                mesh.skeleton.prepare();\n                this._activeBones.addCount(mesh.skeleton.bones.length, false);\n            }\n            if (!mesh.computeBonesUsingShaders) {\n                this._softwareSkinnedMeshes.pushNoDuplicate(mesh);\n            }\n        }\n        let forcePush = sourceMesh.hasInstances || sourceMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh;\n        if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {\n            const subMeshes = this.getActiveSubMeshCandidates(mesh);\n            const len = subMeshes.length;\n            forcePush = forcePush || len === 1;\n            for (let i = 0; i < len; i++) {\n                const subMesh = subMeshes.data[i];\n                this._evaluateSubMesh(subMesh, mesh, sourceMesh, forcePush);\n            }\n        }\n    }\n    /**\n     * Update the transform matrix to update from the current active camera\n     * @param force defines a boolean used to force the update even if cache is up to date\n     */\n    updateTransformMatrix(force) {\n        if (!this.activeCamera) {\n            return;\n        }\n        if (this.activeCamera._renderingMultiview) {\n            const leftCamera = this.activeCamera._rigCameras[0];\n            const rightCamera = this.activeCamera._rigCameras[1];\n            this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));\n        }\n        else {\n            this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\n        }\n    }\n    _bindFrameBuffer(camera, clear = true) {\n        if (camera && camera._multiviewTexture) {\n            camera._multiviewTexture._bindFrameBuffer();\n        }\n        else if (camera && camera.outputRenderTarget) {\n            camera.outputRenderTarget._bindFrameBuffer();\n        }\n        else {\n            if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {\n                this._engine.restoreDefaultFramebuffer();\n            }\n        }\n        if (clear) {\n            this._clearFrameBuffer(camera);\n        }\n    }\n    _clearFrameBuffer(camera) {\n        // we assume the framebuffer currently bound is the right one\n        if (camera && camera._multiviewTexture) {\n            // no clearing?\n        }\n        else if (camera && camera.outputRenderTarget && !camera._renderingMultiview) {\n            const rtt = camera.outputRenderTarget;\n            if (rtt.onClearObservable.hasObservers()) {\n                rtt.onClearObservable.notifyObservers(this._engine);\n            }\n            else if (!rtt.skipInitialClear) {\n                if (this.autoClear) {\n                    this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);\n                }\n                rtt._cleared = true;\n            }\n        }\n        else {\n            if (!this._defaultFrameBufferCleared) {\n                this._defaultFrameBufferCleared = true;\n                this._clear();\n            }\n            else {\n                this._engine.clear(null, false, true, true);\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _renderForCamera(camera, rigParent, bindFrameBuffer = true) {\n        var _a, _b, _c;\n        if (camera && camera._skipRendering) {\n            return;\n        }\n        const engine = this._engine;\n        // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n        this._activeCamera = camera;\n        if (!this.activeCamera) {\n            throw new Error(\"Active camera not set\");\n        }\n        // Viewport\n        engine.setViewport(this.activeCamera.viewport);\n        // Camera\n        this.resetCachedMaterial();\n        this._renderId++;\n        if (!this.prePass && bindFrameBuffer) {\n            let skipInitialClear = true;\n            if (camera._renderingMultiview && camera.outputRenderTarget) {\n                skipInitialClear = camera.outputRenderTarget.skipInitialClear;\n                if (this.autoClear) {\n                    this._defaultFrameBufferCleared = false;\n                    camera.outputRenderTarget.skipInitialClear = false;\n                }\n            }\n            this._bindFrameBuffer(this._activeCamera);\n            if (camera._renderingMultiview && camera.outputRenderTarget) {\n                camera.outputRenderTarget.skipInitialClear = skipInitialClear;\n            }\n        }\n        this.updateTransformMatrix();\n        this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);\n        // Meshes\n        this._evaluateActiveMeshes();\n        // Software skinning\n        for (let softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\n            const mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\n            mesh.applySkeleton(mesh.skeleton);\n        }\n        // Render targets\n        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n        this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);\n        if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\n            this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\n        }\n        if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\n            this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\n        }\n        if (this.environmentTexture && this.environmentTexture.isRenderTarget) {\n            this._renderTargets.pushNoDuplicate(this.environmentTexture);\n        }\n        // Collects render targets from external components.\n        for (const step of this._gatherActiveCameraRenderTargetsStage) {\n            step.action(this._renderTargets);\n        }\n        let needRebind = false;\n        if (this.renderTargetsEnabled) {\n            this._intermediateRendering = true;\n            if (this._renderTargets.length > 0) {\n                Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n                for (let renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\n                    const renderTarget = this._renderTargets.data[renderIndex];\n                    if (renderTarget._shouldRender()) {\n                        this._renderId++;\n                        const hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\n                        renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\n                        needRebind = true;\n                    }\n                }\n                Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n                this._renderId++;\n            }\n            for (const step of this._cameraDrawRenderTargetStage) {\n                needRebind = step.action(this.activeCamera) || needRebind;\n            }\n            this._intermediateRendering = false;\n        }\n        this._engine.currentRenderPassId = (_c = (_b = (_a = camera.outputRenderTarget) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : camera.renderPassId) !== null && _c !== void 0 ? _c : 0;\n        // Restore framebuffer after rendering to targets\n        if (needRebind && !this.prePass) {\n            this._bindFrameBuffer(this._activeCamera, false);\n        }\n        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n        // Prepare Frame\n        if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\n            this.postProcessManager._prepareFrame();\n        }\n        // Before Camera Draw\n        for (const step of this._beforeCameraDrawStage) {\n            step.action(this.activeCamera);\n        }\n        // Render\n        this.onBeforeDrawPhaseObservable.notifyObservers(this);\n        if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {\n            this.finalizeSceneUbo();\n        }\n        this._renderingManager.render(null, null, true, true);\n        this.onAfterDrawPhaseObservable.notifyObservers(this);\n        // After Camera Draw\n        for (const step of this._afterCameraDrawStage) {\n            step.action(this.activeCamera);\n        }\n        // Finalize frame\n        if (this.postProcessManager && !camera._multiviewTexture) {\n            // if the camera has an output render target, render the post process to the render target\n            const texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : undefined;\n            this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\n        }\n        // After post process\n        for (const step of this._afterCameraPostProcessStage) {\n            step.action(this.activeCamera);\n        }\n        // Reset some special arrays\n        this._renderTargets.reset();\n        this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n    }\n    _processSubCameras(camera, bindFrameBuffer = true) {\n        if (camera.cameraRigMode === 0 || camera._renderingMultiview) {\n            if (camera._renderingMultiview && !this._multiviewSceneUbo) {\n                this._createMultiviewUbo();\n            }\n            this._renderForCamera(camera, undefined, bindFrameBuffer);\n            this.onAfterRenderCameraObservable.notifyObservers(camera);\n            return;\n        }\n        if (camera._useMultiviewToSingleView) {\n            this._renderMultiviewToSingleView(camera);\n        }\n        else {\n            // rig cameras\n            this.onBeforeCameraRenderObservable.notifyObservers(camera);\n            for (let index = 0; index < camera._rigCameras.length; index++) {\n                this._renderForCamera(camera._rigCameras[index], camera);\n            }\n        }\n        // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n        this._activeCamera = camera;\n        this.updateTransformMatrix();\n        this.onAfterRenderCameraObservable.notifyObservers(camera);\n    }\n    _checkIntersections() {\n        for (let index = 0; index < this._meshesForIntersections.length; index++) {\n            const sourceMesh = this._meshesForIntersections.data[index];\n            if (!sourceMesh.actionManager) {\n                continue;\n            }\n            for (let actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\n                const action = sourceMesh.actionManager.actions[actionIndex];\n                if (action.trigger === 12 || action.trigger === 13) {\n                    const parameters = action.getTriggerParameter();\n                    const otherMesh = parameters.mesh ? parameters.mesh : parameters;\n                    const areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\n                    const currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\n                    if (areIntersecting && currentIntersectionInProgress === -1) {\n                        if (action.trigger === 12) {\n                            action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n                            sourceMesh._intersectionsInProgress.push(otherMesh);\n                        }\n                        else if (action.trigger === 13) {\n                            sourceMesh._intersectionsInProgress.push(otherMesh);\n                        }\n                    }\n                    else if (!areIntersecting && currentIntersectionInProgress > -1) {\n                        //They intersected, and now they don't.\n                        //is this trigger an exit trigger? execute an event.\n                        if (action.trigger === 13) {\n                            action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n                        }\n                        //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\n                        if (!sourceMesh.actionManager.hasSpecificTrigger(13, (parameter) => {\n                            const parameterMesh = parameter.mesh ? parameter.mesh : parameter;\n                            return otherMesh === parameterMesh;\n                        }) ||\n                            action.trigger === 13) {\n                            sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _advancePhysicsEngineStep(step) {\n        // Do nothing. Code will be replaced if physics engine component is referenced\n    }\n    /** @internal */\n    _animate() {\n        // Nothing to do as long as Animatable have not been imported.\n    }\n    /** Execute all animations (for a frame) */\n    animate() {\n        if (this._engine.isDeterministicLockStep()) {\n            let deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\n            const defaultFrameTime = this._engine.getTimeStep();\n            const defaultFPS = 1000.0 / defaultFrameTime / 1000.0;\n            let stepsTaken = 0;\n            const maxSubSteps = this._engine.getLockstepMaxSteps();\n            let internalSteps = Math.floor(deltaTime / defaultFrameTime);\n            internalSteps = Math.min(internalSteps, maxSubSteps);\n            while (deltaTime > 0 && stepsTaken < internalSteps) {\n                this.onBeforeStepObservable.notifyObservers(this);\n                // Animations\n                this._animationRatio = defaultFrameTime * defaultFPS;\n                this._animate();\n                this.onAfterAnimationsObservable.notifyObservers(this);\n                // Physics\n                if (this.physicsEnabled) {\n                    this._advancePhysicsEngineStep(defaultFrameTime);\n                }\n                this.onAfterStepObservable.notifyObservers(this);\n                this._currentStepId++;\n                stepsTaken++;\n                deltaTime -= defaultFrameTime;\n            }\n            this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\n        }\n        else {\n            // Animations\n            const deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\n            this._animationRatio = deltaTime * (60.0 / 1000.0);\n            this._animate();\n            this.onAfterAnimationsObservable.notifyObservers(this);\n            // Physics\n            if (this.physicsEnabled) {\n                this._advancePhysicsEngineStep(deltaTime);\n            }\n        }\n    }\n    _clear() {\n        if (this.autoClearDepthAndStencil || this.autoClear) {\n            this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n        }\n    }\n    _checkCameraRenderTarget(camera) {\n        var _a;\n        if ((camera === null || camera === void 0 ? void 0 : camera.outputRenderTarget) && !(camera === null || camera === void 0 ? void 0 : camera.isRigCamera)) {\n            camera.outputRenderTarget._cleared = false;\n        }\n        if ((_a = camera === null || camera === void 0 ? void 0 : camera.rigCameras) === null || _a === void 0 ? void 0 : _a.length) {\n            for (let i = 0; i < camera.rigCameras.length; ++i) {\n                const rtt = camera.rigCameras[i].outputRenderTarget;\n                if (rtt) {\n                    rtt._cleared = false;\n                }\n            }\n        }\n    }\n    /**\n     * Resets the draw wrappers cache of all meshes\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n     */\n    resetDrawCache(passId) {\n        if (!this.meshes) {\n            return;\n        }\n        for (const mesh of this.meshes) {\n            mesh.resetDrawCache(passId);\n        }\n    }\n    /**\n     * Render the scene\n     * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\n     * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\n     */\n    render(updateCameras = true, ignoreAnimations = false) {\n        var _a, _b, _c;\n        if (this.isDisposed) {\n            return;\n        }\n        if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {\n            this._checkIsReady();\n        }\n        this._frameId++;\n        this._defaultFrameBufferCleared = false;\n        this._checkCameraRenderTarget(this.activeCamera);\n        if ((_a = this.activeCameras) === null || _a === void 0 ? void 0 : _a.length) {\n            this.activeCameras.forEach(this._checkCameraRenderTarget);\n        }\n        // Register components that have been associated lately to the scene.\n        this._registerTransientComponents();\n        this._activeParticles.fetchNewFrame();\n        this._totalVertices.fetchNewFrame();\n        this._activeIndices.fetchNewFrame();\n        this._activeBones.fetchNewFrame();\n        this._meshesForIntersections.reset();\n        this.resetCachedMaterial();\n        this.onBeforeAnimationsObservable.notifyObservers(this);\n        // Actions\n        if (this.actionManager) {\n            this.actionManager.processTrigger(11);\n        }\n        // Animations\n        if (!ignoreAnimations) {\n            this.animate();\n        }\n        // Before camera update steps\n        for (const step of this._beforeCameraUpdateStage) {\n            step.action();\n        }\n        // Update Cameras\n        if (updateCameras) {\n            if (this.activeCameras && this.activeCameras.length > 0) {\n                for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n                    const camera = this.activeCameras[cameraIndex];\n                    camera.update();\n                    if (camera.cameraRigMode !== 0) {\n                        // rig cameras\n                        for (let index = 0; index < camera._rigCameras.length; index++) {\n                            camera._rigCameras[index].update();\n                        }\n                    }\n                }\n            }\n            else if (this.activeCamera) {\n                this.activeCamera.update();\n                if (this.activeCamera.cameraRigMode !== 0) {\n                    // rig cameras\n                    for (let index = 0; index < this.activeCamera._rigCameras.length; index++) {\n                        this.activeCamera._rigCameras[index].update();\n                    }\n                }\n            }\n        }\n        // Before render\n        this.onBeforeRenderObservable.notifyObservers(this);\n        const engine = this.getEngine();\n        // Customs render targets\n        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n        const currentActiveCamera = ((_b = this.activeCameras) === null || _b === void 0 ? void 0 : _b.length) ? this.activeCameras[0] : this.activeCamera;\n        if (this.renderTargetsEnabled) {\n            Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n            this._intermediateRendering = true;\n            for (let customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\n                const renderTarget = this.customRenderTargets[customIndex];\n                if (renderTarget._shouldRender()) {\n                    this._renderId++;\n                    this.activeCamera = renderTarget.activeCamera || this.activeCamera;\n                    if (!this.activeCamera) {\n                        throw new Error(\"Active camera not set\");\n                    }\n                    // Viewport\n                    engine.setViewport(this.activeCamera.viewport);\n                    // Camera\n                    this.updateTransformMatrix();\n                    renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\n                }\n            }\n            Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n            this._intermediateRendering = false;\n            this._renderId++;\n        }\n        this._engine.currentRenderPassId = (_c = currentActiveCamera === null || currentActiveCamera === void 0 ? void 0 : currentActiveCamera.renderPassId) !== null && _c !== void 0 ? _c : 0;\n        // Restore back buffer\n        this.activeCamera = currentActiveCamera;\n        if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {\n            this._bindFrameBuffer(this._activeCamera, false);\n        }\n        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n        for (const step of this._beforeClearStage) {\n            step.action();\n        }\n        // Clear\n        this._clearFrameBuffer(this.activeCamera);\n        // Collects render targets from external components.\n        for (const step of this._gatherRenderTargetsStage) {\n            step.action(this._renderTargets);\n        }\n        // Multi-cameras?\n        if (this.activeCameras && this.activeCameras.length > 0) {\n            for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n                this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);\n            }\n        }\n        else {\n            if (!this.activeCamera) {\n                throw new Error(\"No camera defined\");\n            }\n            this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);\n        }\n        // Intersection checks\n        this._checkIntersections();\n        // Executes the after render stage actions.\n        for (const step of this._afterRenderStage) {\n            step.action();\n        }\n        // After render\n        if (this.afterRender) {\n            this.afterRender();\n        }\n        this.onAfterRenderObservable.notifyObservers(this);\n        // Cleaning\n        if (this._toBeDisposed.length) {\n            for (let index = 0; index < this._toBeDisposed.length; index++) {\n                const data = this._toBeDisposed[index];\n                if (data) {\n                    data.dispose();\n                }\n            }\n            this._toBeDisposed.length = 0;\n        }\n        if (this.dumpNextRenderTargets) {\n            this.dumpNextRenderTargets = false;\n        }\n        this._activeBones.addCount(0, true);\n        this._activeIndices.addCount(0, true);\n        this._activeParticles.addCount(0, true);\n        this._engine.restoreDefaultFramebuffer();\n    }\n    /**\n     * Freeze all materials\n     * A frozen material will not be updatable but should be faster to render\n     * Note: multimaterials will not be frozen, but their submaterials will\n     */\n    freezeMaterials() {\n        for (let i = 0; i < this.materials.length; i++) {\n            this.materials[i].freeze();\n        }\n    }\n    /**\n     * Unfreeze all materials\n     * A frozen material will not be updatable but should be faster to render\n     */\n    unfreezeMaterials() {\n        for (let i = 0; i < this.materials.length; i++) {\n            this.materials[i].unfreeze();\n        }\n    }\n    /**\n     * Releases all held resources\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.beforeRender = null;\n        this.afterRender = null;\n        this.metadata = null;\n        this.skeletons.length = 0;\n        this.morphTargetManagers.length = 0;\n        this._transientComponents.length = 0;\n        this._isReadyForMeshStage.clear();\n        this._beforeEvaluateActiveMeshStage.clear();\n        this._evaluateSubMeshStage.clear();\n        this._preActiveMeshStage.clear();\n        this._cameraDrawRenderTargetStage.clear();\n        this._beforeCameraDrawStage.clear();\n        this._beforeRenderTargetDrawStage.clear();\n        this._beforeRenderingGroupDrawStage.clear();\n        this._beforeRenderingMeshStage.clear();\n        this._afterRenderingMeshStage.clear();\n        this._afterRenderingGroupDrawStage.clear();\n        this._afterCameraDrawStage.clear();\n        this._afterRenderTargetDrawStage.clear();\n        this._afterRenderStage.clear();\n        this._beforeCameraUpdateStage.clear();\n        this._beforeClearStage.clear();\n        this._gatherRenderTargetsStage.clear();\n        this._gatherActiveCameraRenderTargetsStage.clear();\n        this._pointerMoveStage.clear();\n        this._pointerDownStage.clear();\n        this._pointerUpStage.clear();\n        this.importedMeshesFiles = new Array();\n        if (this.stopAllAnimations) {\n            this.stopAllAnimations();\n        }\n        this.resetCachedMaterial();\n        // Smart arrays\n        if (this.activeCamera) {\n            this.activeCamera._activeMeshes.dispose();\n            this.activeCamera = null;\n        }\n        this.activeCameras = null;\n        this._activeMeshes.dispose();\n        this._renderingManager.dispose();\n        this._processedMaterials.dispose();\n        this._activeParticleSystems.dispose();\n        this._activeSkeletons.dispose();\n        this._softwareSkinnedMeshes.dispose();\n        this._renderTargets.dispose();\n        this._materialsRenderTargets.dispose();\n        this._registeredForLateAnimationBindings.dispose();\n        this._meshesForIntersections.dispose();\n        this._toBeDisposed.length = 0;\n        // Abort active requests\n        const activeRequests = this._activeRequests.slice();\n        for (const request of activeRequests) {\n            request.abort();\n        }\n        this._activeRequests.length = 0;\n        // Events\n        try {\n            this.onDisposeObservable.notifyObservers(this);\n        }\n        catch (e) {\n            console.error(\"An error occurred while calling onDisposeObservable!\", e);\n        }\n        this.detachControl();\n        // Detach cameras\n        const canvas = this._engine.getInputElement();\n        if (canvas) {\n            for (let index = 0; index < this.cameras.length; index++) {\n                this.cameras[index].detachControl();\n            }\n        }\n        // Release animation groups\n        this._disposeList(this.animationGroups);\n        // Release lights\n        this._disposeList(this.lights);\n        // Release meshes\n        this._disposeList(this.meshes, (item) => item.dispose(true));\n        this._disposeList(this.transformNodes, (item) => item.dispose(true));\n        // Release cameras\n        const cameras = this.cameras;\n        this._disposeList(cameras);\n        // Release materials\n        if (this._defaultMaterial) {\n            this._defaultMaterial.dispose();\n        }\n        this._disposeList(this.multiMaterials);\n        this._disposeList(this.materials);\n        // Release particles\n        this._disposeList(this.particleSystems);\n        // Release postProcesses\n        this._disposeList(this.postProcesses);\n        // Release textures\n        this._disposeList(this.textures);\n        // Release morph targets\n        this._disposeList(this.morphTargetManagers);\n        // Release UBO\n        this._sceneUbo.dispose();\n        if (this._multiviewSceneUbo) {\n            this._multiviewSceneUbo.dispose();\n        }\n        // Post-processes\n        this.postProcessManager.dispose();\n        // Components\n        this._disposeList(this._components);\n        // Remove from engine\n        let index = this._engine.scenes.indexOf(this);\n        if (index > -1) {\n            this._engine.scenes.splice(index, 1);\n        }\n        if (EngineStore._LastCreatedScene === this) {\n            if (this._engine.scenes.length > 0) {\n                EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];\n            }\n            else {\n                EngineStore._LastCreatedScene = null;\n            }\n        }\n        index = this._engine._virtualScenes.indexOf(this);\n        if (index > -1) {\n            this._engine._virtualScenes.splice(index, 1);\n        }\n        this._engine.wipeCaches(true);\n        this.onDisposeObservable.clear();\n        this.onBeforeRenderObservable.clear();\n        this.onAfterRenderObservable.clear();\n        this.onBeforeRenderTargetsRenderObservable.clear();\n        this.onAfterRenderTargetsRenderObservable.clear();\n        this.onAfterStepObservable.clear();\n        this.onBeforeStepObservable.clear();\n        this.onBeforeActiveMeshesEvaluationObservable.clear();\n        this.onAfterActiveMeshesEvaluationObservable.clear();\n        this.onBeforeParticlesRenderingObservable.clear();\n        this.onAfterParticlesRenderingObservable.clear();\n        this.onBeforeDrawPhaseObservable.clear();\n        this.onAfterDrawPhaseObservable.clear();\n        this.onBeforeAnimationsObservable.clear();\n        this.onAfterAnimationsObservable.clear();\n        this.onDataLoadedObservable.clear();\n        this.onBeforeRenderingGroupObservable.clear();\n        this.onAfterRenderingGroupObservable.clear();\n        this.onMeshImportedObservable.clear();\n        this.onBeforeCameraRenderObservable.clear();\n        this.onAfterCameraRenderObservable.clear();\n        this.onAfterRenderCameraObservable.clear();\n        this.onReadyObservable.clear();\n        this.onNewCameraAddedObservable.clear();\n        this.onCameraRemovedObservable.clear();\n        this.onNewLightAddedObservable.clear();\n        this.onLightRemovedObservable.clear();\n        this.onNewGeometryAddedObservable.clear();\n        this.onGeometryRemovedObservable.clear();\n        this.onNewTransformNodeAddedObservable.clear();\n        this.onTransformNodeRemovedObservable.clear();\n        this.onNewMeshAddedObservable.clear();\n        this.onMeshRemovedObservable.clear();\n        this.onNewSkeletonAddedObservable.clear();\n        this.onSkeletonRemovedObservable.clear();\n        this.onNewMaterialAddedObservable.clear();\n        this.onNewMultiMaterialAddedObservable.clear();\n        this.onMaterialRemovedObservable.clear();\n        this.onMultiMaterialRemovedObservable.clear();\n        this.onNewTextureAddedObservable.clear();\n        this.onTextureRemovedObservable.clear();\n        this.onPrePointerObservable.clear();\n        this.onPointerObservable.clear();\n        this.onPreKeyboardObservable.clear();\n        this.onKeyboardObservable.clear();\n        this.onActiveCameraChanged.clear();\n        this.onScenePerformancePriorityChangedObservable.clear();\n        this._isDisposed = true;\n    }\n    _disposeList(items, callback) {\n        const itemsCopy = items.slice(0);\n        callback = callback !== null && callback !== void 0 ? callback : ((item) => item.dispose());\n        for (const item of itemsCopy) {\n            callback(item);\n        }\n        items.length = 0;\n    }\n    /**\n     * Gets if the scene is already disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Call this function to reduce memory footprint of the scene.\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n     */\n    clearCachedVertexData() {\n        for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n            const mesh = this.meshes[meshIndex];\n            const geometry = mesh.geometry;\n            if (geometry) {\n                geometry.clearCachedData();\n            }\n        }\n    }\n    /**\n     * This function will remove the local cached buffer data from texture.\n     * It will save memory but will prevent the texture from being rebuilt\n     */\n    cleanCachedTextureBuffer() {\n        for (const baseTexture of this.textures) {\n            const buffer = baseTexture._buffer;\n            if (buffer) {\n                baseTexture._buffer = null;\n            }\n        }\n    }\n    /**\n     * Get the world extend vectors with an optional filter\n     *\n     * @param filterPredicate the predicate - which meshes should be included when calculating the world size\n     * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\n     */\n    getWorldExtends(filterPredicate) {\n        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        filterPredicate = filterPredicate || (() => true);\n        this.meshes.filter(filterPredicate).forEach((mesh) => {\n            mesh.computeWorldMatrix(true);\n            if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\n                return;\n            }\n            const boundingInfo = mesh.getBoundingInfo();\n            const minBox = boundingInfo.boundingBox.minimumWorld;\n            const maxBox = boundingInfo.boundingBox.maximumWorld;\n            Vector3.CheckExtends(minBox, min, max);\n            Vector3.CheckExtends(maxBox, min, max);\n        });\n        return {\n            min: min,\n            max: max,\n        };\n    }\n    // Picking\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n     * @param camera defines the camera to use for the picking\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\n     * @returns a Ray\n     */\n    createPickingRay(x, y, world, camera, cameraViewSpace = false) {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n     * @param result defines the ray where to store the picking ray\n     * @param camera defines the camera to use for the picking\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n     * @returns the current scene\n     */\n    createPickingRayToRef(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param camera defines the camera to use for the picking\n     * @returns a Ray\n     */\n    createPickingRayInCameraSpace(x, y, camera) {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param result defines the ray where to store the picking ray\n     * @param camera defines the camera to use for the picking\n     * @returns the current scene\n     */\n    createPickingRayInCameraSpaceToRef(x, y, result, camera) {\n        throw _WarnImport(\"Ray\");\n    }\n    /** @internal */\n    get _pickingAvailable() {\n        return false;\n    }\n    /** Launch a ray to try to pick a mesh in the scene\n     * @param x position on screen\n     * @param y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns a PickingInfo\n     */\n    pick(x, y, predicate, fastCheck, camera, trianglePredicate) {\n        // Dummy info if picking as not been imported\n        return new PickingInfo();\n    }\n    /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\n     * @param x position on screen\n     * @param y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\n     */\n    pickWithBoundingInfo(x, y, predicate, fastCheck, camera) {\n        // Dummy info if picking as not been imported\n        return new PickingInfo();\n    }\n    /**\n     * Use the given ray to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\n     * irrespective of orientation.\n     * @param ray The ray to use to pick meshes\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns a PickingInfo\n     */\n    pickWithRay(ray, predicate, fastCheck, trianglePredicate) {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Launch a ray to try to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\n     * irrespective of orientation.\n     * @param x X position on screen\n     * @param y Y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns an array of PickingInfo\n     */\n    multiPick(x, y, predicate, camera, trianglePredicate) {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Launch a ray to try to pick a mesh in the scene\n     * @param ray Ray to use\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns an array of PickingInfo\n     */\n    multiPickWithRay(ray, predicate, trianglePredicate) {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Force the value of meshUnderPointer\n     * @param mesh defines the mesh to use\n     * @param pointerId optional pointer id when using more than one pointer\n     * @param pickResult optional pickingInfo data used to find mesh\n     */\n    setPointerOverMesh(mesh, pointerId, pickResult) {\n        this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);\n    }\n    /**\n     * Gets the mesh under the pointer\n     * @returns a Mesh or null if no mesh is under the pointer\n     */\n    getPointerOverMesh() {\n        return this._inputManager.getPointerOverMesh();\n    }\n    // Misc.\n    /** @internal */\n    _rebuildGeometries() {\n        for (const geometry of this.geometries) {\n            geometry._rebuild();\n        }\n        for (const mesh of this.meshes) {\n            mesh._rebuild();\n        }\n        if (this.postProcessManager) {\n            this.postProcessManager._rebuild();\n        }\n        for (const component of this._components) {\n            component.rebuild();\n        }\n        for (const system of this.particleSystems) {\n            system.rebuild();\n        }\n        if (this.spriteManagers) {\n            for (const spriteMgr of this.spriteManagers) {\n                spriteMgr.rebuild();\n            }\n        }\n    }\n    /** @internal */\n    _rebuildTextures() {\n        for (const texture of this.textures) {\n            texture._rebuild();\n        }\n        this.markAllMaterialsAsDirty(1);\n    }\n    // Tags\n    _getByTags(list, tagsQuery, forEach) {\n        if (tagsQuery === undefined) {\n            // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\n            return list;\n        }\n        const listByTags = [];\n        forEach =\n            forEach ||\n                ((item) => {\n                    return;\n                });\n        for (const i in list) {\n            const item = list[i];\n            if (Tags && Tags.MatchesQuery(item, tagsQuery)) {\n                listByTags.push(item);\n                forEach(item);\n            }\n        }\n        return listByTags;\n    }\n    /**\n     * Get a list of meshes by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Mesh\n     */\n    getMeshesByTags(tagsQuery, forEach) {\n        return this._getByTags(this.meshes, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of cameras by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Camera\n     */\n    getCamerasByTags(tagsQuery, forEach) {\n        return this._getByTags(this.cameras, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of lights by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Light\n     */\n    getLightsByTags(tagsQuery, forEach) {\n        return this._getByTags(this.lights, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of materials by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Material\n     */\n    getMaterialByTags(tagsQuery, forEach) {\n        return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));\n    }\n    /**\n     * Get a list of transform nodes by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of TransformNode\n     */\n    getTransformNodesByTags(tagsQuery, forEach) {\n        return this._getByTags(this.transformNodes, tagsQuery, forEach);\n    }\n    /**\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\n     * This allowed control for front to back rendering or reversly depending of the special needs.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n     */\n    setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n    }\n    /**\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n     */\n    setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\n    }\n    /**\n     * Gets the current auto clear configuration for one rendering group of the rendering\n     * manager.\n     * @param index the rendering group index to get the information for\n     * @returns The auto clear setup for the requested rendering group\n     */\n    getAutoClearDepthStencilSetup(index) {\n        return this._renderingManager.getAutoClearDepthStencilSetup(index);\n    }\n    /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\n    get blockMaterialDirtyMechanism() {\n        return this._blockMaterialDirtyMechanism;\n    }\n    set blockMaterialDirtyMechanism(value) {\n        if (this._blockMaterialDirtyMechanism === value) {\n            return;\n        }\n        this._blockMaterialDirtyMechanism = value;\n        if (!value) {\n            // Do a complete update\n            this.markAllMaterialsAsDirty(63);\n        }\n    }\n    /**\n     * Will flag all materials as dirty to trigger new shader compilation\n     * @param flag defines the flag used to specify which material part must be marked as dirty\n     * @param predicate If not null, it will be used to specify if a material has to be marked as dirty\n     */\n    markAllMaterialsAsDirty(flag, predicate) {\n        if (this._blockMaterialDirtyMechanism) {\n            return;\n        }\n        for (const material of this.materials) {\n            if (predicate && !predicate(material)) {\n                continue;\n            }\n            material.markAsDirty(flag);\n        }\n    }\n    /**\n     * @internal\n     */\n    _loadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n        const request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n        this._activeRequests.push(request);\n        request.onCompleteObservable.add((request) => {\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n        });\n        return request;\n    }\n    /**\n     * @internal\n     */\n    _loadFileAsync(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n        return new Promise((resolve, reject) => {\n            this._loadFile(fileOrUrl, (data) => {\n                resolve(data);\n            }, onProgress, useOfflineSupport, useArrayBuffer, (request, exception) => {\n                reject(exception);\n            }, onOpened);\n        });\n    }\n    /**\n     * @internal\n     */\n    _requestFile(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n        const request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n        this._activeRequests.push(request);\n        request.onCompleteObservable.add((request) => {\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n        });\n        return request;\n    }\n    /**\n     * @internal\n     */\n    _requestFileAsync(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n        return new Promise((resolve, reject) => {\n            this._requestFile(url, (data) => {\n                resolve(data);\n            }, onProgress, useOfflineSupport, useArrayBuffer, (error) => {\n                reject(error);\n            }, onOpened);\n        });\n    }\n    /**\n     * @internal\n     */\n    _readFile(file, onSuccess, onProgress, useArrayBuffer, onError) {\n        const request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n        this._activeRequests.push(request);\n        request.onCompleteObservable.add((request) => {\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n        });\n        return request;\n    }\n    /**\n     * @internal\n     */\n    _readFileAsync(file, onProgress, useArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            this._readFile(file, (data) => {\n                resolve(data);\n            }, onProgress, useArrayBuffer, (error) => {\n                reject(error);\n            });\n        });\n    }\n    /**\n     * This method gets the performance collector belonging to the scene, which is generally shared with the inspector.\n     * @returns the perf collector belonging to the scene.\n     */\n    getPerfCollector() {\n        throw _WarnImport(\"performanceViewerSceneExtension\");\n    }\n}\n/** The fog is deactivated */\nScene.FOGMODE_NONE = 0;\n/** The fog density is following an exponential function */\nScene.FOGMODE_EXP = 1;\n/** The fog density is following an exponential function faster than FOGMODE_EXP */\nScene.FOGMODE_EXP2 = 2;\n/** The fog density is following a linear function. */\nScene.FOGMODE_LINEAR = 3;\n/**\n * Gets or sets the minimum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n */\nScene.MinDeltaTime = 1.0;\n/**\n * Gets or sets the maximum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n */\nScene.MaxDeltaTime = 1000.0;\n/**\n * @internal\n */\nScene.prototype.setActiveCameraByID = function (id) {\n    return this.setActiveCameraById(id);\n};\nScene.prototype.getLastMaterialByID = function (id) {\n    return this.getLastMaterialById(id);\n};\nScene.prototype.getMaterialByID = function (id) {\n    return this.getMaterialById(id);\n};\nScene.prototype.getTextureByUniqueID = function (uniqueId) {\n    return this.getTextureByUniqueId(uniqueId);\n};\nScene.prototype.getCameraByID = function (id) {\n    return this.getCameraById(id);\n};\nScene.prototype.getCameraByUniqueID = function (uniqueId) {\n    return this.getCameraByUniqueId(uniqueId);\n};\nScene.prototype.getBoneByID = function (id) {\n    return this.getBoneById(id);\n};\nScene.prototype.getLightByID = function (id) {\n    return this.getLightById(id);\n};\nScene.prototype.getLightByUniqueID = function (uniqueId) {\n    return this.getLightByUniqueId(uniqueId);\n};\nScene.prototype.getParticleSystemByID = function (id) {\n    return this.getParticleSystemById(id);\n};\nScene.prototype.getGeometryByID = function (id) {\n    return this.getGeometryById(id);\n};\nScene.prototype.getMeshByID = function (id) {\n    return this.getMeshById(id);\n};\nScene.prototype.getMeshesByID = function (id) {\n    return this.getMeshesById(id);\n};\nScene.prototype.getTransformNodeByID = function (id) {\n    return this.getTransformNodeById(id);\n};\nScene.prototype.getTransformNodeByUniqueID = function (uniqueId) {\n    return this.getTransformNodeByUniqueId(uniqueId);\n};\nScene.prototype.getTransformNodesByID = function (id) {\n    return this.getTransformNodesById(id);\n};\nScene.prototype.getMeshByUniqueID = function (uniqueId) {\n    return this.getMeshByUniqueId(uniqueId);\n};\nScene.prototype.getLastMeshByID = function (id) {\n    return this.getLastMeshById(id);\n};\nScene.prototype.getLastEntryByID = function (id) {\n    return this.getLastEntryById(id);\n};\nScene.prototype.getNodeByID = function (id) {\n    return this.getNodeById(id);\n};\nScene.prototype.getLastSkeletonByID = function (id) {\n    return this.getLastSkeletonById(id);\n};\n//# sourceMappingURL=scene.js.map"],"names":["ScenePerformancePriority","Scene","static","scene","environmentTexture","this","_environmentTexture","value","markAllMaterialsAsDirty","imageProcessingConfiguration","_imageProcessingConfiguration","performancePriority","_performancePriority","BackwardCompatible","skipFrustumClipping","_renderingManager","maintainStateBetweenFrames","skipPointerMovePicking","autoClear","Intermediate","Aggressive","onScenePerformancePriorityChangedObservable","notifyObservers","forceWireframe","_forceWireframe","_skipFrustumClipping","forcePointsCloud","_forcePointsCloud","animationPropertiesOverride","_animationPropertiesOverride","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","beforeRender","_onBeforeRenderObserver","onBeforeRenderObservable","afterRender","_onAfterRenderObserver","onAfterRenderObservable","beforeCameraRender","_onBeforeCameraRenderObserver","onBeforeCameraRenderObservable","afterCameraRender","_onAfterCameraRenderObserver","onAfterCameraRenderObservable","unTranslatedPointer","_inputManager","DragMovementThreshold","LongPressDelay","DoubleClickDelay","ExclusiveDoubleClickMode","bindEyePosition","effect","variableName","isVector3","_a","eyePosition","_forcedViewPosition","_mirroredCameraPosition","activeCamera","globalPosition","devicePosition","invertNormal","useRightHandedSystem","x","y","z","setFloat3","setVector4","finalizeSceneUbo","ubo","getSceneUniformBuffer","updateFloat4","w","update","_useRightHandedSystem","setStepId","newStepId","_currentStepId","getStepId","getInternalStep","_currentInternalStep","fogEnabled","_fogEnabled","fogMode","_fogMode","prePass","prePassRenderer","defaultRT","enabled","shadowsEnabled","_shadowsEnabled","lightsEnabled","_lightsEnabled","activeCameras","_activeCameras","cameras","_unObserveActiveCameras","onActiveCamerasChanged","_activeCamera","onActiveCameraChanged","defaultMaterial","_defaultMaterial","DefaultMaterialFactory","texturesEnabled","_texturesEnabled","skeletonsEnabled","_skeletonsEnabled","collisionCoordinator","_collisionCoordinator","CollisionCoordinatorFactory","init","renderingManager","frustumPlanes","_frustumPlanes","_registerTransientComponents","_transientComponents","length","component","register","_addComponent","_components","push","serializableComponent","addFromContainer","serialize","_serializableComponents","_getComponent","name","constructor","engine","options","super","cameraToUseForPointers","_isScene","_blockEntityCollection","autoClearDepthAndStencil","clearColor","ambientColor","environmentIntensity","animationsEnabled","useConstantAnimationDeltaTime","constantlyUpdateMeshUnderPointer","hoverCursor","defaultCursor","doNotHandleCursors","preventDefaultOnPointerDown","preventDefaultOnPointerUp","metadata","reservedDataStore","disableOfflineSupportExceptionRules","Array","onAfterRenderCameraObservable","onBeforeAnimationsObservable","onAfterAnimationsObservable","onBeforeDrawPhaseObservable","onAfterDrawPhaseObservable","onReadyObservable","onBeforeActiveMeshesEvaluationObservable","onAfterActiveMeshesEvaluationObservable","onBeforeParticlesRenderingObservable","onAfterParticlesRenderingObservable","onDataLoadedObservable","onNewCameraAddedObservable","onCameraRemovedObservable","onNewLightAddedObservable","onLightRemovedObservable","onNewGeometryAddedObservable","onGeometryRemovedObservable","onNewTransformNodeAddedObservable","onTransformNodeRemovedObservable","onNewMeshAddedObservable","onMeshRemovedObservable","onNewSkeletonAddedObservable","onSkeletonRemovedObservable","onNewMaterialAddedObservable","onNewMultiMaterialAddedObservable","onMaterialRemovedObservable","onMultiMaterialRemovedObservable","onNewTextureAddedObservable","onTextureRemovedObservable","onBeforeRenderTargetsRenderObservable","onAfterRenderTargetsRenderObservable","onBeforeStepObservable","onAfterStepObservable","onBeforeRenderingGroupObservable","onAfterRenderingGroupObservable","onMeshImportedObservable","onAnimationFileImportedObservable","_registeredForLateAnimationBindings","skipPointerDownPicking","skipPointerUpPicking","onPrePointerObservable","onPointerObservable","onPreKeyboardObservable","onKeyboardObservable","_timeAccumulator","FOGMODE_NONE","fogColor","fogDensity","fogStart","fogEnd","needsPreviousWorldMatrices","physicsEnabled","particlesEnabled","spritesEnabled","lensFlaresEnabled","collisionsEnabled","gravity","postProcessesEnabled","renderTargetsEnabled","dumpNextRenderTargets","customRenderTargets","importedMeshesFiles","probesEnabled","_meshesForIntersections","proceduralTexturesEnabled","_totalVertices","_activeIndices","_activeParticles","_activeBones","_animationTime","animationTimeScale","_renderId","_frameId","_executeWhenReadyTimeoutId","_intermediateRendering","_defaultFrameBufferCleared","_viewUpdateFlag","_projectionUpdateFlag","_toBeDisposed","_activeRequests","_pendingData","_isDisposed","dispatchAllSubMeshesOfActiveMeshes","_activeMeshes","_processedMaterials","_renderTargets","_materialsRenderTargets","_activeParticleSystems","_activeSkeletons","_softwareSkinnedMeshes","_activeAnimatables","_transformMatrix","requireLightSorting","_beforeCameraUpdateStage","_beforeClearStage","_beforeRenderTargetClearStage","_gatherRenderTargetsStage","_gatherActiveCameraRenderTargetsStage","_isReadyForMeshStage","_beforeEvaluateActiveMeshStage","_evaluateSubMeshStage","_preActiveMeshStage","_cameraDrawRenderTargetStage","_beforeCameraDrawStage","_beforeRenderTargetDrawStage","_beforeRenderingGroupDrawStage","_beforeRenderingMeshStage","_afterRenderingMeshStage","_afterRenderingGroupDrawStage","_afterCameraDrawStage","_afterCameraPostProcessStage","_afterRenderTargetDrawStage","_afterRenderTargetPostProcessStage","_afterRenderStage","_pointerMoveStage","_pointerDownStage","_pointerUpStage","_geometriesByUniqueId","_defaultMeshCandidates","data","_defaultSubMeshCandidates","_preventFreeActiveMeshesAndRenderingGroups","_activeMeshesFrozen","_activeMeshesFrozenButKeepClipping","_skipEvaluateActiveMeshesCompletely","_allowPostProcessClearColor","getDeterministicFrameTime","_engine","getTimeStep","_registeredActions","_blockMaterialDirtyMechanism","_perfCollector","fullOptions","Object","assign","useGeometryUniqueIdsMap","useMaterialMeshMap","useClonedMeshMap","virtual","_virtualScenes","scenes","_uid","postProcessManager","attachControl","_createUbo","setDefaultCandidateProviders","onNewSceneAddedObservable","getClassName","_getDefaultMeshCandidates","meshes","_getDefaultSubMeshCandidates","mesh","subMeshes","getActiveMeshCandidates","bind","getActiveSubMeshCandidates","getIntersectingSubMeshCandidates","getCollidingSubMeshCandidates","meshUnderPointer","pointerX","pointerY","getCachedMaterial","_cachedMaterial","getCachedEffect","_cachedEffect","getCachedVisibility","_cachedVisibility","isCachedMaterialInvalid","material","visibility","getEngine","getTotalVertices","current","totalVerticesPerfCounter","getActiveIndices","totalActiveIndicesPerfCounter","getActiveParticles","activeParticlesPerfCounter","getActiveBones","activeBonesPerfCounter","getActiveMeshes","getAnimationRatio","undefined","_animationRatio","getRenderId","getFrameId","incrementRenderId","setSceneUniformBuffer","createSceneUniformBuffer","simulatePointerMove","pickResult","pointerEventInit","simulatePointerDown","simulatePointerUp","doubleTap","isPointerCaptured","pointerId","attachUp","attachDown","attachMove","detachControl","isReady","checkRenderTargets","_b","_c","index","currentRenderPassId","renderPassId","reset","hardwareInstancedRendering","hasThinInstances","getCaps","instancedArrays","instances","step","action","mat","_storeEffectOnSubMeshes","subMesh","getMaterial","hasRenderTargetTextures","getRenderTargetTextures","indexOf","concatWithNoDuplicate","isReadyForRendering","geometries","delayLoadState","camera","particleSystem","particleSystems","layers","layer","areAllEffectsReady","resetCachedMaterial","registerBeforeRender","func","unregisterBeforeRender","removeCallback","registerAfterRender","unregisterAfterRender","_executeOnceBeforeRender","execFunc","setTimeout","executeOnceBeforeRender","timeout","addPendingData","removePendingData","wasLoading","isLoading","splice","getWaitingItemsCount","executeWhenReady","addOnce","_checkIsReady","whenReadyAsync","Promise","resolve","clear","animatables","resetLastAnimationTimeFrame","_animationTimeLast","getViewMatrix","_viewMatrix","getProjectionMatrix","_projectionMatrix","getTransformMatrix","setTransformMatrix","viewL","projectionL","viewR","projectionR","_multiviewSceneUbo","dispose","updateFlag","multiplyToRef","useUbo","_updateMultiviewUbo","_sceneUbo","updateMatrix","sceneUbo","addUniform","getUniqueId","UniqueId","addMesh","newMesh","recursive","_resyncLightSources","parent","_addToSceneRootNodes","getChildMeshes","forEach","m","removeMesh","toRemove","pop","_removeFromSceneRootNodes","_invalidateMesh","addTransformNode","newTransformNode","getScene","_indexInSceneTransformNodesArray","transformNodes","removeTransformNode","lastNode","removeSkeleton","skeletons","_executeActiveContainerCleanup","removeMorphTargetManager","morphTargetManagers","removeLight","lights","_removeLightSource","sortLightsByPriority","removeCamera","index2","removeParticleSystem","removeAnimation","animations","stopAnimation","target","animationName","targetMask","removeAnimationGroup","animationGroups","removeMultiMaterial","multiMaterials","removeMaterial","_indexInSceneMaterialArray","materials","lastMaterial","removeActionManager","actionManagers","removeTexture","textures","addLight","newLight","lightSources","sort","addCamera","newCamera","addSkeleton","newSkeleton","addParticleSystem","newParticleSystem","addAnimation","newAnimation","addAnimationGroup","newAnimationGroup","addMultiMaterial","newMultiMaterial","addMaterial","newMaterial","addMorphTargetManager","newMorphTargetManager","addGeometry","newGeometry","uniqueId","addActionManager","newActionManager","addTexture","newTexture","switchActiveCamera","getInputElement","setActiveCameraById","id","getCameraById","setActiveCameraByName","getCameraByName","getAnimationGroupByName","_getMaterial","allowMultiMaterials","predicate","getMaterialByUniqueID","getMaterialById","getMaterialByName","getLastMaterialById","getTextureByUniqueId","getTextureByName","getCameraByUniqueId","getBoneById","skeletonIndex","skeleton","boneIndex","bones","getBoneByName","getLightByName","getLightById","getLightByUniqueId","getParticleSystemById","getGeometryById","_getGeometryByUniqueId","pushGeometry","geometry","force","removeGeometry","lastGeometry","getGeometries","getMeshById","getMeshesById","filter","getTransformNodeById","getTransformNodeByUniqueId","getTransformNodesById","getMeshByUniqueId","getLastMeshById","getLastEntryById","getNodeById","transformNode","light","bone","getNodeByName","getMeshByName","getTransformNodeByName","getLastSkeletonById","getSkeletonByUniqueId","getSkeletonById","getSkeletonByName","getMorphTargetManagerById","getMorphTargetById","managerIndex","morphTargetManager","numTargets","getTarget","getMorphTargetByName","getPostProcessByName","postProcessIndex","postProcesses","postProcess","isActiveMesh","uid","addExternalData","key","_externalData","getExternalData","get","getOrAddExternalDataWithFactory","factory","getOrAddWithFactory","removeExternalData","_evaluateSubMesh","initialMesh","forcePush","isInFrustum","dispatch","freeProcessedMaterials","blockfreeActiveMeshesAndRenderingGroups","freeActiveMeshes","freeRenderingGroups","i","texture","renderList","_isInIntermediateRendering","freezeActiveMeshes","skipEvaluateActiveMeshes","onSuccess","onError","freezeMeshes","keepFrustumCulling","updateTransformMatrix","_evaluateActiveMeshes","_freeze","unfreezeActiveMeshes","_internalAbstractMeshDataInfo","_isActive","_unFreeze","container","snapshotRendering","snapshotRenderingMode","len","computeWorldMatrix","psLength","animate","resetSprites","_currentLODIsUpToDate","isBlocked","addCount","isEnabled","scaling","hasAZeroComponent","actionManager","hasSpecificTriggers2","pushNoDuplicate","meshToRender","customLODSelector","getLOD","_currentLOD","billboardMode","_preActivate","isVisible","layerMask","alwaysSelectAsActiveMesh","_activate","isAnInstance","_actAsRegularMesh","_onlyForInstances","_activeMesh","_postActivate","particleIndex","isStarted","emitter","position","dispatchParticles","sourceMesh","prepare","computeBonesUsingShaders","hasInstances","_renderingMultiview","leftCamera","_rigCameras","rightCamera","_bindFrameBuffer","_multiviewTexture","outputRenderTarget","_currentFrameBufferIsDefaultFrameBuffer","restoreDefaultFramebuffer","_clearFrameBuffer","rtt","onClearObservable","hasObservers","skipInitialClear","_cleared","_clear","_renderForCamera","rigParent","bindFrameBuffer","_skipRendering","Error","setViewport","viewport","softwareSkinnedMeshIndex","applySkeleton","isRenderTarget","needRebind","renderIndex","renderTarget","_shouldRender","hasSpecialRenderTargetCamera","render","_prepareFrame","_finalizeFrame","isIntermediate","_processSubCameras","cameraRigMode","_createMultiviewUbo","_useMultiviewToSingleView","_renderMultiviewToSingleView","_checkIntersections","actionIndex","actions","trigger","parameters","getTriggerParameter","otherMesh","areIntersecting","intersectsMesh","usePreciseIntersection","currentIntersectionInProgress","_intersectionsInProgress","_executeCurrent","hasSpecificTrigger","parameter","parameterMesh","_advancePhysicsEngineStep","_animate","isDeterministicLockStep","deltaTime","Math","max","MinDeltaTime","min","getDeltaTime","MaxDeltaTime","defaultFrameTime","defaultFPS","stepsTaken","maxSubSteps","getLockstepMaxSteps","internalSteps","floor","_checkCameraRenderTarget","isRigCamera","rigCameras","resetDrawCache","passId","updateCameras","ignoreAnimations","isDisposed","fetchNewFrame","processTrigger","cameraIndex","currentActiveCamera","customIndex","freezeMaterials","freeze","unfreezeMaterials","unfreeze","stopAllAnimations","activeRequests","slice","request","abort","e","console","error","_disposeList","item","wipeCaches","items","itemsCopy","clearCachedVertexData","meshIndex","clearCachedData","cleanCachedTextureBuffer","baseTexture","_buffer","getWorldExtends","filterPredicate","Number","MAX_VALUE","infiniteDistance","boundingInfo","getBoundingInfo","minBox","boundingBox","minimumWorld","maxBox","maximumWorld","createPickingRay","world","cameraViewSpace","createPickingRayToRef","result","enableDistantPicking","createPickingRayInCameraSpace","createPickingRayInCameraSpaceToRef","_pickingAvailable","pick","fastCheck","trianglePredicate","pickWithBoundingInfo","pickWithRay","ray","multiPick","multiPickWithRay","setPointerOverMesh","getPointerOverMesh","_rebuildGeometries","_rebuild","rebuild","system","spriteManagers","spriteMgr","_rebuildTextures","_getByTags","list","tagsQuery","listByTags","getMeshesByTags","getCamerasByTags","getLightsByTags","getMaterialByTags","concat","getTransformNodesByTags","setRenderingOrder","renderingGroupId","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","setRenderingAutoClearDepthStencil","autoClearDepthStencil","depth","stencil","getAutoClearDepthStencilSetup","blockMaterialDirtyMechanism","flag","markAsDirty","_loadFile","fileOrUrl","onProgress","useOfflineSupport","useArrayBuffer","onOpened","offlineProvider","onCompleteObservable","_loadFileAsync","reject","exception","_requestFile","url","_requestFileAsync","_readFile","file","_readFileAsync","getPerfCollector","FOGMODE_EXP","FOGMODE_EXP2","FOGMODE_LINEAR","prototype","setActiveCameraByID","getLastMaterialByID","getMaterialByID","getTextureByUniqueID","getCameraByID","getCameraByUniqueID","getBoneByID","getLightByID","getLightByUniqueID","getParticleSystemByID","getGeometryByID","getMeshByID","getMeshesByID","getTransformNodeByID","getTransformNodeByUniqueID","getTransformNodesByID","getMeshByUniqueID","getLastMeshByID","getLastEntryByID","getNodeByID","getLastSkeletonByID"],"sourceRoot":""}