{"version":3,"file":"87a06baf-9960d685d5208673f5c7.js","mappings":"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","sources":["webpack://code-cave/./node_modules/@babylonjs/core/Meshes/mesh.js"],"sourcesContent":["import { Observable } from \"../Misc/observable.js\";\nimport { Tools, AsyncLoop } from \"../Misc/tools.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler } from \"../Misc/coroutine.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { ScenePerformancePriority } from \"../scene.js\";\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"./mesh.vertexData.js\";\nimport { Geometry } from \"./geometry.js\";\nimport { AbstractMesh } from \"./abstractMesh.js\";\nimport { SubMesh } from \"./subMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags.js\";\n\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { GetClass, RegisterClass } from \"../Misc/typeStore.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { MeshLODLevel } from \"./meshLODLevel.js\";\n/**\n * @internal\n **/\nexport class _CreationDataStorage {\n}\n/**\n * @internal\n **/\nclass _InstanceDataStorage {\n    constructor() {\n        this.visibleInstances = {};\n        this.batchCache = new _InstancesBatch();\n        this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch();\n        this.instancesBufferSize = 32 * 16 * 4; // let's start with a maximum of 32 instances\n    }\n}\n/**\n * @internal\n **/\nexport class _InstancesBatch {\n    constructor() {\n        this.mustReturn = false;\n        this.visibleInstances = new Array();\n        this.renderSelf = new Array();\n        this.hardwareInstancedRendering = new Array();\n    }\n}\n/**\n * @internal\n **/\nclass _ThinInstanceDataStorage {\n    constructor() {\n        this.instancesCount = 0;\n        this.matrixBuffer = null;\n        this.previousMatrixBuffer = null;\n        this.matrixBufferSize = 32 * 16; // let's start with a maximum of 32 thin instances\n        this.matrixData = null;\n        this.boundingVectors = [];\n        this.worldMatrices = null;\n    }\n}\n/**\n * @internal\n **/\nclass _InternalMeshDataInfo {\n    constructor() {\n        this._areNormalsFrozen = false; // Will be used by ribbons mainly\n        // Will be used to save a source mesh reference, If any\n        this._source = null;\n        // Will be used to for fast cloned mesh lookup\n        this.meshMap = null;\n        this._preActivateId = -1;\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        this._LODLevels = new Array();\n        /** Alternative definition of LOD level, using screen coverage instead of distance */\n        this._useLODScreenCoverage = false;\n        this._effectiveMaterial = null;\n        this._forcedInstanceCount = 0;\n        this._overrideRenderingFillMode = null;\n    }\n}\n/**\n * Class used to represent renderable models\n */\nexport class Mesh extends AbstractMesh {\n    /**\n     * Gets the default side orientation.\n     * @param orientation the orientation to value to attempt to get\n     * @returns the default orientation\n     * @internal\n     */\n    static _GetDefaultSideOrientation(orientation) {\n        return orientation || Mesh.FRONTSIDE; // works as Mesh.FRONTSIDE is 0\n    }\n    /**\n     * Determines if the LOD levels are intended to be calculated using screen coverage (surface area ratio) instead of distance.\n     */\n    get useLODScreenCoverage() {\n        return this._internalMeshDataInfo._useLODScreenCoverage;\n    }\n    set useLODScreenCoverage(value) {\n        this._internalMeshDataInfo._useLODScreenCoverage = value;\n        this._sortLODLevels();\n    }\n    get computeBonesUsingShaders() {\n        return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\n    }\n    set computeBonesUsingShaders(value) {\n        if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\n            return;\n        }\n        if (value && this._internalMeshDataInfo._sourcePositions) {\n            // switch from software to GPU computation: we need to reset the vertex and normal buffers that have been updated by the software process\n            this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);\n            if (this._internalMeshDataInfo._sourceNormals) {\n                this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);\n            }\n            this._internalMeshDataInfo._sourcePositions = null;\n            this._internalMeshDataInfo._sourceNormals = null;\n        }\n        this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\n        this._markSubMeshesAsAttributesDirty();\n    }\n    /**\n     * An event triggered before rendering the mesh\n     */\n    get onBeforeRenderObservable() {\n        if (!this._internalMeshDataInfo._onBeforeRenderObservable) {\n            this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();\n        }\n        return this._internalMeshDataInfo._onBeforeRenderObservable;\n    }\n    /**\n     * An event triggered before binding the mesh\n     */\n    get onBeforeBindObservable() {\n        if (!this._internalMeshDataInfo._onBeforeBindObservable) {\n            this._internalMeshDataInfo._onBeforeBindObservable = new Observable();\n        }\n        return this._internalMeshDataInfo._onBeforeBindObservable;\n    }\n    /**\n     * An event triggered after rendering the mesh\n     */\n    get onAfterRenderObservable() {\n        if (!this._internalMeshDataInfo._onAfterRenderObservable) {\n            this._internalMeshDataInfo._onAfterRenderObservable = new Observable();\n        }\n        return this._internalMeshDataInfo._onAfterRenderObservable;\n    }\n    /**\n     * An event triggeredbetween rendering pass when using separateCullingPass = true\n     */\n    get onBetweenPassObservable() {\n        if (!this._internalMeshDataInfo._onBetweenPassObservable) {\n            this._internalMeshDataInfo._onBetweenPassObservable = new Observable();\n        }\n        return this._internalMeshDataInfo._onBetweenPassObservable;\n    }\n    /**\n     * An event triggered before drawing the mesh\n     */\n    get onBeforeDrawObservable() {\n        if (!this._internalMeshDataInfo._onBeforeDrawObservable) {\n            this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();\n        }\n        return this._internalMeshDataInfo._onBeforeDrawObservable;\n    }\n    /**\n     * Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead\n     */\n    set onBeforeDraw(callback) {\n        if (this._onBeforeDrawObserver) {\n            this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);\n        }\n        this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);\n    }\n    get hasInstances() {\n        return this.instances.length > 0;\n    }\n    get hasThinInstances() {\n        var _a;\n        return ((_a = this._thinInstanceDataStorage.instancesCount) !== null && _a !== void 0 ? _a : 0) > 0;\n    }\n    /**\n     * Gets or sets the forced number of instances to display.\n     * If 0 (default value), the number of instances is not forced and depends on the draw type\n     * (regular / instance / thin instances mesh)\n     */\n    get forcedInstanceCount() {\n        return this._internalMeshDataInfo._forcedInstanceCount;\n    }\n    set forcedInstanceCount(count) {\n        this._internalMeshDataInfo._forcedInstanceCount = count;\n    }\n    /**\n     * Use this property to override the Material's fillMode value\n     */\n    get overrideRenderingFillMode() {\n        return this._internalMeshDataInfo._overrideRenderingFillMode;\n    }\n    set overrideRenderingFillMode(fillMode) {\n        this._internalMeshDataInfo._overrideRenderingFillMode = fillMode;\n    }\n    /**\n     * Gets the source mesh (the one used to clone this one from)\n     */\n    get source() {\n        return this._internalMeshDataInfo._source;\n    }\n    /**\n     * Gets the list of clones of this mesh\n     * The scene must have been constructed with useClonedMeshMap=true for this to work!\n     * Note that useClonedMeshMap=true is the default setting\n     */\n    get cloneMeshMap() {\n        return this._internalMeshDataInfo.meshMap;\n    }\n    /**\n     * Gets or sets a boolean indicating that this mesh does not use index buffer\n     */\n    get isUnIndexed() {\n        return this._unIndexed;\n    }\n    set isUnIndexed(value) {\n        if (this._unIndexed !== value) {\n            this._unIndexed = value;\n            this._markSubMeshesAsAttributesDirty();\n        }\n    }\n    /** Gets the array buffer used to store the instanced buffer used for instances' world matrices */\n    get worldMatrixInstancedBuffer() {\n        return this._instanceDataStorage.instancesData;\n    }\n    /** Gets the array buffer used to store the instanced buffer used for instances' previous world matrices */\n    get previousWorldMatrixInstancedBuffer() {\n        return this._instanceDataStorage.instancesPreviousData;\n    }\n    /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n    get manualUpdateOfWorldMatrixInstancedBuffer() {\n        return this._instanceDataStorage.manualUpdate;\n    }\n    set manualUpdateOfWorldMatrixInstancedBuffer(value) {\n        this._instanceDataStorage.manualUpdate = value;\n    }\n    /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n    get manualUpdateOfPreviousWorldMatrixInstancedBuffer() {\n        return this._instanceDataStorage.previousManualUpdate;\n    }\n    set manualUpdateOfPreviousWorldMatrixInstancedBuffer(value) {\n        this._instanceDataStorage.previousManualUpdate = value;\n    }\n    /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices must be performed in all cases (and notably even in frozen mode) */\n    get forceWorldMatrixInstancedBufferUpdate() {\n        return this._instanceDataStorage.forceMatrixUpdates;\n    }\n    set forceWorldMatrixInstancedBufferUpdate(value) {\n        this._instanceDataStorage.forceMatrixUpdates = value;\n    }\n    /**\n     * @constructor\n     * @param name The value used by scene.getMeshByName() to do a lookup.\n     * @param scene The scene to add this mesh to.\n     * @param parent The parent of this mesh, if it has one\n     * @param source An optional Mesh from which geometry is shared, cloned.\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\n     *                  When false, achieved by calling a clone(), also passing False.\n     *                  This will make creation of children, recursive.\n     * @param clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.\n     */\n    constructor(name, scene = null, parent = null, source = null, doNotCloneChildren, clonePhysicsImpostor = true) {\n        super(name, scene);\n        // Internal data\n        this._internalMeshDataInfo = new _InternalMeshDataInfo();\n        // Members\n        /**\n         * Gets the delay loading state of the mesh (when delay loading is turned on)\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/incrementalLoading\n         */\n        this.delayLoadState = 0;\n        /**\n         * Gets the list of instances created from this mesh\n         * it is not supposed to be modified manually.\n         * Note also that the order of the InstancedMesh wihin the array is not significant and might change.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n         */\n        this.instances = new Array();\n        // Private\n        /** @internal */\n        this._creationDataStorage = null;\n        /** @internal */\n        this._geometry = null;\n        /** @internal */\n        this._instanceDataStorage = new _InstanceDataStorage();\n        /** @internal */\n        this._thinInstanceDataStorage = new _ThinInstanceDataStorage();\n        /** @internal */\n        this._shouldGenerateFlatShading = false;\n        // Use by builder only to know what orientation were the mesh build in.\n        /** @internal */\n        this._originalBuilderSideOrientation = Mesh.DEFAULTSIDE;\n        /**\n         * Use this property to change the original side orientation defined at construction time\n         */\n        this.overrideMaterialSideOrientation = null;\n        /**\n         * Gets or sets a boolean indicating whether to render ignoring the active camera's max z setting. (false by default)\n         * You should not mix meshes that have this property set to true with meshes that have it set to false if they all write\n         * to the depth buffer, because the z-values are not comparable in the two cases and you will get rendering artifacts if you do.\n         * You can set the property to true for meshes that do not write to the depth buffer, or set the same value (either false or true) otherwise.\n         * Note this will reduce performance when set to true.\n         */\n        this.ignoreCameraMaxZ = false;\n        scene = this.getScene();\n        this._onBeforeDraw = (isInstance, world, effectiveMaterial) => {\n            if (isInstance && effectiveMaterial) {\n                if (this._uniformBuffer) {\n                    this.transferToEffect(world);\n                }\n                else {\n                    effectiveMaterial.bindOnlyWorldMatrix(world);\n                }\n            }\n        };\n        if (source) {\n            // Geometry\n            if (source._geometry) {\n                source._geometry.applyToMesh(this);\n            }\n            // Deep copy\n            DeepCopier.DeepCopy(source, this, [\n                \"name\",\n                \"material\",\n                \"skeleton\",\n                \"instances\",\n                \"parent\",\n                \"uniqueId\",\n                \"source\",\n                \"metadata\",\n                \"morphTargetManager\",\n                \"hasInstances\",\n                \"worldMatrixInstancedBuffer\",\n                \"previousWorldMatrixInstancedBuffer\",\n                \"hasLODLevels\",\n                \"geometry\",\n                \"isBlocked\",\n                \"areNormalsFrozen\",\n                \"facetNb\",\n                \"isFacetDataEnabled\",\n                \"lightSources\",\n                \"useBones\",\n                \"isAnInstance\",\n                \"collider\",\n                \"edgesRenderer\",\n                \"forward\",\n                \"up\",\n                \"right\",\n                \"absolutePosition\",\n                \"absoluteScaling\",\n                \"absoluteRotationQuaternion\",\n                \"isWorldMatrixFrozen\",\n                \"nonUniformScaling\",\n                \"behaviors\",\n                \"worldMatrixFromCache\",\n                \"hasThinInstances\",\n                \"cloneMeshMap\",\n                \"hasBoundingInfo\",\n            ], [\"_poseMatrix\"]);\n            // Source mesh\n            this._internalMeshDataInfo._source = source;\n            if (scene.useClonedMeshMap) {\n                if (!source._internalMeshDataInfo.meshMap) {\n                    source._internalMeshDataInfo.meshMap = {};\n                }\n                source._internalMeshDataInfo.meshMap[this.uniqueId] = this;\n            }\n            // Construction Params\n            // Clone parameters allowing mesh to be updated in case of parametric shapes.\n            this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;\n            this._creationDataStorage = source._creationDataStorage;\n            // Animation ranges\n            if (source._ranges) {\n                const ranges = source._ranges;\n                for (const name in ranges) {\n                    if (!Object.prototype.hasOwnProperty.call(ranges, name)) {\n                        continue;\n                    }\n                    if (!ranges[name]) {\n                        continue;\n                    }\n                    this.createAnimationRange(name, ranges[name].from, ranges[name].to);\n                }\n            }\n            // Metadata\n            if (source.metadata && source.metadata.clone) {\n                this.metadata = source.metadata.clone();\n            }\n            else {\n                this.metadata = source.metadata;\n            }\n            this._internalMetadata = source._internalMetadata;\n            // Tags\n            if (Tags && Tags.HasTags(source)) {\n                Tags.AddTagsTo(this, Tags.GetTags(source, true));\n            }\n            // Enabled. We shouldn't need to check the source's ancestors, as this mesh\n            // will have the same ones.\n            this.setEnabled(source.isEnabled(false));\n            // Parent\n            this.parent = source.parent;\n            // Pivot\n            this.setPivotMatrix(source.getPivotMatrix());\n            this.id = name + \".\" + source.id;\n            // Material\n            this.material = source.material;\n            if (!doNotCloneChildren) {\n                // Children\n                const directDescendants = source.getDescendants(true);\n                for (let index = 0; index < directDescendants.length; index++) {\n                    const child = directDescendants[index];\n                    if (child.clone) {\n                        child.clone(name + \".\" + child.name, this);\n                    }\n                }\n            }\n            // Morphs\n            if (source.morphTargetManager) {\n                this.morphTargetManager = source.morphTargetManager;\n            }\n            // Physics clone\n            if (scene.getPhysicsEngine) {\n                const physicsEngine = scene.getPhysicsEngine();\n                if (clonePhysicsImpostor && physicsEngine) {\n                    if (physicsEngine.getPluginVersion() === 1) {\n                        const impostor = physicsEngine.getImpostorForPhysicsObject(source);\n                        if (impostor) {\n                            this.physicsImpostor = impostor.clone(this);\n                        }\n                    }\n                    else if (physicsEngine.getPluginVersion() === 2) {\n                        if (source.physicsBody) {\n                            source.physicsBody.clone(this);\n                        }\n                    }\n                }\n            }\n            // Particles\n            for (let index = 0; index < scene.particleSystems.length; index++) {\n                const system = scene.particleSystems[index];\n                if (system.emitter === source) {\n                    system.clone(system.name, this);\n                }\n            }\n            // Skeleton\n            this.skeleton = source.skeleton;\n            this.refreshBoundingInfo(true, true);\n            this.computeWorldMatrix(true);\n        }\n        // Parent\n        if (parent !== null) {\n            this.parent = parent;\n        }\n        this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays;\n        this._internalMeshDataInfo._onMeshReadyObserverAdded = (observer) => {\n            // only notify once! then unregister the observer\n            observer.unregisterOnNextCall = true;\n            if (this.isReady(true)) {\n                this.onMeshReadyObservable.notifyObservers(this);\n            }\n            else {\n                if (!this._internalMeshDataInfo._checkReadinessObserver) {\n                    this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add(() => {\n                        // check for complete readiness\n                        if (this.isReady(true)) {\n                            this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);\n                            this._internalMeshDataInfo._checkReadinessObserver = null;\n                            this.onMeshReadyObservable.notifyObservers(this);\n                        }\n                    });\n                }\n            }\n        };\n        this.onMeshReadyObservable = new Observable(this._internalMeshDataInfo._onMeshReadyObserverAdded);\n        if (source) {\n            source.onClonedObservable.notifyObservers(this);\n        }\n    }\n    instantiateHierarchy(newParent = null, options, onNewNodeCreated) {\n        const instance = this.getTotalVertices() === 0 || (options && options.doNotInstantiate && (options.doNotInstantiate === true || options.doNotInstantiate(this)))\n            ? this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true)\n            : this.createInstance(\"instance of \" + (this.name || this.id));\n        instance.parent = newParent || this.parent;\n        instance.position = this.position.clone();\n        instance.scaling = this.scaling.clone();\n        if (this.rotationQuaternion) {\n            instance.rotationQuaternion = this.rotationQuaternion.clone();\n        }\n        else {\n            instance.rotation = this.rotation.clone();\n        }\n        if (onNewNodeCreated) {\n            onNewNodeCreated(this, instance);\n        }\n        for (const child of this.getChildTransformNodes(true)) {\n            // instancedMesh should have a different sourced mesh\n            if (child.getClassName() === \"InstancedMesh\" && instance.getClassName() === \"Mesh\" && child.sourceMesh === this) {\n                child.instantiateHierarchy(instance, {\n                    doNotInstantiate: (options && options.doNotInstantiate) || false,\n                    newSourcedMesh: instance,\n                }, onNewNodeCreated);\n            }\n            else {\n                child.instantiateHierarchy(instance, options, onNewNodeCreated);\n            }\n        }\n        return instance;\n    }\n    /**\n     * Gets the class name\n     * @returns the string \"Mesh\".\n     */\n    getClassName() {\n        return \"Mesh\";\n    }\n    /** @internal */\n    get _isMesh() {\n        return true;\n    }\n    /**\n     * Returns a description of this mesh\n     * @param fullDetails define if full details about this mesh must be used\n     * @returns a descriptive string representing this mesh\n     */\n    toString(fullDetails) {\n        let ret = super.toString(fullDetails);\n        ret += \", n vertices: \" + this.getTotalVertices();\n        ret += \", parent: \" + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : \"NONE\");\n        if (this.animations) {\n            for (let i = 0; i < this.animations.length; i++) {\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n            }\n        }\n        if (fullDetails) {\n            if (this._geometry) {\n                const ib = this.getIndices();\n                const vb = this.getVerticesData(VertexBuffer.PositionKind);\n                if (vb && ib) {\n                    ret += \", flat shading: \" + (vb.length / 3 === ib.length ? \"YES\" : \"NO\");\n                }\n            }\n            else {\n                ret += \", flat shading: UNKNOWN\";\n            }\n        }\n        return ret;\n    }\n    /** @internal */\n    _unBindEffect() {\n        super._unBindEffect();\n        for (const instance of this.instances) {\n            instance._unBindEffect();\n        }\n    }\n    /**\n     * Gets a boolean indicating if this mesh has LOD\n     */\n    get hasLODLevels() {\n        return this._internalMeshDataInfo._LODLevels.length > 0;\n    }\n    /**\n     * Gets the list of MeshLODLevel associated with the current mesh\n     * @returns an array of MeshLODLevel\n     */\n    getLODLevels() {\n        return this._internalMeshDataInfo._LODLevels;\n    }\n    _sortLODLevels() {\n        const sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;\n        this._internalMeshDataInfo._LODLevels.sort((a, b) => {\n            if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {\n                return sortingOrderFactor;\n            }\n            if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {\n                return -sortingOrderFactor;\n            }\n            return 0;\n        });\n    }\n    /**\n     * Add a mesh as LOD level triggered at the given distance.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n     * @param distanceOrScreenCoverage Either distance from the center of the object to show this level or the screen coverage if `useScreenCoverage` is set to `true`.\n     * If screen coverage, value is a fraction of the screen's total surface, between 0 and 1.\n     * Example Playground for distance https://playground.babylonjs.com/#QE7KM#197\n     * Example Playground for screen coverage https://playground.babylonjs.com/#QE7KM#196\n     * @param mesh The mesh to be added as LOD level (can be null)\n     * @returns This mesh (for chaining)\n     */\n    addLODLevel(distanceOrScreenCoverage, mesh) {\n        if (mesh && mesh._masterMesh) {\n            Logger.Warn(\"You cannot use a mesh as LOD level twice\");\n            return this;\n        }\n        const level = new MeshLODLevel(distanceOrScreenCoverage, mesh);\n        this._internalMeshDataInfo._LODLevels.push(level);\n        if (mesh) {\n            mesh._masterMesh = this;\n        }\n        this._sortLODLevels();\n        return this;\n    }\n    /**\n     * Returns the LOD level mesh at the passed distance or null if not found.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n     * @param distance The distance from the center of the object to show this level\n     * @returns a Mesh or `null`\n     */\n    getLODLevelAtDistance(distance) {\n        const internalDataInfo = this._internalMeshDataInfo;\n        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\n            const level = internalDataInfo._LODLevels[index];\n            if (level.distanceOrScreenCoverage === distance) {\n                return level.mesh;\n            }\n        }\n        return null;\n    }\n    /**\n     * Remove a mesh from the LOD array\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n     * @param mesh defines the mesh to be removed\n     * @returns This mesh (for chaining)\n     */\n    removeLODLevel(mesh) {\n        const internalDataInfo = this._internalMeshDataInfo;\n        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\n            if (internalDataInfo._LODLevels[index].mesh === mesh) {\n                internalDataInfo._LODLevels.splice(index, 1);\n                if (mesh) {\n                    mesh._masterMesh = null;\n                }\n            }\n        }\n        this._sortLODLevels();\n        return this;\n    }\n    /**\n     * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n     * @param camera defines the camera to use to compute distance\n     * @param boundingSphere defines a custom bounding sphere to use instead of the one from this mesh\n     * @returns This mesh (for chaining)\n     */\n    getLOD(camera, boundingSphere) {\n        const internalDataInfo = this._internalMeshDataInfo;\n        if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {\n            return this;\n        }\n        const bSphere = boundingSphere || this.getBoundingInfo().boundingSphere;\n        const distanceToCamera = camera.mode === Camera.ORTHOGRAPHIC_CAMERA ? camera.minZ : bSphere.centerWorld.subtract(camera.globalPosition).length();\n        let compareValue = distanceToCamera;\n        let compareSign = 1;\n        if (internalDataInfo._useLODScreenCoverage) {\n            const screenArea = camera.screenArea;\n            let meshArea = (bSphere.radiusWorld * camera.minZ) / distanceToCamera;\n            meshArea = meshArea * meshArea * Math.PI;\n            compareValue = meshArea / screenArea;\n            compareSign = -1;\n        }\n        if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {\n            if (this.onLODLevelSelection) {\n                this.onLODLevelSelection(compareValue, this, this);\n            }\n            return this;\n        }\n        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\n            const level = internalDataInfo._LODLevels[index];\n            if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {\n                if (level.mesh) {\n                    if (level.mesh.delayLoadState === 4) {\n                        level.mesh._checkDelayState();\n                        return this;\n                    }\n                    if (level.mesh.delayLoadState === 2) {\n                        return this;\n                    }\n                    level.mesh._preActivate();\n                    level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n                }\n                if (this.onLODLevelSelection) {\n                    this.onLODLevelSelection(compareValue, this, level.mesh);\n                }\n                return level.mesh;\n            }\n        }\n        if (this.onLODLevelSelection) {\n            this.onLODLevelSelection(compareValue, this, this);\n        }\n        return this;\n    }\n    /**\n     * Gets the mesh internal Geometry object\n     */\n    get geometry() {\n        return this._geometry;\n    }\n    /**\n     * Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.\n     * @returns the total number of vertices\n     */\n    getTotalVertices() {\n        if (this._geometry === null || this._geometry === undefined) {\n            return 0;\n        }\n        return this._geometry.getTotalVertices();\n    }\n    /**\n     * Returns the content of an associated vertex buffer\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param copyWhenShared defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\n     * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n     * @returns a FloatArray or null if the mesh has no geometry or no vertex buffer for this kind.\n     */\n    getVerticesData(kind, copyWhenShared, forceCopy, bypassInstanceData) {\n        var _a, _b;\n        if (!this._geometry) {\n            return null;\n        }\n        let data = bypassInstanceData\n            ? undefined\n            : (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.getFloatData(this.instances.length + 1, // +1 because the master mesh is not included in the instances array\n            forceCopy || (copyWhenShared && this._geometry.meshes.length !== 1));\n        if (!data) {\n            data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);\n        }\n        return data;\n    }\n    /**\n     * Returns the mesh VertexBuffer object from the requested `kind`\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.NormalKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n     * @returns a FloatArray or null if the mesh has no vertex buffer for this kind.\n     */\n    getVertexBuffer(kind, bypassInstanceData) {\n        var _a, _b;\n        if (!this._geometry) {\n            return null;\n        }\n        return (_b = (bypassInstanceData ? undefined : (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind])) !== null && _b !== void 0 ? _b : this._geometry.getVertexBuffer(kind);\n    }\n    /**\n     * Tests if a specific vertex buffer is associated with this mesh\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.NormalKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n     * @returns a boolean\n     */\n    isVerticesDataPresent(kind, bypassInstanceData) {\n        var _a;\n        if (!this._geometry) {\n            if (this._delayInfo) {\n                return this._delayInfo.indexOf(kind) !== -1;\n            }\n            return false;\n        }\n        return (!bypassInstanceData && ((_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== undefined) || this._geometry.isVerticesDataPresent(kind);\n    }\n    /**\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable.\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n     * @returns a boolean\n     */\n    isVertexBufferUpdatable(kind, bypassInstanceData) {\n        var _a;\n        if (!this._geometry) {\n            if (this._delayInfo) {\n                return this._delayInfo.indexOf(kind) !== -1;\n            }\n            return false;\n        }\n        if (!bypassInstanceData) {\n            const buffer = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind];\n            if (buffer) {\n                return buffer.isUpdatable();\n            }\n        }\n        return this._geometry.isVertexBufferUpdatable(kind);\n    }\n    /**\n     * Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.\n     * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n     * @returns an array of strings\n     */\n    getVerticesDataKinds(bypassInstanceData) {\n        if (!this._geometry) {\n            const result = new Array();\n            if (this._delayInfo) {\n                this._delayInfo.forEach(function (kind) {\n                    result.push(kind);\n                });\n            }\n            return result;\n        }\n        const kinds = this._geometry.getVerticesDataKinds();\n        if (!bypassInstanceData && this._userInstancedBuffersStorage) {\n            for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {\n                if (kinds.indexOf(kind) === -1) {\n                    kinds.push(kind);\n                }\n            }\n        }\n        return kinds;\n    }\n    /**\n     * Returns a positive integer : the total number of indices in this mesh geometry.\n     * @returns the numner of indices or zero if the mesh has no geometry.\n     */\n    getTotalIndices() {\n        if (!this._geometry) {\n            return 0;\n        }\n        return this._geometry.getTotalIndices();\n    }\n    /**\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n     * @returns the indices array or an empty array if the mesh has no geometry\n     */\n    getIndices(copyWhenShared, forceCopy) {\n        if (!this._geometry) {\n            return [];\n        }\n        return this._geometry.getIndices(copyWhenShared, forceCopy);\n    }\n    get isBlocked() {\n        return this._masterMesh !== null && this._masterMesh !== undefined;\n    }\n    /**\n     * Determine if the current mesh is ready to be rendered\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n     * @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)\n     * @returns true if all associated assets are ready (material, textures, shaders)\n     */\n    isReady(completeCheck = false, forceInstanceSupport = false) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        if (this.delayLoadState === 2) {\n            return false;\n        }\n        if (!super.isReady(completeCheck)) {\n            return false;\n        }\n        if (!this.subMeshes || this.subMeshes.length === 0) {\n            return true;\n        }\n        if (!completeCheck) {\n            return true;\n        }\n        const engine = this.getEngine();\n        const scene = this.getScene();\n        const hardwareInstancedRendering = forceInstanceSupport || (engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances));\n        this.computeWorldMatrix();\n        const mat = this.material || scene.defaultMaterial;\n        if (mat) {\n            if (mat._storeEffectOnSubMeshes) {\n                for (const subMesh of this.subMeshes) {\n                    const effectiveMaterial = subMesh.getMaterial();\n                    if (effectiveMaterial) {\n                        if (effectiveMaterial._storeEffectOnSubMeshes) {\n                            if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n                                return false;\n                            }\n                        }\n                        else {\n                            if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                if (!mat.isReady(this, hardwareInstancedRendering)) {\n                    return false;\n                }\n            }\n        }\n        // Shadows\n        const currentRenderPassId = engine.currentRenderPassId;\n        for (const light of this.lightSources) {\n            const generators = light.getShadowGenerators();\n            if (!generators) {\n                continue;\n            }\n            const iterator = generators.values();\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                const generator = key.value;\n                if (generator && (!((_a = generator.getShadowMap()) === null || _a === void 0 ? void 0 : _a.renderList) || (((_b = generator.getShadowMap()) === null || _b === void 0 ? void 0 : _b.renderList) && ((_d = (_c = generator.getShadowMap()) === null || _c === void 0 ? void 0 : _c.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1))) {\n                    const shadowMap = generator.getShadowMap();\n                    const renderPassIds = (_e = shadowMap.renderPassIds) !== null && _e !== void 0 ? _e : [engine.currentRenderPassId];\n                    for (let p = 0; p < renderPassIds.length; ++p) {\n                        engine.currentRenderPassId = renderPassIds[p];\n                        for (const subMesh of this.subMeshes) {\n                            if (!generator.isReady(subMesh, hardwareInstancedRendering, (_g = (_f = subMesh.getMaterial()) === null || _f === void 0 ? void 0 : _f.needAlphaBlendingForMesh(this)) !== null && _g !== void 0 ? _g : false)) {\n                                engine.currentRenderPassId = currentRenderPassId;\n                                return false;\n                            }\n                        }\n                    }\n                    engine.currentRenderPassId = currentRenderPassId;\n                }\n            }\n        }\n        // LOD\n        for (const lod of this._internalMeshDataInfo._LODLevels) {\n            if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.\n     */\n    get areNormalsFrozen() {\n        return this._internalMeshDataInfo._areNormalsFrozen;\n    }\n    /**\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.\n     * @returns the current mesh\n     */\n    freezeNormals() {\n        this._internalMeshDataInfo._areNormalsFrozen = true;\n        return this;\n    }\n    /**\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen\n     * @returns the current mesh\n     */\n    unfreezeNormals() {\n        this._internalMeshDataInfo._areNormalsFrozen = false;\n        return this;\n    }\n    /**\n     * Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs\n     */\n    set overridenInstanceCount(count) {\n        this._instanceDataStorage.overridenInstanceCount = count;\n    }\n    // Methods\n    /** @internal */\n    _preActivate() {\n        const internalDataInfo = this._internalMeshDataInfo;\n        const sceneRenderId = this.getScene().getRenderId();\n        if (internalDataInfo._preActivateId === sceneRenderId) {\n            return this;\n        }\n        internalDataInfo._preActivateId = sceneRenderId;\n        this._instanceDataStorage.visibleInstances = null;\n        return this;\n    }\n    /**\n     * @internal\n     */\n    _preActivateForIntermediateRendering(renderId) {\n        if (this._instanceDataStorage.visibleInstances) {\n            this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;\n        }\n        return this;\n    }\n    /**\n     * @internal\n     */\n    _registerInstanceForRenderId(instance, renderId) {\n        if (!this._instanceDataStorage.visibleInstances) {\n            this._instanceDataStorage.visibleInstances = {\n                defaultRenderId: renderId,\n                selfDefaultRenderId: this._renderId,\n            };\n        }\n        if (!this._instanceDataStorage.visibleInstances[renderId]) {\n            if (this._instanceDataStorage.previousRenderId !== undefined && this._instanceDataStorage.isFrozen) {\n                this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;\n            }\n            this._instanceDataStorage.previousRenderId = renderId;\n            this._instanceDataStorage.visibleInstances[renderId] = new Array();\n        }\n        this._instanceDataStorage.visibleInstances[renderId].push(instance);\n        return this;\n    }\n    _afterComputeWorldMatrix() {\n        super._afterComputeWorldMatrix();\n        if (!this.hasThinInstances) {\n            return;\n        }\n        if (!this.doNotSyncBoundingInfo) {\n            this.thinInstanceRefreshBoundingInfo(false);\n        }\n    }\n    /** @internal */\n    _postActivate() {\n        if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {\n            this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);\n            this.edgesRenderer.customInstances.push(this.getWorldMatrix());\n        }\n    }\n    /**\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n     * This means the mesh underlying bounding box and sphere are recomputed.\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n     * @returns the current mesh\n     */\n    refreshBoundingInfo(applySkeleton = false, applyMorph = false) {\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\n            return this;\n        }\n        const bias = this.geometry ? this.geometry.boundingBias : null;\n        this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);\n        return this;\n    }\n    /**\n     * @internal\n     */\n    _createGlobalSubMesh(force) {\n        const totalVertices = this.getTotalVertices();\n        if (!totalVertices || !this.getIndices()) {\n            return null;\n        }\n        // Check if we need to recreate the submeshes\n        if (this.subMeshes && this.subMeshes.length > 0) {\n            const ib = this.getIndices();\n            if (!ib) {\n                return null;\n            }\n            const totalIndices = ib.length;\n            let needToRecreate = false;\n            if (force) {\n                needToRecreate = true;\n            }\n            else {\n                for (const submesh of this.subMeshes) {\n                    if (submesh.indexStart + submesh.indexCount > totalIndices) {\n                        needToRecreate = true;\n                        break;\n                    }\n                    if (submesh.verticesStart + submesh.verticesCount > totalVertices) {\n                        needToRecreate = true;\n                        break;\n                    }\n                }\n            }\n            if (!needToRecreate) {\n                return this.subMeshes[0];\n            }\n        }\n        this.releaseSubMeshes();\n        return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);\n    }\n    /**\n     * This function will subdivide the mesh into multiple submeshes\n     * @param count defines the expected number of submeshes\n     */\n    subdivide(count) {\n        if (count < 1) {\n            return;\n        }\n        const totalIndices = this.getTotalIndices();\n        let subdivisionSize = (totalIndices / count) | 0;\n        let offset = 0;\n        // Ensure that subdivisionSize is a multiple of 3\n        while (subdivisionSize % 3 !== 0) {\n            subdivisionSize++;\n        }\n        this.releaseSubMeshes();\n        for (let index = 0; index < count; index++) {\n            if (offset >= totalIndices) {\n                break;\n            }\n            SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);\n            offset += subdivisionSize;\n        }\n        this.synchronizeInstances();\n    }\n    /**\n     * Copy a FloatArray into a specific associated vertex buffer\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\n     * @param stride defines the data stride size (can be null)\n     * @returns the current mesh\n     */\n    setVerticesData(kind, data, updatable = false, stride) {\n        if (!this._geometry) {\n            const vertexData = new VertexData();\n            vertexData.set(data, kind);\n            const scene = this.getScene();\n            new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n        }\n        else {\n            this._geometry.setVerticesData(kind, data, updatable, stride);\n        }\n        return this;\n    }\n    /**\n     * Delete a vertex buffer associated with this mesh\n     * @param kind defines which buffer to delete (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     */\n    removeVerticesData(kind) {\n        if (!this._geometry) {\n            return;\n        }\n        this._geometry.removeVerticesData(kind);\n    }\n    /**\n     * Flags an associated vertex buffer as updatable\n     * @param kind defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\n     */\n    markVerticesDataAsUpdatable(kind, updatable = true) {\n        const vb = this.getVertexBuffer(kind);\n        if (!vb || vb.isUpdatable() === updatable) {\n            return;\n        }\n        this.setVerticesData(kind, this.getVerticesData(kind), updatable);\n    }\n    /**\n     * Sets the mesh global Vertex Buffer\n     * @param buffer defines the buffer to use\n     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\n     * @returns the current mesh\n     */\n    setVerticesBuffer(buffer, disposeExistingBuffer = true) {\n        if (!this._geometry) {\n            this._geometry = Geometry.CreateGeometryForMesh(this);\n        }\n        this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);\n        return this;\n    }\n    /**\n     * Update a specific associated vertex buffer\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\n     * @returns the current mesh\n     */\n    updateVerticesData(kind, data, updateExtends, makeItUnique) {\n        if (!this._geometry) {\n            return this;\n        }\n        if (!makeItUnique) {\n            this._geometry.updateVerticesData(kind, data, updateExtends);\n        }\n        else {\n            this.makeGeometryUnique();\n            this.updateVerticesData(kind, data, updateExtends, false);\n        }\n        return this;\n    }\n    /**\n     * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#other-shapes-updatemeshpositions\n     * @param positionFunction is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything\n     * @param computeNormals is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update\n     * @returns the current mesh\n     */\n    updateMeshPositions(positionFunction, computeNormals = true) {\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\n        if (!positions) {\n            return this;\n        }\n        positionFunction(positions);\n        this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n        if (computeNormals) {\n            const indices = this.getIndices();\n            const normals = this.getVerticesData(VertexBuffer.NormalKind);\n            if (!normals) {\n                return this;\n            }\n            VertexData.ComputeNormals(positions, indices, normals);\n            this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\n        }\n        return this;\n    }\n    /**\n     * Creates a un-shared specific occurence of the geometry for the mesh.\n     * @returns the current mesh\n     */\n    makeGeometryUnique() {\n        if (!this._geometry) {\n            return this;\n        }\n        if (this._geometry.meshes.length === 1) {\n            return this;\n        }\n        const oldGeometry = this._geometry;\n        const geometry = this._geometry.copy(Geometry.RandomId());\n        oldGeometry.releaseForMesh(this, true);\n        geometry.applyToMesh(this);\n        return this;\n    }\n    /**\n     * Set the index buffer of this mesh\n     * @param indices defines the source data\n     * @param totalVertices defines the total number of vertices referenced by this index data (can be null)\n     * @param updatable defines if the updated index buffer must be flagged as updatable (default is false)\n     * @returns the current mesh\n     */\n    setIndices(indices, totalVertices = null, updatable = false) {\n        if (!this._geometry) {\n            const vertexData = new VertexData();\n            vertexData.indices = indices;\n            const scene = this.getScene();\n            new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n        }\n        else {\n            this._geometry.setIndices(indices, totalVertices, updatable);\n        }\n        return this;\n    }\n    /**\n     * Update the current index buffer\n     * @param indices defines the source data\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n     * @returns the current mesh\n     */\n    updateIndices(indices, offset, gpuMemoryOnly = false) {\n        if (!this._geometry) {\n            return this;\n        }\n        this._geometry.updateIndices(indices, offset, gpuMemoryOnly);\n        return this;\n    }\n    /**\n     * Invert the geometry to move from a right handed system to a left handed one.\n     * @returns the current mesh\n     */\n    toLeftHanded() {\n        if (!this._geometry) {\n            return this;\n        }\n        this._geometry.toLeftHanded();\n        return this;\n    }\n    /**\n     * @internal\n     */\n    _bind(subMesh, effect, fillMode, allowInstancedRendering = true) {\n        if (!this._geometry) {\n            return this;\n        }\n        const engine = this.getScene().getEngine();\n        // Morph targets\n        if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {\n            this.morphTargetManager._bind(effect);\n        }\n        // Wireframe\n        let indexToBind;\n        if (this._unIndexed) {\n            indexToBind = null;\n        }\n        else {\n            switch (this._getRenderingFillMode(fillMode)) {\n                case Material.PointFillMode:\n                    indexToBind = null;\n                    break;\n                case Material.WireFrameFillMode:\n                    indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);\n                    break;\n                default:\n                case Material.TriangleFillMode:\n                    indexToBind = this._geometry.getIndexBuffer();\n                    break;\n            }\n        }\n        // VBOs\n        if (!allowInstancedRendering || !this._userInstancedBuffersStorage || this.hasThinInstances) {\n            this._geometry._bind(effect, indexToBind);\n        }\n        else {\n            this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\n        }\n        return this;\n    }\n    /**\n     * @internal\n     */\n    _draw(subMesh, fillMode, instancesCount) {\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\n            return this;\n        }\n        if (this._internalMeshDataInfo._onBeforeDrawObservable) {\n            this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);\n        }\n        const scene = this.getScene();\n        const engine = scene.getEngine();\n        if (this._unIndexed || fillMode == Material.PointFillMode) {\n            // or triangles as points\n            engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);\n        }\n        else if (fillMode == Material.WireFrameFillMode) {\n            // Triangles as wireframe\n            engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);\n        }\n        else {\n            engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);\n        }\n        return this;\n    }\n    /**\n     * Registers for this mesh a javascript function called just before the rendering process\n     * @param func defines the function to call before rendering this mesh\n     * @returns the current mesh\n     */\n    registerBeforeRender(func) {\n        this.onBeforeRenderObservable.add(func);\n        return this;\n    }\n    /**\n     * Disposes a previously registered javascript function called before the rendering\n     * @param func defines the function to remove\n     * @returns the current mesh\n     */\n    unregisterBeforeRender(func) {\n        this.onBeforeRenderObservable.removeCallback(func);\n        return this;\n    }\n    /**\n     * Registers for this mesh a javascript function called just after the rendering is complete\n     * @param func defines the function to call after rendering this mesh\n     * @returns the current mesh\n     */\n    registerAfterRender(func) {\n        this.onAfterRenderObservable.add(func);\n        return this;\n    }\n    /**\n     * Disposes a previously registered javascript function called after the rendering.\n     * @param func defines the function to remove\n     * @returns the current mesh\n     */\n    unregisterAfterRender(func) {\n        this.onAfterRenderObservable.removeCallback(func);\n        return this;\n    }\n    /**\n     * @internal\n     */\n    _getInstancesRenderList(subMeshId, isReplacementMode = false) {\n        if (this._instanceDataStorage.isFrozen) {\n            if (isReplacementMode) {\n                this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;\n                this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;\n                return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;\n            }\n            if (this._instanceDataStorage.previousBatch) {\n                return this._instanceDataStorage.previousBatch;\n            }\n        }\n        const scene = this.getScene();\n        const isInIntermediateRendering = scene._isInIntermediateRendering();\n        const onlyForInstances = isInIntermediateRendering\n            ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate\n            : this._internalAbstractMeshDataInfo._onlyForInstances;\n        const batchCache = this._instanceDataStorage.batchCache;\n        batchCache.mustReturn = false;\n        batchCache.renderSelf[subMeshId] = isReplacementMode || (!onlyForInstances && this.isEnabled() && this.isVisible);\n        batchCache.visibleInstances[subMeshId] = null;\n        if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {\n            const visibleInstances = this._instanceDataStorage.visibleInstances;\n            const currentRenderId = scene.getRenderId();\n            const defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;\n            batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];\n            if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {\n                batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];\n            }\n        }\n        batchCache.hardwareInstancedRendering[subMeshId] =\n            !isReplacementMode &&\n                this._instanceDataStorage.hardwareInstancedRendering &&\n                batchCache.visibleInstances[subMeshId] !== null &&\n                batchCache.visibleInstances[subMeshId] !== undefined;\n        this._instanceDataStorage.previousBatch = batchCache;\n        return batchCache;\n    }\n    /**\n     * @internal\n     */\n    _renderWithInstances(subMesh, fillMode, batch, effect, engine) {\n        var _a;\n        const visibleInstances = batch.visibleInstances[subMesh._id];\n        const visibleInstanceCount = visibleInstances ? visibleInstances.length : 0;\n        const instanceStorage = this._instanceDataStorage;\n        const currentInstancesBufferSize = instanceStorage.instancesBufferSize;\n        let instancesBuffer = instanceStorage.instancesBuffer;\n        let instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;\n        const matricesCount = visibleInstanceCount + 1;\n        const bufferSize = matricesCount * 16 * 4;\n        while (instanceStorage.instancesBufferSize < bufferSize) {\n            instanceStorage.instancesBufferSize *= 2;\n        }\n        if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n            instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n        }\n        if ((this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData) || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n            instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n        }\n        let offset = 0;\n        let instancesCount = 0;\n        const renderSelf = batch.renderSelf[subMesh._id];\n        const needUpdateBuffer = !instancesBuffer ||\n            currentInstancesBufferSize !== instanceStorage.instancesBufferSize ||\n            (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer);\n        if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {\n            const world = this.getWorldMatrix();\n            if (renderSelf) {\n                if (this._scene.needsPreviousWorldMatrices) {\n                    if (!instanceStorage.masterMeshPreviousWorldMatrix) {\n                        instanceStorage.masterMeshPreviousWorldMatrix = world.clone();\n                        instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n                    }\n                    else {\n                        instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n                        instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);\n                    }\n                }\n                world.copyToArray(instanceStorage.instancesData, offset);\n                offset += 16;\n                instancesCount++;\n            }\n            if (visibleInstances) {\n                if (Mesh.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMesh.getRenderingMesh()))) {\n                    const cameraPosition = this._scene.activeCamera.globalPosition;\n                    for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\n                        const instanceMesh = visibleInstances[instanceIndex];\n                        instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n                    }\n                    visibleInstances.sort((m1, m2) => {\n                        return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;\n                    });\n                }\n                for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\n                    const instance = visibleInstances[instanceIndex];\n                    const matrix = instance.getWorldMatrix();\n                    matrix.copyToArray(instanceStorage.instancesData, offset);\n                    if (this._scene.needsPreviousWorldMatrices) {\n                        if (!instance._previousWorldMatrix) {\n                            instance._previousWorldMatrix = matrix.clone();\n                            instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n                        }\n                        else {\n                            instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n                            instance._previousWorldMatrix.copyFrom(matrix);\n                        }\n                    }\n                    offset += 16;\n                    instancesCount++;\n                }\n            }\n        }\n        else {\n            instancesCount = (renderSelf ? 1 : 0) + visibleInstanceCount;\n        }\n        if (needUpdateBuffer) {\n            if (instancesBuffer) {\n                instancesBuffer.dispose();\n            }\n            if (instancesPreviousBuffer) {\n                instancesPreviousBuffer.dispose();\n            }\n            instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);\n            instanceStorage.instancesBuffer = instancesBuffer;\n            if (!this._userInstancedBuffersStorage) {\n                this._userInstancedBuffersStorage = {\n                    data: {},\n                    vertexBuffers: {},\n                    strides: {},\n                    sizes: {},\n                    vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\n                };\n            }\n            this._userInstancedBuffersStorage.vertexBuffers[\"world0\"] = instancesBuffer.createVertexBuffer(\"world0\", 0, 4);\n            this._userInstancedBuffersStorage.vertexBuffers[\"world1\"] = instancesBuffer.createVertexBuffer(\"world1\", 4, 4);\n            this._userInstancedBuffersStorage.vertexBuffers[\"world2\"] = instancesBuffer.createVertexBuffer(\"world2\", 8, 4);\n            this._userInstancedBuffersStorage.vertexBuffers[\"world3\"] = instancesBuffer.createVertexBuffer(\"world3\", 12, 4);\n            if (this._scene.needsPreviousWorldMatrices) {\n                instancesPreviousBuffer = new Buffer(engine, instanceStorage.instancesPreviousData, true, 16, false, true);\n                instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld0\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld0\", 0, 4);\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld1\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld1\", 4, 4);\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld2\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld2\", 8, 4);\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld3\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld3\", 12, 4);\n            }\n            this._invalidateInstanceVertexArrayObject();\n        }\n        else {\n            if (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) {\n                instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n                if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {\n                    instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);\n                }\n            }\n        }\n        this._processInstancedBuffers(visibleInstances, renderSelf);\n        // Stats\n        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\n        // Draw\n        if (engine._currentDrawContext) {\n            engine._currentDrawContext.useInstancing = true;\n        }\n        this._bind(subMesh, effect, fillMode);\n        this._draw(subMesh, fillMode, instancesCount);\n        // Write current matrices as previous matrices in case of manual update\n        // Default behaviour when previous matrices are not specified explicitly\n        // Will break if instances number/order changes\n        if (this._scene.needsPreviousWorldMatrices &&\n            !needUpdateBuffer &&\n            this._instanceDataStorage.manualUpdate &&\n            (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) &&\n            !this._instanceDataStorage.previousManualUpdate) {\n            instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n        }\n        engine.unbindInstanceAttributes();\n        return this;\n    }\n    /**\n     * @internal\n     */\n    _renderWithThinInstances(subMesh, fillMode, effect, engine) {\n        var _a, _b;\n        // Stats\n        const instancesCount = (_b = (_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.instancesCount) !== null && _b !== void 0 ? _b : 0;\n        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\n        // Draw\n        if (engine._currentDrawContext) {\n            engine._currentDrawContext.useInstancing = true;\n        }\n        this._bind(subMesh, effect, fillMode);\n        this._draw(subMesh, fillMode, instancesCount);\n        // Write current matrices as previous matrices\n        // Default behaviour when previous matrices are not specified explicitly\n        // Will break if instances number/order changes\n        if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {\n            if (!this._thinInstanceDataStorage.previousMatrixBuffer) {\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", this._thinInstanceDataStorage.matrixData, false);\n            }\n            else {\n                this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);\n            }\n        }\n        engine.unbindInstanceAttributes();\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _processInstancedBuffers(visibleInstances, renderSelf) {\n        // Do nothing\n    }\n    /**\n     * @internal\n     */\n    _processRendering(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {\n        const scene = this.getScene();\n        const engine = scene.getEngine();\n        fillMode = this._getRenderingFillMode(fillMode);\n        if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {\n            this._renderWithThinInstances(subMesh, fillMode, effect, engine);\n            return this;\n        }\n        if (hardwareInstancedRendering) {\n            this._renderWithInstances(subMesh, fillMode, batch, effect, engine);\n        }\n        else {\n            if (engine._currentDrawContext) {\n                engine._currentDrawContext.useInstancing = false;\n            }\n            let instanceCount = 0;\n            if (batch.renderSelf[subMesh._id]) {\n                // Draw\n                if (onBeforeDraw) {\n                    onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);\n                }\n                instanceCount++;\n                this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);\n            }\n            const visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];\n            if (visibleInstancesForSubMesh) {\n                const visibleInstanceCount = visibleInstancesForSubMesh.length;\n                instanceCount += visibleInstanceCount;\n                // Stats\n                for (let instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {\n                    const instance = visibleInstancesForSubMesh[instanceIndex];\n                    // World\n                    const world = instance.getWorldMatrix();\n                    if (onBeforeDraw) {\n                        onBeforeDraw(true, world, effectiveMaterial);\n                    }\n                    // Draw\n                    this._draw(subMesh, fillMode);\n                }\n            }\n            // Stats\n            scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);\n        }\n        return this;\n    }\n    /**\n     * @internal\n     */\n    _rebuild(dispose = false) {\n        if (this._instanceDataStorage.instancesBuffer) {\n            // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n            if (dispose) {\n                this._instanceDataStorage.instancesBuffer.dispose();\n            }\n            this._instanceDataStorage.instancesBuffer = null;\n        }\n        if (this._userInstancedBuffersStorage) {\n            for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {\n                const buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];\n                if (buffer) {\n                    // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n                    if (dispose) {\n                        buffer.dispose();\n                    }\n                    this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n                }\n            }\n            if (this._userInstancedBuffersStorage.vertexArrayObjects) {\n                this._userInstancedBuffersStorage.vertexArrayObjects = {};\n            }\n        }\n        this._internalMeshDataInfo._effectiveMaterial = null;\n        super._rebuild(dispose);\n    }\n    /** @internal */\n    _freeze() {\n        if (!this.subMeshes) {\n            return;\n        }\n        // Prepare batches\n        for (let index = 0; index < this.subMeshes.length; index++) {\n            this._getInstancesRenderList(index);\n        }\n        this._internalMeshDataInfo._effectiveMaterial = null;\n        this._instanceDataStorage.isFrozen = true;\n    }\n    /** @internal */\n    _unFreeze() {\n        this._instanceDataStorage.isFrozen = false;\n        this._instanceDataStorage.previousBatch = null;\n    }\n    /**\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\n     * @param subMesh defines the subMesh to render\n     * @param enableAlphaMode defines if alpha mode can be changed\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\n     * @returns the current mesh\n     */\n    render(subMesh, enableAlphaMode, effectiveMeshReplacement) {\n        var _a, _b, _c;\n        const scene = this.getScene();\n        if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {\n            this._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n        }\n        else {\n            this._internalAbstractMeshDataInfo._isActive = false;\n        }\n        if (this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {\n            return this;\n        }\n        // Managing instances\n        const batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);\n        if (batch.mustReturn) {\n            return this;\n        }\n        // Checking geometry state\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\n            return this;\n        }\n        const engine = scene.getEngine();\n        let oldCameraMaxZ = 0;\n        let oldCamera = null;\n        if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {\n            oldCameraMaxZ = scene.activeCamera.maxZ;\n            oldCamera = scene.activeCamera;\n            scene.activeCamera.maxZ = 0;\n            scene.updateTransformMatrix(true);\n        }\n        if (this._internalMeshDataInfo._onBeforeRenderObservable) {\n            this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);\n        }\n        const renderingMesh = subMesh.getRenderingMesh();\n        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] ||\n            renderingMesh.hasThinInstances ||\n            (!!this._userInstancedBuffersStorage && !subMesh.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh);\n        const instanceDataStorage = this._instanceDataStorage;\n        const material = subMesh.getMaterial();\n        if (!material) {\n            if (oldCamera) {\n                oldCamera.maxZ = oldCameraMaxZ;\n                scene.updateTransformMatrix(true);\n            }\n            return this;\n        }\n        // Material\n        if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {\n            if (material._storeEffectOnSubMeshes) {\n                if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n                    if (oldCamera) {\n                        oldCamera.maxZ = oldCameraMaxZ;\n                        scene.updateTransformMatrix(true);\n                    }\n                    return this;\n                }\n            }\n            else if (!material.isReady(this, hardwareInstancedRendering)) {\n                if (oldCamera) {\n                    oldCamera.maxZ = oldCameraMaxZ;\n                    scene.updateTransformMatrix(true);\n                }\n                return this;\n            }\n            this._internalMeshDataInfo._effectiveMaterial = material;\n        }\n        else if ((material._storeEffectOnSubMeshes && !((_a = subMesh.effect) === null || _a === void 0 ? void 0 : _a._wasPreviouslyReady)) ||\n            (!material._storeEffectOnSubMeshes && !((_b = material.getEffect()) === null || _b === void 0 ? void 0 : _b._wasPreviouslyReady))) {\n            if (oldCamera) {\n                oldCamera.maxZ = oldCameraMaxZ;\n                scene.updateTransformMatrix(true);\n            }\n            return this;\n        }\n        // Alpha mode\n        if (enableAlphaMode) {\n            engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);\n        }\n        let drawWrapper;\n        if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {\n            drawWrapper = subMesh._drawWrapper;\n        }\n        else {\n            drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();\n        }\n        const effect = (_c = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _c !== void 0 ? _c : null;\n        for (const step of scene._beforeRenderingMeshStage) {\n            step.action(this, subMesh, batch, effect);\n        }\n        if (!drawWrapper || !effect) {\n            if (oldCamera) {\n                oldCamera.maxZ = oldCameraMaxZ;\n                scene.updateTransformMatrix(true);\n            }\n            return this;\n        }\n        const effectiveMesh = effectiveMeshReplacement || this;\n        let sideOrientation;\n        if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {\n            const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n            sideOrientation = this.overrideMaterialSideOrientation;\n            if (sideOrientation == null) {\n                sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;\n            }\n            if (mainDeterminant < 0) {\n                sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n            }\n            instanceDataStorage.sideOrientation = sideOrientation;\n        }\n        else {\n            sideOrientation = instanceDataStorage.sideOrientation;\n        }\n        const reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);\n        if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {\n            engine.setDepthWrite(true);\n        }\n        // Bind\n        const effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;\n        const fillMode = effectiveMaterial.fillMode;\n        if (this._internalMeshDataInfo._onBeforeBindObservable) {\n            this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);\n        }\n        if (!hardwareInstancedRendering) {\n            // Binding will be done later because we need to add more info to the VB\n            this._bind(subMesh, effect, fillMode, false);\n        }\n        const world = effectiveMesh.getWorldMatrix();\n        if (effectiveMaterial._storeEffectOnSubMeshes) {\n            effectiveMaterial.bindForSubMesh(world, this, subMesh);\n        }\n        else {\n            effectiveMaterial.bind(world, this);\n        }\n        if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {\n            engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n            this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\n            engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n            if (this._internalMeshDataInfo._onBetweenPassObservable) {\n                this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);\n            }\n        }\n        // Draw\n        this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\n        // Unbind\n        this._internalMeshDataInfo._effectiveMaterial.unbind();\n        for (const step of scene._afterRenderingMeshStage) {\n            step.action(this, subMesh, batch, effect);\n        }\n        if (this._internalMeshDataInfo._onAfterRenderObservable) {\n            this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);\n        }\n        if (oldCamera) {\n            oldCamera.maxZ = oldCameraMaxZ;\n            scene.updateTransformMatrix(true);\n        }\n        if (scene.performancePriority === ScenePerformancePriority.Aggressive && !instanceDataStorage.isFrozen) {\n            this._freeze();\n        }\n        return this;\n    }\n    /**\n     *   Renormalize the mesh and patch it up if there are no weights\n     *   Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.\n     *   However in the case of zero weights then we set just a single influence to 1.\n     *   We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.\n     */\n    cleanMatrixWeights() {\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n            if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n                this._normalizeSkinWeightsAndExtra();\n            }\n            else {\n                this._normalizeSkinFourWeights();\n            }\n        }\n    }\n    // faster 4 weight version.\n    _normalizeSkinFourWeights() {\n        const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n        const numWeights = matricesWeights.length;\n        for (let a = 0; a < numWeights; a += 4) {\n            // accumulate weights\n            const t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\n            // check for invalid weight and just set it to 1.\n            if (t === 0) {\n                matricesWeights[a] = 1;\n            }\n            else {\n                // renormalize so everything adds to 1 use reciprocal\n                const recip = 1 / t;\n                matricesWeights[a] *= recip;\n                matricesWeights[a + 1] *= recip;\n                matricesWeights[a + 2] *= recip;\n                matricesWeights[a + 3] *= recip;\n            }\n        }\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n    }\n    // handle special case of extra verts.  (in theory gltf can handle 12 influences)\n    _normalizeSkinWeightsAndExtra() {\n        const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n        const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n        const numWeights = matricesWeights.length;\n        for (let a = 0; a < numWeights; a += 4) {\n            // accumulate weights\n            let t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\n            t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];\n            // check for invalid weight and just set it to 1.\n            if (t === 0) {\n                matricesWeights[a] = 1;\n            }\n            else {\n                // renormalize so everything adds to 1 use reciprocal\n                const recip = 1 / t;\n                matricesWeights[a] *= recip;\n                matricesWeights[a + 1] *= recip;\n                matricesWeights[a + 2] *= recip;\n                matricesWeights[a + 3] *= recip;\n                // same goes for extras\n                matricesWeightsExtra[a] *= recip;\n                matricesWeightsExtra[a + 1] *= recip;\n                matricesWeightsExtra[a + 2] *= recip;\n                matricesWeightsExtra[a + 3] *= recip;\n            }\n        }\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);\n    }\n    /**\n     * ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,\n     * or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let\n     * the user know there was an issue with importing the mesh\n     * @returns a validation object with skinned, valid and report string\n     */\n    validateSkinning() {\n        const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n        const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n        if (matricesWeights === null || this.skeleton == null) {\n            return { skinned: false, valid: true, report: \"not skinned\" };\n        }\n        const numWeights = matricesWeights.length;\n        let numberNotSorted = 0;\n        let missingWeights = 0;\n        let maxUsedWeights = 0;\n        let numberNotNormalized = 0;\n        const numInfluences = matricesWeightsExtra === null ? 4 : 8;\n        const usedWeightCounts = new Array();\n        for (let a = 0; a <= numInfluences; a++) {\n            usedWeightCounts[a] = 0;\n        }\n        const toleranceEpsilon = 0.001;\n        for (let a = 0; a < numWeights; a += 4) {\n            let lastWeight = matricesWeights[a];\n            let t = lastWeight;\n            let usedWeights = t === 0 ? 0 : 1;\n            for (let b = 1; b < numInfluences; b++) {\n                const d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];\n                if (d > lastWeight) {\n                    numberNotSorted++;\n                }\n                if (d !== 0) {\n                    usedWeights++;\n                }\n                t += d;\n                lastWeight = d;\n            }\n            // count the buffer weights usage\n            usedWeightCounts[usedWeights]++;\n            // max influences\n            if (usedWeights > maxUsedWeights) {\n                maxUsedWeights = usedWeights;\n            }\n            // check for invalid weight and just set it to 1.\n            if (t === 0) {\n                missingWeights++;\n            }\n            else {\n                // renormalize so everything adds to 1 use reciprocal\n                const recip = 1 / t;\n                let tolerance = 0;\n                for (let b = 0; b < numInfluences; b++) {\n                    if (b < 4) {\n                        tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);\n                    }\n                    else {\n                        tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);\n                    }\n                }\n                // arbitrary epsilon value for dictating not normalized\n                if (tolerance > toleranceEpsilon) {\n                    numberNotNormalized++;\n                }\n            }\n        }\n        // validate bone indices are in range of the skeleton\n        const numBones = this.skeleton.bones.length;\n        const matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n        const matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n        let numBadBoneIndices = 0;\n        for (let a = 0; a < numWeights; a += 4) {\n            for (let b = 0; b < numInfluences; b++) {\n                const index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];\n                if (index >= numBones || index < 0) {\n                    numBadBoneIndices++;\n                }\n            }\n        }\n        // log mesh stats\n        const output = \"Number of Weights = \" +\n            numWeights / 4 +\n            \"\\nMaximum influences = \" +\n            maxUsedWeights +\n            \"\\nMissing Weights = \" +\n            missingWeights +\n            \"\\nNot Sorted = \" +\n            numberNotSorted +\n            \"\\nNot Normalized = \" +\n            numberNotNormalized +\n            \"\\nWeightCounts = [\" +\n            usedWeightCounts +\n            \"]\" +\n            \"\\nNumber of bones = \" +\n            numBones +\n            \"\\nBad Bone Indices = \" +\n            numBadBoneIndices;\n        return { skinned: true, valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0, report: output };\n    }\n    /** @internal */\n    _checkDelayState() {\n        const scene = this.getScene();\n        if (this._geometry) {\n            this._geometry.load(scene);\n        }\n        else if (this.delayLoadState === 4) {\n            this.delayLoadState = 2;\n            this._queueLoad(scene);\n        }\n        return this;\n    }\n    _queueLoad(scene) {\n        scene.addPendingData(this);\n        const getBinaryData = this.delayLoadingFile.indexOf(\".babylonbinarymeshdata\") !== -1;\n        Tools.LoadFile(this.delayLoadingFile, (data) => {\n            if (data instanceof ArrayBuffer) {\n                this._delayLoadingFunction(data, this);\n            }\n            else {\n                this._delayLoadingFunction(JSON.parse(data), this);\n            }\n            this.instances.forEach((instance) => {\n                instance.refreshBoundingInfo();\n                instance._syncSubMeshes();\n            });\n            this.delayLoadState = 1;\n            scene.removePendingData(this);\n        }, () => { }, scene.offlineProvider, getBinaryData);\n        return this;\n    }\n    /**\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\n     * A mesh is in the frustum if its bounding box intersects the frustum\n     * @param frustumPlanes defines the frustum to test\n     * @returns true if the mesh is in the frustum planes\n     */\n    isInFrustum(frustumPlanes) {\n        if (this.delayLoadState === 2) {\n            return false;\n        }\n        if (!super.isInFrustum(frustumPlanes)) {\n            return false;\n        }\n        this._checkDelayState();\n        return true;\n    }\n    /**\n     * Sets the mesh material by the material or multiMaterial `id` property\n     * @param id is a string identifying the material or the multiMaterial\n     * @returns the current mesh\n     */\n    setMaterialById(id) {\n        const materials = this.getScene().materials;\n        let index;\n        for (index = materials.length - 1; index > -1; index--) {\n            if (materials[index].id === id) {\n                this.material = materials[index];\n                return this;\n            }\n        }\n        // Multi\n        const multiMaterials = this.getScene().multiMaterials;\n        for (index = multiMaterials.length - 1; index > -1; index--) {\n            if (multiMaterials[index].id === id) {\n                this.material = multiMaterials[index];\n                return this;\n            }\n        }\n        return this;\n    }\n    /**\n     * Returns as a new array populated with the mesh material and/or skeleton, if any.\n     * @returns an array of IAnimatable\n     */\n    getAnimatables() {\n        const results = new Array();\n        if (this.material) {\n            results.push(this.material);\n        }\n        if (this.skeleton) {\n            results.push(this.skeleton);\n        }\n        return results;\n    }\n    /**\n     * Modifies the mesh geometry according to the passed transformation matrix.\n     * This method returns nothing, but it really modifies the mesh even if it's originally not set as updatable.\n     * The mesh normals are modified using the same transformation.\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\n     * @param transform defines the transform matrix to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\n     * @returns the current mesh\n     */\n    bakeTransformIntoVertices(transform) {\n        // Position\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n            return this;\n        }\n        const submeshes = this.subMeshes.splice(0);\n        this._resetPointsArrayCache();\n        let data = this.getVerticesData(VertexBuffer.PositionKind);\n        const temp = Vector3.Zero();\n        let index;\n        for (index = 0; index < data.length; index += 3) {\n            Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).toArray(data, index);\n        }\n        this.setVerticesData(VertexBuffer.PositionKind, data, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());\n        // Normals\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n            data = this.getVerticesData(VertexBuffer.NormalKind);\n            for (index = 0; index < data.length; index += 3) {\n                Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp)\n                    .normalize()\n                    .toArray(data, index);\n            }\n            this.setVerticesData(VertexBuffer.NormalKind, data, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());\n        }\n        // flip faces?\n        if (transform.determinant() < 0) {\n            this.flipFaces();\n        }\n        // Restore submeshes\n        this.releaseSubMeshes();\n        this.subMeshes = submeshes;\n        return this;\n    }\n    /**\n     * Modifies the mesh geometry according to its own current World Matrix.\n     * The mesh World Matrix is then reset.\n     * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\n     * @param bakeIndependentlyOfChildren indicates whether to preserve all child nodes' World Matrix during baking\n     * @returns the current mesh\n     */\n    bakeCurrentTransformIntoVertices(bakeIndependentlyOfChildren = true) {\n        this.bakeTransformIntoVertices(this.computeWorldMatrix(true));\n        this.resetLocalMatrix(bakeIndependentlyOfChildren);\n        return this;\n    }\n    // Cache\n    /** @internal */\n    get _positions() {\n        if (this._internalAbstractMeshDataInfo._positions) {\n            return this._internalAbstractMeshDataInfo._positions;\n        }\n        if (this._geometry) {\n            return this._geometry._positions;\n        }\n        return null;\n    }\n    /** @internal */\n    _resetPointsArrayCache() {\n        if (this._geometry) {\n            this._geometry._resetPointsArrayCache();\n        }\n        return this;\n    }\n    /** @internal */\n    _generatePointsArray() {\n        if (this._geometry) {\n            return this._geometry._generatePointsArray();\n        }\n        return false;\n    }\n    /**\n     * Returns a new Mesh object generated from the current mesh properties.\n     * This method must not get confused with createInstance()\n     * @param name is a string, the name given to the new mesh\n     * @param newParent can be any Node object (default `null`)\n     * @param doNotCloneChildren allows/denies the recursive cloning of the original mesh children if any (default `false`)\n     * @param clonePhysicsImpostor allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)\n     * @returns a new mesh\n     */\n    clone(name = \"\", newParent = null, doNotCloneChildren, clonePhysicsImpostor = true) {\n        return new Mesh(name, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);\n    }\n    /**\n     * Releases resources associated with this mesh.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n    dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n        this.morphTargetManager = null;\n        if (this._geometry) {\n            this._geometry.releaseForMesh(this, true);\n        }\n        const internalDataInfo = this._internalMeshDataInfo;\n        if (internalDataInfo._onBeforeDrawObservable) {\n            internalDataInfo._onBeforeDrawObservable.clear();\n        }\n        if (internalDataInfo._onBeforeBindObservable) {\n            internalDataInfo._onBeforeBindObservable.clear();\n        }\n        if (internalDataInfo._onBeforeRenderObservable) {\n            internalDataInfo._onBeforeRenderObservable.clear();\n        }\n        if (internalDataInfo._onAfterRenderObservable) {\n            internalDataInfo._onAfterRenderObservable.clear();\n        }\n        if (internalDataInfo._onBetweenPassObservable) {\n            internalDataInfo._onBetweenPassObservable.clear();\n        }\n        // Sources\n        if (this._scene.useClonedMeshMap) {\n            if (internalDataInfo.meshMap) {\n                for (const uniqueId in internalDataInfo.meshMap) {\n                    const mesh = internalDataInfo.meshMap[uniqueId];\n                    if (mesh) {\n                        mesh._internalMeshDataInfo._source = null;\n                        internalDataInfo.meshMap[uniqueId] = undefined;\n                    }\n                }\n            }\n            if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {\n                internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = undefined;\n            }\n        }\n        else {\n            const meshes = this.getScene().meshes;\n            for (const abstractMesh of meshes) {\n                const mesh = abstractMesh;\n                if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {\n                    mesh._internalMeshDataInfo._source = null;\n                }\n            }\n        }\n        internalDataInfo._source = null;\n        this._instanceDataStorage.visibleInstances = {};\n        // Instances\n        this._disposeInstanceSpecificData();\n        // Thin instances\n        this._disposeThinInstanceSpecificData();\n        if (this._internalMeshDataInfo._checkReadinessObserver) {\n            this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);\n        }\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\n    }\n    /** @internal */\n    _disposeInstanceSpecificData() {\n        // Do nothing\n    }\n    /** @internal */\n    _disposeThinInstanceSpecificData() {\n        // Do nothing\n    }\n    /** @internal */\n    _invalidateInstanceVertexArrayObject() {\n        // Do nothing\n    }\n    /**\n     * Modifies the mesh geometry according to a displacement map.\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n     * @param url is a string, the URL from the image file is to be downloaded.\n     * @param minHeight is the lower limit of the displacement.\n     * @param maxHeight is the upper limit of the displacement.\n     * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.\n     * @param uvOffset is an optional vector2 used to offset UV.\n     * @param uvScale is an optional vector2 used to scale UV.\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n     * @returns the Mesh.\n     */\n    applyDisplacementMap(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale, forceUpdate = false) {\n        const scene = this.getScene();\n        const onload = (img) => {\n            // Getting height map data\n            const heightMapWidth = img.width;\n            const heightMapHeight = img.height;\n            const canvas = this.getEngine().createCanvas(heightMapWidth, heightMapHeight);\n            const context = canvas.getContext(\"2d\");\n            context.drawImage(img, 0, 0);\n            // Create VertexData from map data\n            //Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\n            const buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;\n            this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);\n            //execute success callback, if set\n            if (onSuccess) {\n                onSuccess(this);\n            }\n        };\n        Tools.LoadImage(url, onload, () => { }, scene.offlineProvider);\n        return this;\n    }\n    /**\n     * Modifies the mesh geometry according to a displacementMap buffer.\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n     * @param buffer is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.\n     * @param heightMapWidth is the width of the buffer image.\n     * @param heightMapHeight is the height of the buffer image.\n     * @param minHeight is the lower limit of the displacement.\n     * @param maxHeight is the upper limit of the displacement.\n     * @param uvOffset is an optional vector2 used to offset UV.\n     * @param uvScale is an optional vector2 used to scale UV.\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n     * @returns the Mesh.\n     */\n    applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate = false) {\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n            Logger.Warn(\"Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing\");\n            return this;\n        }\n        const positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);\n        const normals = this.getVerticesData(VertexBuffer.NormalKind);\n        const uvs = this.getVerticesData(VertexBuffer.UVKind);\n        let position = Vector3.Zero();\n        const normal = Vector3.Zero();\n        const uv = Vector2.Zero();\n        uvOffset = uvOffset || Vector2.Zero();\n        uvScale = uvScale || new Vector2(1, 1);\n        for (let index = 0; index < positions.length; index += 3) {\n            Vector3.FromArrayToRef(positions, index, position);\n            Vector3.FromArrayToRef(normals, index, normal);\n            Vector2.FromArrayToRef(uvs, (index / 3) * 2, uv);\n            // Compute height\n            const u = (Math.abs(uv.x * uvScale.x + (uvOffset.x % 1)) * (heightMapWidth - 1)) % heightMapWidth | 0;\n            const v = (Math.abs(uv.y * uvScale.y + (uvOffset.y % 1)) * (heightMapHeight - 1)) % heightMapHeight | 0;\n            const pos = (u + v * heightMapWidth) * 4;\n            const r = buffer[pos] / 255.0;\n            const g = buffer[pos + 1] / 255.0;\n            const b = buffer[pos + 2] / 255.0;\n            const gradient = r * 0.3 + g * 0.59 + b * 0.11;\n            normal.normalize();\n            normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);\n            position = position.add(normal);\n            position.toArray(positions, index);\n        }\n        VertexData.ComputeNormals(positions, this.getIndices(), normals);\n        if (forceUpdate) {\n            this.setVerticesData(VertexBuffer.PositionKind, positions);\n            this.setVerticesData(VertexBuffer.NormalKind, normals);\n            this.setVerticesData(VertexBuffer.UVKind, uvs);\n        }\n        else {\n            this.updateVerticesData(VertexBuffer.PositionKind, positions);\n            this.updateVerticesData(VertexBuffer.NormalKind, normals);\n        }\n        return this;\n    }\n    /**\n     * Modify the mesh to get a flat shading rendering.\n     * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.\n     * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.\n     * @returns current mesh\n     */\n    convertToFlatShadedMesh() {\n        const kinds = this.getVerticesDataKinds();\n        const vbs = {};\n        const data = {};\n        const newdata = {};\n        let updatableNormals = false;\n        let kindIndex;\n        let kind;\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n            kind = kinds[kindIndex];\n            const vertexBuffer = this.getVertexBuffer(kind);\n            // Check data consistency\n            const vertexData = vertexBuffer.getData();\n            if (vertexData instanceof Array || vertexData instanceof Float32Array) {\n                if (vertexData.length === 0) {\n                    continue;\n                }\n            }\n            if (kind === VertexBuffer.NormalKind) {\n                updatableNormals = vertexBuffer.isUpdatable();\n                kinds.splice(kindIndex, 1);\n                kindIndex--;\n                continue;\n            }\n            vbs[kind] = vertexBuffer;\n            data[kind] = this.getVerticesData(kind);\n            newdata[kind] = [];\n        }\n        // Save previous submeshes\n        const previousSubmeshes = this.subMeshes.slice(0);\n        const indices = this.getIndices();\n        const totalIndices = this.getTotalIndices();\n        // Generating unique vertices per face\n        let index;\n        for (index = 0; index < totalIndices; index++) {\n            const vertexIndex = indices[index];\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n                kind = kinds[kindIndex];\n                if (!vbs[kind]) {\n                    continue;\n                }\n                const stride = vbs[kind].getStrideSize();\n                for (let offset = 0; offset < stride; offset++) {\n                    newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n                }\n            }\n        }\n        // Updating faces & normal\n        const normals = [];\n        const positions = newdata[VertexBuffer.PositionKind];\n        const useRightHandedSystem = this.getScene().useRightHandedSystem;\n        let flipNormalGeneration;\n        if (useRightHandedSystem) {\n            flipNormalGeneration = this.overrideMaterialSideOrientation === 1;\n        }\n        else {\n            flipNormalGeneration = this.overrideMaterialSideOrientation === 0;\n        }\n        for (index = 0; index < totalIndices; index += 3) {\n            indices[index] = index;\n            indices[index + 1] = index + 1;\n            indices[index + 2] = index + 2;\n            const p1 = Vector3.FromArray(positions, index * 3);\n            const p2 = Vector3.FromArray(positions, (index + 1) * 3);\n            const p3 = Vector3.FromArray(positions, (index + 2) * 3);\n            const p1p2 = p1.subtract(p2);\n            const p3p2 = p3.subtract(p2);\n            const normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));\n            if (flipNormalGeneration) {\n                normal.scaleInPlace(-1);\n            }\n            // Store same normals for every vertex\n            for (let localIndex = 0; localIndex < 3; localIndex++) {\n                normals.push(normal.x);\n                normals.push(normal.y);\n                normals.push(normal.z);\n            }\n        }\n        this.setIndices(indices);\n        this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);\n        // Updating vertex buffers\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n            kind = kinds[kindIndex];\n            if (!newdata[kind]) {\n                continue;\n            }\n            this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\n        }\n        // Updating submeshes\n        this.releaseSubMeshes();\n        for (let submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n            const previousOne = previousSubmeshes[submeshIndex];\n            SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n        }\n        this.synchronizeInstances();\n        return this;\n    }\n    /**\n     * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.\n     * In other words, more vertices, no more indices and a single bigger VBO.\n     * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.\n     * @returns current mesh\n     */\n    convertToUnIndexedMesh() {\n        const kinds = this.getVerticesDataKinds();\n        const vbs = {};\n        const data = {};\n        const newdata = {};\n        let kindIndex;\n        let kind;\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n            kind = kinds[kindIndex];\n            const vertexBuffer = this.getVertexBuffer(kind);\n            vbs[kind] = vertexBuffer;\n            data[kind] = vbs[kind].getData();\n            newdata[kind] = [];\n        }\n        // Save previous submeshes\n        const previousSubmeshes = this.subMeshes.slice(0);\n        const indices = this.getIndices();\n        const totalIndices = this.getTotalIndices();\n        // Generating unique vertices per face\n        let index;\n        for (index = 0; index < totalIndices; index++) {\n            const vertexIndex = indices[index];\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n                kind = kinds[kindIndex];\n                const stride = vbs[kind].getStrideSize();\n                for (let offset = 0; offset < stride; offset++) {\n                    newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n                }\n            }\n        }\n        // Updating indices\n        for (index = 0; index < totalIndices; index += 3) {\n            indices[index] = index;\n            indices[index + 1] = index + 1;\n            indices[index + 2] = index + 2;\n        }\n        this.setIndices(indices);\n        // Updating vertex buffers\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n            kind = kinds[kindIndex];\n            this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable(), vbs[kind].getStrideSize());\n        }\n        // Updating submeshes\n        this.releaseSubMeshes();\n        for (let submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n            const previousOne = previousSubmeshes[submeshIndex];\n            SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n        }\n        this._unIndexed = true;\n        this.synchronizeInstances();\n        return this;\n    }\n    /**\n     * Inverses facet orientations.\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     * @param flipNormals will also inverts the normals\n     * @returns current mesh\n     */\n    flipFaces(flipNormals = false) {\n        const vertex_data = VertexData.ExtractFromMesh(this);\n        let i;\n        if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {\n            for (i = 0; i < vertex_data.normals.length; i++) {\n                vertex_data.normals[i] *= -1;\n            }\n        }\n        if (vertex_data.indices) {\n            let temp;\n            for (i = 0; i < vertex_data.indices.length; i += 3) {\n                // reassign indices\n                temp = vertex_data.indices[i + 1];\n                vertex_data.indices[i + 1] = vertex_data.indices[i + 2];\n                vertex_data.indices[i + 2] = temp;\n            }\n        }\n        vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n        return this;\n    }\n    /**\n     * Increase the number of facets and hence vertices in a mesh\n     * Vertex normals are interpolated from existing vertex normals\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     * @param numberPerEdge the number of new vertices to add to each edge of a facet, optional default 1\n     */\n    increaseVertices(numberPerEdge = 1) {\n        const vertex_data = VertexData.ExtractFromMesh(this);\n        const currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;\n        const positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;\n        const uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;\n        const normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;\n        if (!currentIndices || !positions) {\n            Logger.Warn(\"Couldn't increase number of vertices : VertexData must contain at least indices and positions\");\n        }\n        else {\n            vertex_data.indices = currentIndices;\n            vertex_data.positions = positions;\n            if (uvs) {\n                vertex_data.uvs = uvs;\n            }\n            if (normals) {\n                vertex_data.normals = normals;\n            }\n            const segments = numberPerEdge + 1; //segments per current facet edge, become sides of new facets\n            const tempIndices = new Array();\n            for (let i = 0; i < segments + 1; i++) {\n                tempIndices[i] = new Array();\n            }\n            let a; //vertex index of one end of a side\n            let b; //vertex index of other end of the side\n            const deltaPosition = new Vector3(0, 0, 0);\n            const deltaNormal = new Vector3(0, 0, 0);\n            const deltaUV = new Vector2(0, 0);\n            const indices = new Array();\n            const vertexIndex = new Array();\n            const side = new Array();\n            let len;\n            let positionPtr = positions.length;\n            let uvPtr;\n            if (uvs) {\n                uvPtr = uvs.length;\n            }\n            let normalsPtr;\n            if (normals) {\n                normalsPtr = normals.length;\n            }\n            for (let i = 0; i < currentIndices.length; i += 3) {\n                vertexIndex[0] = currentIndices[i];\n                vertexIndex[1] = currentIndices[i + 1];\n                vertexIndex[2] = currentIndices[i + 2];\n                for (let j = 0; j < 3; j++) {\n                    a = vertexIndex[j];\n                    b = vertexIndex[(j + 1) % 3];\n                    if (side[a] === undefined && side[b] === undefined) {\n                        side[a] = new Array();\n                        side[b] = new Array();\n                    }\n                    else {\n                        if (side[a] === undefined) {\n                            side[a] = new Array();\n                        }\n                        if (side[b] === undefined) {\n                            side[b] = new Array();\n                        }\n                    }\n                    if (side[a][b] === undefined && side[b][a] === undefined) {\n                        side[a][b] = [];\n                        deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;\n                        deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;\n                        deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;\n                        if (normals) {\n                            deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;\n                            deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;\n                            deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;\n                        }\n                        if (uvs) {\n                            deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;\n                            deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;\n                        }\n                        side[a][b].push(a);\n                        for (let k = 1; k < segments; k++) {\n                            side[a][b].push(positions.length / 3);\n                            positions[positionPtr++] = positions[3 * a] + k * deltaPosition.x;\n                            positions[positionPtr++] = positions[3 * a + 1] + k * deltaPosition.y;\n                            positions[positionPtr++] = positions[3 * a + 2] + k * deltaPosition.z;\n                            if (normals) {\n                                normals[normalsPtr++] = normals[3 * a] + k * deltaNormal.x;\n                                normals[normalsPtr++] = normals[3 * a + 1] + k * deltaNormal.y;\n                                normals[normalsPtr++] = normals[3 * a + 2] + k * deltaNormal.z;\n                            }\n                            if (uvs) {\n                                uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;\n                                uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;\n                            }\n                        }\n                        side[a][b].push(b);\n                        side[b][a] = new Array();\n                        len = side[a][b].length;\n                        for (let idx = 0; idx < len; idx++) {\n                            side[b][a][idx] = side[a][b][len - 1 - idx];\n                        }\n                    }\n                }\n                //Calculate positions, normals and uvs of new internal vertices\n                tempIndices[0][0] = currentIndices[i];\n                tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];\n                tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];\n                for (let k = 2; k < segments; k++) {\n                    tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];\n                    tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];\n                    deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;\n                    deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;\n                    deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;\n                    if (normals) {\n                        deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;\n                        deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;\n                        deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;\n                    }\n                    if (uvs) {\n                        deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;\n                        deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;\n                    }\n                    for (let j = 1; j < k; j++) {\n                        tempIndices[k][j] = positions.length / 3;\n                        positions[positionPtr++] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;\n                        positions[positionPtr++] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;\n                        positions[positionPtr++] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;\n                        if (normals) {\n                            normals[normalsPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;\n                            normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;\n                            normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;\n                        }\n                        if (uvs) {\n                            uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;\n                            uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;\n                        }\n                    }\n                }\n                tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];\n                // reform indices\n                indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);\n                for (let k = 1; k < segments; k++) {\n                    let j;\n                    for (j = 0; j < k; j++) {\n                        indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\n                        indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);\n                    }\n                    indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\n                }\n            }\n            vertex_data.indices = indices;\n            vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n        }\n    }\n    /**\n     * Force adjacent facets to share vertices and remove any facets that have all vertices in a line\n     * This will undo any application of covertToFlatShadedMesh\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     */\n    forceSharedVertices() {\n        const vertex_data = VertexData.ExtractFromMesh(this);\n        const currentUVs = vertex_data.uvs;\n        const currentIndices = vertex_data.indices;\n        const currentPositions = vertex_data.positions;\n        const currentColors = vertex_data.colors;\n        const currentMatrixIndices = vertex_data.matricesIndices;\n        const currentMatrixWeights = vertex_data.matricesWeights;\n        const currentMatrixIndicesExtra = vertex_data.matricesIndicesExtra;\n        const currentMatrixWeightsExtra = vertex_data.matricesWeightsExtra;\n        if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {\n            Logger.Warn(\"VertexData contains empty entries\");\n        }\n        else {\n            const positions = new Array();\n            const indices = new Array();\n            const uvs = new Array();\n            const colors = new Array();\n            const matrixIndices = new Array();\n            const matrixWeights = new Array();\n            const matrixIndicesExtra = new Array();\n            const matrixWeightsExtra = new Array();\n            let pstring = new Array(); //lists facet vertex positions (a,b,c) as string \"a|b|c\"\n            let indexPtr = 0; // pointer to next available index value\n            const uniquePositions = {}; // unique vertex positions\n            let ptr; // pointer to element in uniquePositions\n            let facet;\n            for (let i = 0; i < currentIndices.length; i += 3) {\n                facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]]; //facet vertex indices\n                pstring = new Array();\n                for (let j = 0; j < 3; j++) {\n                    pstring[j] = \"\";\n                    for (let k = 0; k < 3; k++) {\n                        //small values make 0\n                        if (Math.abs(currentPositions[3 * facet[j] + k]) < 0.00000001) {\n                            currentPositions[3 * facet[j] + k] = 0;\n                        }\n                        pstring[j] += currentPositions[3 * facet[j] + k] + \"|\";\n                    }\n                }\n                //check facet vertices to see that none are repeated\n                // do not process any facet that has a repeated vertex, ie is a line\n                if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {\n                    //for each facet position check if already listed in uniquePositions\n                    // if not listed add to uniquePositions and set index pointer\n                    // if listed use its index in uniquePositions and new index pointer\n                    for (let j = 0; j < 3; j++) {\n                        ptr = uniquePositions[pstring[j]];\n                        if (ptr === undefined) {\n                            uniquePositions[pstring[j]] = indexPtr;\n                            ptr = indexPtr++;\n                            //not listed so add individual x, y, z coordinates to positions\n                            for (let k = 0; k < 3; k++) {\n                                positions.push(currentPositions[3 * facet[j] + k]);\n                            }\n                            if (currentColors !== null && currentColors !== void 0) {\n                                for (let k = 0; k < 4; k++) {\n                                    colors.push(currentColors[4 * facet[j] + k]);\n                                }\n                            }\n                            if (currentUVs !== null && currentUVs !== void 0) {\n                                for (let k = 0; k < 2; k++) {\n                                    uvs.push(currentUVs[2 * facet[j] + k]);\n                                }\n                            }\n                            if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {\n                                for (let k = 0; k < 4; k++) {\n                                    matrixIndices.push(currentMatrixIndices[4 * facet[j] + k]);\n                                }\n                            }\n                            if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n                                for (let k = 0; k < 4; k++) {\n                                    matrixWeights.push(currentMatrixWeights[4 * facet[j] + k]);\n                                }\n                            }\n                            if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {\n                                for (let k = 0; k < 4; k++) {\n                                    matrixIndicesExtra.push(currentMatrixIndicesExtra[4 * facet[j] + k]);\n                                }\n                            }\n                            if (currentMatrixWeightsExtra !== null && currentMatrixWeightsExtra !== void 0) {\n                                for (let k = 0; k < 4; k++) {\n                                    matrixWeightsExtra.push(currentMatrixWeightsExtra[4 * facet[j] + k]);\n                                }\n                            }\n                        }\n                        // add new index pointer to indices array\n                        indices.push(ptr);\n                    }\n                }\n            }\n            const normals = new Array();\n            VertexData.ComputeNormals(positions, indices, normals);\n            //create new vertex data object and update\n            vertex_data.positions = positions;\n            vertex_data.indices = indices;\n            vertex_data.normals = normals;\n            if (currentUVs !== null && currentUVs !== void 0) {\n                vertex_data.uvs = uvs;\n            }\n            if (currentColors !== null && currentColors !== void 0) {\n                vertex_data.colors = colors;\n            }\n            if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {\n                vertex_data.matricesIndices = matrixIndices;\n            }\n            if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n                vertex_data.matricesWeights = matrixWeights;\n            }\n            if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {\n                vertex_data.matricesIndicesExtra = matrixIndicesExtra;\n            }\n            if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n                vertex_data.matricesWeightsExtra = matrixWeightsExtra;\n            }\n            vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n        }\n    }\n    // Instances\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/naming-convention\n    static _instancedMeshFactory(name, mesh) {\n        throw _WarnImport(\"InstancedMesh\");\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static _PhysicsImpostorParser(scene, physicObject, jsonObject) {\n        throw _WarnImport(\"PhysicsImpostor\");\n    }\n    /**\n     * Creates a new InstancedMesh object from the mesh model.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n     * @param name defines the name of the new instance\n     * @returns a new InstancedMesh\n     */\n    createInstance(name) {\n        return Mesh._instancedMeshFactory(name, this);\n    }\n    /**\n     * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.\n     * After this call, all the mesh instances have the same submeshes than the current mesh.\n     * @returns the current mesh\n     */\n    synchronizeInstances() {\n        for (let instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {\n            const instance = this.instances[instanceIndex];\n            instance._syncSubMeshes();\n        }\n        return this;\n    }\n    /**\n     * Optimization of the mesh's indices, in case a mesh has duplicated vertices.\n     * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.\n     * This should be used together with the simplification to avoid disappearing triangles.\n     * @param successCallback an optional success callback to be called after the optimization finished.\n     * @returns the current mesh\n     */\n    optimizeIndices(successCallback) {\n        const indices = this.getIndices();\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\n        if (!positions || !indices) {\n            return this;\n        }\n        const vectorPositions = new Array();\n        for (let pos = 0; pos < positions.length; pos = pos + 3) {\n            vectorPositions.push(Vector3.FromArray(positions, pos));\n        }\n        const dupes = new Array();\n        AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, (iteration) => {\n            const realPos = vectorPositions.length - 1 - iteration;\n            const testedPosition = vectorPositions[realPos];\n            for (let j = 0; j < realPos; ++j) {\n                const againstPosition = vectorPositions[j];\n                if (testedPosition.equals(againstPosition)) {\n                    dupes[realPos] = j;\n                    break;\n                }\n            }\n        }, () => {\n            for (let i = 0; i < indices.length; ++i) {\n                indices[i] = dupes[indices[i]] || indices[i];\n            }\n            //indices are now reordered\n            const originalSubMeshes = this.subMeshes.slice(0);\n            this.setIndices(indices);\n            this.subMeshes = originalSubMeshes;\n            if (successCallback) {\n                successCallback(this);\n            }\n        });\n        return this;\n    }\n    /**\n     * Serialize current mesh\n     * @param serializationObject defines the object which will receive the serialization data\n     */\n    serialize(serializationObject = {}) {\n        serializationObject.name = this.name;\n        serializationObject.id = this.id;\n        serializationObject.uniqueId = this.uniqueId;\n        serializationObject.type = this.getClassName();\n        if (Tags && Tags.HasTags(this)) {\n            serializationObject.tags = Tags.GetTags(this);\n        }\n        serializationObject.position = this.position.asArray();\n        if (this.rotationQuaternion) {\n            serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();\n        }\n        else if (this.rotation) {\n            serializationObject.rotation = this.rotation.asArray();\n        }\n        serializationObject.scaling = this.scaling.asArray();\n        if (this._postMultiplyPivotMatrix) {\n            serializationObject.pivotMatrix = this.getPivotMatrix().asArray();\n        }\n        else {\n            serializationObject.localMatrix = this.getPivotMatrix().asArray();\n        }\n        serializationObject.isEnabled = this.isEnabled(false);\n        serializationObject.isVisible = this.isVisible;\n        serializationObject.infiniteDistance = this.infiniteDistance;\n        serializationObject.pickable = this.isPickable;\n        serializationObject.receiveShadows = this.receiveShadows;\n        serializationObject.billboardMode = this.billboardMode;\n        serializationObject.visibility = this.visibility;\n        serializationObject.checkCollisions = this.checkCollisions;\n        serializationObject.isBlocker = this.isBlocker;\n        serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;\n        // Parent\n        if (this.parent) {\n            this.parent._serializeAsParent(serializationObject);\n        }\n        // Geometry\n        serializationObject.isUnIndexed = this.isUnIndexed;\n        const geometry = this._geometry;\n        if (geometry && this.subMeshes) {\n            serializationObject.geometryUniqueId = geometry.uniqueId;\n            serializationObject.geometryId = geometry.id;\n            // SubMeshes\n            serializationObject.subMeshes = [];\n            for (let subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {\n                const subMesh = this.subMeshes[subIndex];\n                serializationObject.subMeshes.push({\n                    materialIndex: subMesh.materialIndex,\n                    verticesStart: subMesh.verticesStart,\n                    verticesCount: subMesh.verticesCount,\n                    indexStart: subMesh.indexStart,\n                    indexCount: subMesh.indexCount,\n                });\n            }\n        }\n        // Material\n        if (this.material) {\n            if (!this.material.doNotSerialize) {\n                serializationObject.materialUniqueId = this.material.uniqueId;\n                serializationObject.materialId = this.material.id; // back compat\n            }\n        }\n        else {\n            this.material = null;\n            serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;\n            serializationObject.materialId = this._scene.defaultMaterial.id; // back compat\n        }\n        // Morph targets\n        if (this.morphTargetManager) {\n            serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;\n        }\n        // Skeleton\n        if (this.skeleton) {\n            serializationObject.skeletonId = this.skeleton.id;\n            serializationObject.numBoneInfluencers = this.numBoneInfluencers;\n        }\n        // Physics\n        //TODO implement correct serialization for physics impostors.\n        if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n            const impostor = this.getPhysicsImpostor();\n            if (impostor) {\n                serializationObject.physicsMass = impostor.getParam(\"mass\");\n                serializationObject.physicsFriction = impostor.getParam(\"friction\");\n                serializationObject.physicsRestitution = impostor.getParam(\"mass\");\n                serializationObject.physicsImpostor = impostor.type;\n            }\n        }\n        // Metadata\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        // Instances\n        serializationObject.instances = [];\n        for (let index = 0; index < this.instances.length; index++) {\n            const instance = this.instances[index];\n            if (instance.doNotSerialize) {\n                continue;\n            }\n            const serializationInstance = {\n                name: instance.name,\n                id: instance.id,\n                isEnabled: instance.isEnabled(false),\n                isVisible: instance.isVisible,\n                isPickable: instance.isPickable,\n                checkCollisions: instance.checkCollisions,\n                position: instance.position.asArray(),\n                scaling: instance.scaling.asArray(),\n            };\n            if (instance.parent) {\n                instance.parent._serializeAsParent(serializationInstance);\n            }\n            if (instance.rotationQuaternion) {\n                serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();\n            }\n            else if (instance.rotation) {\n                serializationInstance.rotation = instance.rotation.asArray();\n            }\n            // Physics\n            //TODO implement correct serialization for physics impostors.\n            if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n                const impostor = instance.getPhysicsImpostor();\n                if (impostor) {\n                    serializationInstance.physicsMass = impostor.getParam(\"mass\");\n                    serializationInstance.physicsFriction = impostor.getParam(\"friction\");\n                    serializationInstance.physicsRestitution = impostor.getParam(\"mass\");\n                    serializationInstance.physicsImpostor = impostor.type;\n                }\n            }\n            // Metadata\n            if (instance.metadata) {\n                serializationInstance.metadata = instance.metadata;\n            }\n            // Action Manager\n            if (instance.actionManager) {\n                serializationInstance.actions = instance.actionManager.serialize(instance.name);\n            }\n            serializationObject.instances.push(serializationInstance);\n            // Animations\n            SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);\n            serializationInstance.ranges = instance.serializeAnimationRanges();\n        }\n        // Thin instances\n        if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {\n            serializationObject.thinInstances = {\n                instancesCount: this._thinInstanceDataStorage.instancesCount,\n                matrixData: Array.from(this._thinInstanceDataStorage.matrixData),\n                matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,\n                enablePicking: this.thinInstanceEnablePicking,\n            };\n            if (this._userThinInstanceBuffersStorage) {\n                const userThinInstance = {\n                    data: {},\n                    sizes: {},\n                    strides: {},\n                };\n                for (const kind in this._userThinInstanceBuffersStorage.data) {\n                    userThinInstance.data[kind] = Array.from(this._userThinInstanceBuffersStorage.data[kind]);\n                    userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];\n                    userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];\n                }\n                serializationObject.thinInstances.userThinInstance = userThinInstance;\n            }\n        }\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n        serializationObject.ranges = this.serializeAnimationRanges();\n        // Layer mask\n        serializationObject.layerMask = this.layerMask;\n        // Alpha\n        serializationObject.alphaIndex = this.alphaIndex;\n        serializationObject.hasVertexAlpha = this.hasVertexAlpha;\n        // Overlay\n        serializationObject.overlayAlpha = this.overlayAlpha;\n        serializationObject.overlayColor = this.overlayColor.asArray();\n        serializationObject.renderOverlay = this.renderOverlay;\n        // Fog\n        serializationObject.applyFog = this.applyFog;\n        // Action Manager\n        if (this.actionManager) {\n            serializationObject.actions = this.actionManager.serialize(this.name);\n        }\n        return serializationObject;\n    }\n    /** @internal */\n    _syncGeometryWithMorphTargetManager() {\n        if (!this.geometry) {\n            return;\n        }\n        this._markSubMeshesAsAttributesDirty();\n        const morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;\n        if (morphTargetManager && morphTargetManager.vertexCount) {\n            if (morphTargetManager.vertexCount !== this.getTotalVertices()) {\n                Logger.Error(\"Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.\");\n                this.morphTargetManager = null;\n                return;\n            }\n            if (morphTargetManager.isUsingTextureForTargets) {\n                return;\n            }\n            for (let index = 0; index < morphTargetManager.numInfluencers; index++) {\n                const morphTarget = morphTargetManager.getActiveTarget(index);\n                const positions = morphTarget.getPositions();\n                if (!positions) {\n                    Logger.Error(\"Invalid morph target. Target must have positions.\");\n                    return;\n                }\n                this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);\n                const normals = morphTarget.getNormals();\n                if (normals) {\n                    this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);\n                }\n                const tangents = morphTarget.getTangents();\n                if (tangents) {\n                    this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);\n                }\n                const uvs = morphTarget.getUVs();\n                if (uvs) {\n                    this.geometry.setVerticesData(VertexBuffer.UVKind + \"_\" + index, uvs, false, 2);\n                }\n            }\n        }\n        else {\n            let index = 0;\n            // Positions\n            while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {\n                this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {\n                    this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);\n                }\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {\n                    this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);\n                }\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {\n                    this.geometry.removeVerticesData(VertexBuffer.UVKind + \"_\" + index);\n                }\n                index++;\n            }\n        }\n    }\n    /**\n     * Returns a new Mesh object parsed from the source provided.\n     * @param parsedMesh is the source\n     * @param scene defines the hosting scene\n     * @param rootUrl is the root URL to prefix the `delayLoadingFile` property with\n     * @returns a new Mesh\n     */\n    static Parse(parsedMesh, scene, rootUrl) {\n        let mesh;\n        if (parsedMesh.type && parsedMesh.type === \"LinesMesh\") {\n            mesh = Mesh._LinesMeshParser(parsedMesh, scene);\n        }\n        else if (parsedMesh.type && parsedMesh.type === \"GroundMesh\") {\n            mesh = Mesh._GroundMeshParser(parsedMesh, scene);\n        }\n        else if (parsedMesh.type && parsedMesh.type === \"GoldbergMesh\") {\n            mesh = Mesh._GoldbergMeshParser(parsedMesh, scene);\n        }\n        else if (parsedMesh.type && parsedMesh.type === \"GreasedLineMesh\") {\n            mesh = Mesh._GreasedLineMeshParser(parsedMesh, scene);\n        }\n        else {\n            mesh = new Mesh(parsedMesh.name, scene);\n        }\n        mesh.id = parsedMesh.id;\n        mesh._waitingParsedUniqueId = parsedMesh.uniqueId;\n        if (Tags) {\n            Tags.AddTagsTo(mesh, parsedMesh.tags);\n        }\n        mesh.position = Vector3.FromArray(parsedMesh.position);\n        if (parsedMesh.metadata !== undefined) {\n            mesh.metadata = parsedMesh.metadata;\n        }\n        if (parsedMesh.rotationQuaternion) {\n            mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);\n        }\n        else if (parsedMesh.rotation) {\n            mesh.rotation = Vector3.FromArray(parsedMesh.rotation);\n        }\n        mesh.scaling = Vector3.FromArray(parsedMesh.scaling);\n        if (parsedMesh.localMatrix) {\n            mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));\n        }\n        else if (parsedMesh.pivotMatrix) {\n            mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));\n        }\n        mesh.setEnabled(parsedMesh.isEnabled);\n        mesh.isVisible = parsedMesh.isVisible;\n        mesh.infiniteDistance = parsedMesh.infiniteDistance;\n        mesh.showBoundingBox = parsedMesh.showBoundingBox;\n        mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;\n        if (parsedMesh.applyFog !== undefined) {\n            mesh.applyFog = parsedMesh.applyFog;\n        }\n        if (parsedMesh.pickable !== undefined) {\n            mesh.isPickable = parsedMesh.pickable;\n        }\n        if (parsedMesh.alphaIndex !== undefined) {\n            mesh.alphaIndex = parsedMesh.alphaIndex;\n        }\n        mesh.receiveShadows = parsedMesh.receiveShadows;\n        if (parsedMesh.billboardMode !== undefined) {\n            mesh.billboardMode = parsedMesh.billboardMode;\n        }\n        if (parsedMesh.visibility !== undefined) {\n            mesh.visibility = parsedMesh.visibility;\n        }\n        mesh.checkCollisions = parsedMesh.checkCollisions;\n        mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;\n        if (parsedMesh.isBlocker !== undefined) {\n            mesh.isBlocker = parsedMesh.isBlocker;\n        }\n        mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;\n        // freezeWorldMatrix\n        if (parsedMesh.freezeWorldMatrix) {\n            mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;\n        }\n        // Parent\n        if (parsedMesh.parentId !== undefined) {\n            mesh._waitingParentId = parsedMesh.parentId;\n        }\n        if (parsedMesh.parentInstanceIndex !== undefined) {\n            mesh._waitingParentInstanceIndex = parsedMesh.parentInstanceIndex;\n        }\n        // Actions\n        if (parsedMesh.actions !== undefined) {\n            mesh._waitingData.actions = parsedMesh.actions;\n        }\n        // Overlay\n        if (parsedMesh.overlayAlpha !== undefined) {\n            mesh.overlayAlpha = parsedMesh.overlayAlpha;\n        }\n        if (parsedMesh.overlayColor !== undefined) {\n            mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);\n        }\n        if (parsedMesh.renderOverlay !== undefined) {\n            mesh.renderOverlay = parsedMesh.renderOverlay;\n        }\n        // Geometry\n        mesh.isUnIndexed = !!parsedMesh.isUnIndexed;\n        mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;\n        if (parsedMesh.delayLoadingFile) {\n            mesh.delayLoadState = 4;\n            mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;\n            mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));\n            if (parsedMesh._binaryInfo) {\n                mesh._binaryInfo = parsedMesh._binaryInfo;\n            }\n            mesh._delayInfo = [];\n            if (parsedMesh.hasUVs) {\n                mesh._delayInfo.push(VertexBuffer.UVKind);\n            }\n            if (parsedMesh.hasUVs2) {\n                mesh._delayInfo.push(VertexBuffer.UV2Kind);\n            }\n            if (parsedMesh.hasUVs3) {\n                mesh._delayInfo.push(VertexBuffer.UV3Kind);\n            }\n            if (parsedMesh.hasUVs4) {\n                mesh._delayInfo.push(VertexBuffer.UV4Kind);\n            }\n            if (parsedMesh.hasUVs5) {\n                mesh._delayInfo.push(VertexBuffer.UV5Kind);\n            }\n            if (parsedMesh.hasUVs6) {\n                mesh._delayInfo.push(VertexBuffer.UV6Kind);\n            }\n            if (parsedMesh.hasColors) {\n                mesh._delayInfo.push(VertexBuffer.ColorKind);\n            }\n            if (parsedMesh.hasMatricesIndices) {\n                mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n            }\n            if (parsedMesh.hasMatricesWeights) {\n                mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n            }\n            mesh._delayLoadingFunction = Geometry._ImportGeometry;\n            if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {\n                mesh._checkDelayState();\n            }\n        }\n        else {\n            Geometry._ImportGeometry(parsedMesh, mesh);\n        }\n        // Material\n        if (parsedMesh.materialUniqueId) {\n            mesh._waitingMaterialId = parsedMesh.materialUniqueId;\n        }\n        else if (parsedMesh.materialId) {\n            mesh._waitingMaterialId = parsedMesh.materialId;\n        }\n        // Morph targets\n        if (parsedMesh.morphTargetManagerId > -1) {\n            mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);\n        }\n        // Skeleton\n        if (parsedMesh.skeletonId !== undefined && parsedMesh.skeletonId !== null) {\n            mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);\n            if (parsedMesh.numBoneInfluencers) {\n                mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;\n            }\n        }\n        // Animations\n        if (parsedMesh.animations) {\n            for (let animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {\n                const parsedAnimation = parsedMesh.animations[animationIndex];\n                const internalClass = GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    mesh.animations.push(internalClass.Parse(parsedAnimation));\n                }\n            }\n            Node.ParseAnimationRanges(mesh, parsedMesh, scene);\n        }\n        if (parsedMesh.autoAnimate) {\n            scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1.0);\n        }\n        // Layer Mask\n        if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {\n            mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));\n        }\n        else {\n            mesh.layerMask = 0x0fffffff;\n        }\n        // Physics\n        if (parsedMesh.physicsImpostor) {\n            Mesh._PhysicsImpostorParser(scene, mesh, parsedMesh);\n        }\n        // Levels\n        if (parsedMesh.lodMeshIds) {\n            mesh._waitingData.lods = {\n                ids: parsedMesh.lodMeshIds,\n                distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,\n                coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null,\n            };\n        }\n        // Instances\n        if (parsedMesh.instances) {\n            for (let index = 0; index < parsedMesh.instances.length; index++) {\n                const parsedInstance = parsedMesh.instances[index];\n                const instance = mesh.createInstance(parsedInstance.name);\n                if (parsedInstance.id) {\n                    instance.id = parsedInstance.id;\n                }\n                if (Tags) {\n                    if (parsedInstance.tags) {\n                        Tags.AddTagsTo(instance, parsedInstance.tags);\n                    }\n                    else {\n                        Tags.AddTagsTo(instance, parsedMesh.tags);\n                    }\n                }\n                instance.position = Vector3.FromArray(parsedInstance.position);\n                if (parsedInstance.metadata !== undefined) {\n                    instance.metadata = parsedInstance.metadata;\n                }\n                if (parsedInstance.parentId !== undefined) {\n                    instance._waitingParentId = parsedInstance.parentId;\n                }\n                if (parsedInstance.parentInstanceIndex !== undefined) {\n                    instance._waitingParentInstanceIndex = parsedInstance.parentInstanceIndex;\n                }\n                if (parsedInstance.isEnabled !== undefined && parsedInstance.isEnabled !== null) {\n                    instance.setEnabled(parsedInstance.isEnabled);\n                }\n                if (parsedInstance.isVisible !== undefined && parsedInstance.isVisible !== null) {\n                    instance.isVisible = parsedInstance.isVisible;\n                }\n                if (parsedInstance.isPickable !== undefined && parsedInstance.isPickable !== null) {\n                    instance.isPickable = parsedInstance.isPickable;\n                }\n                if (parsedInstance.rotationQuaternion) {\n                    instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);\n                }\n                else if (parsedInstance.rotation) {\n                    instance.rotation = Vector3.FromArray(parsedInstance.rotation);\n                }\n                instance.scaling = Vector3.FromArray(parsedInstance.scaling);\n                if (parsedInstance.checkCollisions != undefined && parsedInstance.checkCollisions != null) {\n                    instance.checkCollisions = parsedInstance.checkCollisions;\n                }\n                if (parsedInstance.pickable != undefined && parsedInstance.pickable != null) {\n                    instance.isPickable = parsedInstance.pickable;\n                }\n                if (parsedInstance.showBoundingBox != undefined && parsedInstance.showBoundingBox != null) {\n                    instance.showBoundingBox = parsedInstance.showBoundingBox;\n                }\n                if (parsedInstance.showSubMeshesBoundingBox != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n                    instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;\n                }\n                if (parsedInstance.alphaIndex != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n                    instance.alphaIndex = parsedInstance.alphaIndex;\n                }\n                // Physics\n                if (parsedInstance.physicsImpostor) {\n                    Mesh._PhysicsImpostorParser(scene, instance, parsedInstance);\n                }\n                // Actions\n                if (parsedInstance.actions !== undefined) {\n                    instance._waitingData.actions = parsedInstance.actions;\n                }\n                // Animation\n                if (parsedInstance.animations) {\n                    for (let animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {\n                        const parsedAnimation = parsedInstance.animations[animationIndex];\n                        const internalClass = GetClass(\"BABYLON.Animation\");\n                        if (internalClass) {\n                            instance.animations.push(internalClass.Parse(parsedAnimation));\n                        }\n                    }\n                    Node.ParseAnimationRanges(instance, parsedInstance, scene);\n                    if (parsedInstance.autoAnimate) {\n                        scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1.0);\n                    }\n                }\n            }\n        }\n        // Thin instances\n        if (parsedMesh.thinInstances) {\n            const thinInstances = parsedMesh.thinInstances;\n            mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;\n            if (thinInstances.matrixData) {\n                mesh.thinInstanceSetBuffer(\"matrix\", new Float32Array(thinInstances.matrixData), 16, false);\n                mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n                mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;\n            }\n            else {\n                mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n            }\n            if (parsedMesh.thinInstances.userThinInstance) {\n                const userThinInstance = parsedMesh.thinInstances.userThinInstance;\n                for (const kind in userThinInstance.data) {\n                    mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);\n                    mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];\n                }\n            }\n        }\n        return mesh;\n    }\n    // Skeletons\n    /**\n     * Prepare internal position array for software CPU skinning\n     * @returns original positions used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh\n     */\n    setPositionsForCPUSkinning() {\n        const internalDataInfo = this._internalMeshDataInfo;\n        if (!internalDataInfo._sourcePositions) {\n            const source = this.getVerticesData(VertexBuffer.PositionKind);\n            if (!source) {\n                return internalDataInfo._sourcePositions;\n            }\n            internalDataInfo._sourcePositions = new Float32Array(source);\n            if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n                this.setVerticesData(VertexBuffer.PositionKind, source, true);\n            }\n        }\n        return internalDataInfo._sourcePositions;\n    }\n    /**\n     * Prepare internal normal array for software CPU skinning\n     * @returns original normals used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh.\n     */\n    setNormalsForCPUSkinning() {\n        const internalDataInfo = this._internalMeshDataInfo;\n        if (!internalDataInfo._sourceNormals) {\n            const source = this.getVerticesData(VertexBuffer.NormalKind);\n            if (!source) {\n                return internalDataInfo._sourceNormals;\n            }\n            internalDataInfo._sourceNormals = new Float32Array(source);\n            if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n                this.setVerticesData(VertexBuffer.NormalKind, source, true);\n            }\n        }\n        return internalDataInfo._sourceNormals;\n    }\n    /**\n     * Updates the vertex buffer by applying transformation from the bones\n     * @param skeleton defines the skeleton to apply to current mesh\n     * @returns the current mesh\n     */\n    applySkeleton(skeleton) {\n        if (!this.geometry) {\n            return this;\n        }\n        if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {\n            return this;\n        }\n        this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n            return this;\n        }\n        if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n            return this;\n        }\n        if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n            return this;\n        }\n        const hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);\n        const internalDataInfo = this._internalMeshDataInfo;\n        if (!internalDataInfo._sourcePositions) {\n            const submeshes = this.subMeshes.slice();\n            this.setPositionsForCPUSkinning();\n            this.subMeshes = submeshes;\n        }\n        if (hasNormals && !internalDataInfo._sourceNormals) {\n            this.setNormalsForCPUSkinning();\n        }\n        // positionsData checks for not being Float32Array will only pass at most once\n        let positionsData = this.getVerticesData(VertexBuffer.PositionKind);\n        if (!positionsData) {\n            return this;\n        }\n        if (!(positionsData instanceof Float32Array)) {\n            positionsData = new Float32Array(positionsData);\n        }\n        // normalsData checks for not being Float32Array will only pass at most once\n        let normalsData = this.getVerticesData(VertexBuffer.NormalKind);\n        if (hasNormals) {\n            if (!normalsData) {\n                return this;\n            }\n            if (!(normalsData instanceof Float32Array)) {\n                normalsData = new Float32Array(normalsData);\n            }\n        }\n        const matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n        const matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n        if (!matricesWeightsData || !matricesIndicesData) {\n            return this;\n        }\n        const needExtras = this.numBoneInfluencers > 4;\n        const matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n        const matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n        const skeletonMatrices = skeleton.getTransformMatrices(this);\n        const tempVector3 = Vector3.Zero();\n        const finalMatrix = new Matrix();\n        const tempMatrix = new Matrix();\n        let matWeightIdx = 0;\n        let inf;\n        for (let index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {\n            let weight;\n            for (inf = 0; inf < 4; inf++) {\n                weight = matricesWeightsData[matWeightIdx + inf];\n                if (weight > 0) {\n                    Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                    finalMatrix.addToSelf(tempMatrix);\n                }\n            }\n            if (needExtras) {\n                for (inf = 0; inf < 4; inf++) {\n                    weight = matricesWeightsExtraData[matWeightIdx + inf];\n                    if (weight > 0) {\n                        Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                        finalMatrix.addToSelf(tempMatrix);\n                    }\n                }\n            }\n            Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);\n            tempVector3.toArray(positionsData, index);\n            if (hasNormals) {\n                Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);\n                tempVector3.toArray(normalsData, index);\n            }\n            finalMatrix.reset();\n        }\n        this.updateVerticesData(VertexBuffer.PositionKind, positionsData);\n        if (hasNormals) {\n            this.updateVerticesData(VertexBuffer.NormalKind, normalsData);\n        }\n        return this;\n    }\n    // Tools\n    /**\n     * Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates\n     * @param meshes defines the list of meshes to scan\n     * @returns an object `{min:` Vector3`, max:` Vector3`}`\n     */\n    static MinMax(meshes) {\n        let minVector = null;\n        let maxVector = null;\n        meshes.forEach(function (mesh) {\n            const boundingInfo = mesh.getBoundingInfo();\n            const boundingBox = boundingInfo.boundingBox;\n            if (!minVector || !maxVector) {\n                minVector = boundingBox.minimumWorld;\n                maxVector = boundingBox.maximumWorld;\n            }\n            else {\n                minVector.minimizeInPlace(boundingBox.minimumWorld);\n                maxVector.maximizeInPlace(boundingBox.maximumWorld);\n            }\n        });\n        if (!minVector || !maxVector) {\n            return {\n                min: Vector3.Zero(),\n                max: Vector3.Zero(),\n            };\n        }\n        return {\n            min: minVector,\n            max: maxVector,\n        };\n    }\n    /**\n     * Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array\n     * @param meshesOrMinMaxVector could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object\n     * @returns a vector3\n     */\n    static Center(meshesOrMinMaxVector) {\n        const minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;\n        return Vector3.Center(minMaxVector.min, minMaxVector.max);\n    }\n    /**\n     * Merge the array of meshes into a single mesh for performance reasons.\n     * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.\n     * @param disposeSource when true (default), dispose of the vertices from the source meshes.\n     * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.\n     * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.\n     * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.\n     * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.\n     * @returns a new mesh\n     */\n    static MergeMeshes(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {\n        return runCoroutineSync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));\n    }\n    /**\n     * Merge the array of meshes into a single mesh for performance reasons.\n     * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.\n     * @param disposeSource when true (default), dispose of the vertices from the source meshes.\n     * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.\n     * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.\n     * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.\n     * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.\n     * @returns a new mesh\n     */\n    static MergeMeshesAsync(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {\n        return runCoroutineAsync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());\n    }\n    static *_MergeMeshesCoroutine(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, isAsync) {\n        // Remove any null/undefined entries from the mesh array\n        meshes = meshes.filter(Boolean);\n        if (meshes.length === 0) {\n            return null;\n        }\n        let index;\n        if (!allow32BitsIndices) {\n            let totalVertices = 0;\n            // Counting vertices\n            for (index = 0; index < meshes.length; index++) {\n                totalVertices += meshes[index].getTotalVertices();\n                if (totalVertices >= 65536) {\n                    Logger.Warn(\"Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices\");\n                    return null;\n                }\n            }\n        }\n        if (multiMultiMaterials) {\n            subdivideWithSubMeshes = false;\n        }\n        const materialArray = new Array();\n        const materialIndexArray = new Array();\n        // Merge\n        const indiceArray = new Array();\n        const currentOverrideMaterialSideOrientation = meshes[0].overrideMaterialSideOrientation;\n        for (index = 0; index < meshes.length; index++) {\n            const mesh = meshes[index];\n            if (mesh.isAnInstance) {\n                Logger.Warn(\"Cannot merge instance meshes.\");\n                return null;\n            }\n            if (currentOverrideMaterialSideOrientation !== mesh.overrideMaterialSideOrientation) {\n                Logger.Warn(\"Cannot merge meshes with different overrideMaterialSideOrientation values.\");\n                return null;\n            }\n            if (subdivideWithSubMeshes) {\n                indiceArray.push(mesh.getTotalIndices());\n            }\n            if (multiMultiMaterials) {\n                if (mesh.material) {\n                    const material = mesh.material;\n                    if (material instanceof MultiMaterial) {\n                        for (let matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {\n                            if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {\n                                materialArray.push(material.subMaterials[matIndex]);\n                            }\n                        }\n                        for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                            materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));\n                            indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n                        }\n                    }\n                    else {\n                        if (materialArray.indexOf(material) < 0) {\n                            materialArray.push(material);\n                        }\n                        for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                            materialIndexArray.push(materialArray.indexOf(material));\n                            indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n                        }\n                    }\n                }\n                else {\n                    for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                        materialIndexArray.push(0);\n                        indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n                    }\n                }\n            }\n        }\n        const source = meshes[0];\n        const getVertexDataFromMesh = (mesh) => {\n            const wm = mesh.computeWorldMatrix(true);\n            const vertexData = VertexData.ExtractFromMesh(mesh, false, false);\n            return { vertexData, transform: wm };\n        };\n        const { vertexData: sourceVertexData, transform: sourceTransform } = getVertexDataFromMesh(source);\n        if (isAsync) {\n            yield;\n        }\n        const meshVertexDatas = new Array(meshes.length - 1);\n        for (let i = 1; i < meshes.length; i++) {\n            meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);\n            if (isAsync) {\n                yield;\n            }\n        }\n        const mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);\n        let mergeCoroutineStep = mergeCoroutine.next();\n        while (!mergeCoroutineStep.done) {\n            if (isAsync) {\n                yield;\n            }\n            mergeCoroutineStep = mergeCoroutine.next();\n        }\n        const vertexData = mergeCoroutineStep.value;\n        if (!meshSubclass) {\n            meshSubclass = new Mesh(source.name + \"_merged\", source.getScene());\n        }\n        const applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, undefined, isAsync);\n        let applyToCoroutineStep = applyToCoroutine.next();\n        while (!applyToCoroutineStep.done) {\n            if (isAsync) {\n                yield;\n            }\n            applyToCoroutineStep = applyToCoroutine.next();\n        }\n        // Setting properties\n        meshSubclass.checkCollisions = source.checkCollisions;\n        meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;\n        // Cleaning\n        if (disposeSource) {\n            for (index = 0; index < meshes.length; index++) {\n                meshes[index].dispose();\n            }\n        }\n        // Subdivide\n        if (subdivideWithSubMeshes || multiMultiMaterials) {\n            //-- removal of global submesh\n            meshSubclass.releaseSubMeshes();\n            index = 0;\n            let offset = 0;\n            //-- apply subdivision according to index table\n            while (index < indiceArray.length) {\n                SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, undefined, false);\n                offset += indiceArray[index];\n                index++;\n            }\n            for (const subMesh of meshSubclass.subMeshes) {\n                subMesh.refreshBoundingInfo();\n            }\n            meshSubclass.computeWorldMatrix(true);\n        }\n        if (multiMultiMaterials) {\n            const newMultiMaterial = new MultiMaterial(source.name + \"_merged\", source.getScene());\n            newMultiMaterial.subMaterials = materialArray;\n            for (let subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {\n                meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];\n            }\n            meshSubclass.material = newMultiMaterial;\n        }\n        else {\n            meshSubclass.material = source.material;\n        }\n        return meshSubclass;\n    }\n    /**\n     * @internal\n     */\n    addInstance(instance) {\n        instance._indexInSourceMeshInstanceArray = this.instances.length;\n        this.instances.push(instance);\n    }\n    /**\n     * @internal\n     */\n    removeInstance(instance) {\n        // Remove from mesh\n        const index = instance._indexInSourceMeshInstanceArray;\n        if (index != -1) {\n            if (index !== this.instances.length - 1) {\n                const last = this.instances[this.instances.length - 1];\n                this.instances[index] = last;\n                last._indexInSourceMeshInstanceArray = index;\n            }\n            instance._indexInSourceMeshInstanceArray = -1;\n            this.instances.pop();\n        }\n    }\n    /** @internal */\n    _shouldConvertRHS() {\n        return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;\n    }\n    /** @internal */\n    _getRenderingFillMode(fillMode) {\n        var _a;\n        const scene = this.getScene();\n        if (scene.forcePointsCloud)\n            return Material.PointFillMode;\n        if (scene.forceWireframe)\n            return Material.WireFrameFillMode;\n        return (_a = this.overrideRenderingFillMode) !== null && _a !== void 0 ? _a : fillMode;\n    }\n}\n// Consts\n/**\n * Mesh side orientation : usually the external or front surface\n */\nMesh.FRONTSIDE = VertexData.FRONTSIDE;\n/**\n * Mesh side orientation : usually the internal or back surface\n */\nMesh.BACKSIDE = VertexData.BACKSIDE;\n/**\n * Mesh side orientation : both internal and external or front and back surfaces\n */\nMesh.DOUBLESIDE = VertexData.DOUBLESIDE;\n/**\n * Mesh side orientation : by default, `FRONTSIDE`\n */\nMesh.DEFAULTSIDE = VertexData.DEFAULTSIDE;\n/**\n * Mesh cap setting : no cap\n */\nMesh.NO_CAP = 0;\n/**\n * Mesh cap setting : one cap at the beginning of the mesh\n */\nMesh.CAP_START = 1;\n/**\n * Mesh cap setting : one cap at the end of the mesh\n */\nMesh.CAP_END = 2;\n/**\n * Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh\n */\nMesh.CAP_ALL = 3;\n/**\n * Mesh pattern setting : no flip or rotate\n */\nMesh.NO_FLIP = 0;\n/**\n * Mesh pattern setting : flip (reflect in y axis) alternate tiles on each row or column\n */\nMesh.FLIP_TILE = 1;\n/**\n * Mesh pattern setting : rotate (180degs) alternate tiles on each row or column\n */\nMesh.ROTATE_TILE = 2;\n/**\n * Mesh pattern setting : flip (reflect in y axis) all tiles on alternate rows\n */\nMesh.FLIP_ROW = 3;\n/**\n * Mesh pattern setting : rotate (180degs) all tiles on alternate rows\n */\nMesh.ROTATE_ROW = 4;\n/**\n * Mesh pattern setting : flip and rotate alternate tiles on each row or column\n */\nMesh.FLIP_N_ROTATE_TILE = 5;\n/**\n * Mesh pattern setting : rotate pattern and rotate\n */\nMesh.FLIP_N_ROTATE_ROW = 6;\n/**\n * Mesh tile positioning : part tiles same on left/right or top/bottom\n */\nMesh.CENTER = 0;\n/**\n * Mesh tile positioning : part tiles on left\n */\nMesh.LEFT = 1;\n/**\n * Mesh tile positioning : part tiles on right\n */\nMesh.RIGHT = 2;\n/**\n * Mesh tile positioning : part tiles on top\n */\nMesh.TOP = 3;\n/**\n * Mesh tile positioning : part tiles on bottom\n */\nMesh.BOTTOM = 4;\n/**\n * Indicates that the instanced meshes should be sorted from back to front before rendering if their material is transparent\n */\nMesh.INSTANCEDMESH_SORT_TRANSPARENT = false;\n// Statics\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._GroundMeshParser = (parsedMesh, scene) => {\n    throw _WarnImport(\"GroundMesh\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._GoldbergMeshParser = (parsedMesh, scene) => {\n    throw _WarnImport(\"GoldbergMesh\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._LinesMeshParser = (parsedMesh, scene) => {\n    throw _WarnImport(\"LinesMesh\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._GreasedLineMeshParser = (parsedMesh, scene) => {\n    throw _WarnImport(\"GreasedLineMesh\");\n};\nRegisterClass(\"BABYLON.Mesh\", Mesh);\n/**\n * @internal\n */\nMesh.prototype.setMaterialByID = function (id) {\n    return this.setMaterialById(id);\n};\nMesh.CreateDisc =\n    Mesh.CreateDisc ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateBox =\n    Mesh.CreateBox ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateSphere =\n    Mesh.CreateSphere ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateCylinder =\n    Mesh.CreateCylinder ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateTorusKnot =\n    Mesh.CreateTorusKnot ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateTorus =\n    Mesh.CreateTorus ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreatePlane =\n    Mesh.CreatePlane ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateGround =\n    Mesh.CreateGround ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateTiledGround =\n    Mesh.CreateTiledGround ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateGroundFromHeightMap =\n    Mesh.CreateGroundFromHeightMap ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateTube =\n    Mesh.CreateTube ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreatePolyhedron =\n    Mesh.CreatePolyhedron ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateIcoSphere =\n    Mesh.CreateIcoSphere ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateDecal =\n    Mesh.CreateDecal ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateCapsule =\n    Mesh.CreateCapsule ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.ExtendToGoldberg =\n    Mesh.ExtendToGoldberg ||\n        (() => {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\n//# sourceMappingURL=mesh.js.map"],"names":["_CreationDataStorage","_InstanceDataStorage","constructor","this","visibleInstances","batchCache","_InstancesBatch","batchCacheReplacementModeInFrozenMode","instancesBufferSize","mustReturn","Array","renderSelf","hardwareInstancedRendering","_ThinInstanceDataStorage","instancesCount","matrixBuffer","previousMatrixBuffer","matrixBufferSize","matrixData","boundingVectors","worldMatrices","_InternalMeshDataInfo","_areNormalsFrozen","_source","meshMap","_preActivateId","_LODLevels","_useLODScreenCoverage","_effectiveMaterial","_forcedInstanceCount","_overrideRenderingFillMode","Mesh","static","orientation","FRONTSIDE","useLODScreenCoverage","_internalMeshDataInfo","value","_sortLODLevels","computeBonesUsingShaders","_internalAbstractMeshDataInfo","_computeBonesUsingShaders","_sourcePositions","setVerticesData","_sourceNormals","_markSubMeshesAsAttributesDirty","onBeforeRenderObservable","_onBeforeRenderObservable","onBeforeBindObservable","_onBeforeBindObservable","onAfterRenderObservable","_onAfterRenderObservable","onBetweenPassObservable","_onBetweenPassObservable","onBeforeDrawObservable","_onBeforeDrawObservable","onBeforeDraw","callback","_onBeforeDrawObserver","remove","add","hasInstances","instances","length","hasThinInstances","_a","_thinInstanceDataStorage","forcedInstanceCount","count","overrideRenderingFillMode","fillMode","source","cloneMeshMap","isUnIndexed","_unIndexed","worldMatrixInstancedBuffer","_instanceDataStorage","instancesData","previousWorldMatrixInstancedBuffer","instancesPreviousData","manualUpdateOfWorldMatrixInstancedBuffer","manualUpdate","manualUpdateOfPreviousWorldMatrixInstancedBuffer","previousManualUpdate","forceWorldMatrixInstancedBufferUpdate","forceMatrixUpdates","name","scene","parent","doNotCloneChildren","clonePhysicsImpostor","super","delayLoadState","_creationDataStorage","_geometry","_shouldGenerateFlatShading","_originalBuilderSideOrientation","DEFAULTSIDE","overrideMaterialSideOrientation","ignoreCameraMaxZ","getScene","_onBeforeDraw","isInstance","world","effectiveMaterial","_uniformBuffer","transferToEffect","bindOnlyWorldMatrix","applyToMesh","useClonedMeshMap","uniqueId","_ranges","ranges","Object","prototype","hasOwnProperty","call","createAnimationRange","from","to","metadata","clone","_internalMetadata","setEnabled","isEnabled","setPivotMatrix","getPivotMatrix","id","material","directDescendants","getDescendants","index","child","morphTargetManager","getPhysicsEngine","physicsEngine","getPluginVersion","impostor","getImpostorForPhysicsObject","physicsImpostor","physicsBody","particleSystems","system","emitter","skeleton","refreshBoundingInfo","computeWorldMatrix","getEngine","getCaps","instancedArrays","_onMeshReadyObserverAdded","observer","unregisterOnNextCall","isReady","onMeshReadyObservable","notifyObservers","_checkReadinessObserver","_scene","onClonedObservable","instantiateHierarchy","newParent","options","onNewNodeCreated","instance","getTotalVertices","doNotInstantiate","createInstance","position","scaling","rotationQuaternion","rotation","getChildTransformNodes","getClassName","sourceMesh","newSourcedMesh","_isMesh","toString","fullDetails","ret","_waitingParentId","animations","i","ib","getIndices","vb","getVerticesData","_unBindEffect","hasLODLevels","getLODLevels","sortingOrderFactor","sort","a","b","distanceOrScreenCoverage","addLODLevel","mesh","_masterMesh","level","push","getLODLevelAtDistance","distance","internalDataInfo","removeLODLevel","splice","getLOD","camera","boundingSphere","bSphere","getBoundingInfo","distanceToCamera","mode","minZ","centerWorld","subtract","globalPosition","compareValue","compareSign","screenArea","meshArea","radiusWorld","Math","PI","onLODLevelSelection","_checkDelayState","_preActivate","_updateSubMeshesBoundingInfo","worldMatrixFromCache","geometry","undefined","kind","copyWhenShared","forceCopy","bypassInstanceData","_b","data","_userInstancedBuffersStorage","vertexBuffers","getFloatData","meshes","getVertexBuffer","isVerticesDataPresent","_delayInfo","indexOf","isVertexBufferUpdatable","buffer","isUpdatable","getVerticesDataKinds","result","forEach","kinds","getTotalIndices","isBlocked","completeCheck","forceInstanceSupport","_c","_d","_e","_f","_g","subMeshes","engine","mat","defaultMaterial","_storeEffectOnSubMeshes","subMesh","getMaterial","isReadyForSubMesh","currentRenderPassId","light","lightSources","generators","getShadowGenerators","iterator","values","key","next","done","generator","getShadowMap","renderList","renderPassIds","p","needAlphaBlendingForMesh","lod","areNormalsFrozen","freezeNormals","unfreezeNormals","overridenInstanceCount","sceneRenderId","getRenderId","_preActivateForIntermediateRendering","renderId","intermediateDefaultRenderId","_registerInstanceForRenderId","defaultRenderId","selfDefaultRenderId","_renderId","previousRenderId","isFrozen","_afterComputeWorldMatrix","doNotSyncBoundingInfo","thinInstanceRefreshBoundingInfo","_postActivate","edgesShareWithInstances","edgesRenderer","_renderingGroup","_edgesRenderers","pushNoDuplicate","customInstances","getWorldMatrix","applySkeleton","applyMorph","hasBoundingInfo","isLocked","bias","boundingBias","_refreshBoundingInfo","_getPositionData","_createGlobalSubMesh","force","totalVertices","totalIndices","needToRecreate","submesh","indexStart","indexCount","verticesStart","verticesCount","releaseSubMeshes","subdivide","subdivisionSize","offset","synchronizeInstances","updatable","stride","vertexData","set","removeVerticesData","markVerticesDataAsUpdatable","setVerticesBuffer","disposeExistingBuffer","updateVerticesData","updateExtends","makeItUnique","makeGeometryUnique","updateMeshPositions","positionFunction","computeNormals","positions","indices","normals","oldGeometry","copy","releaseForMesh","setIndices","updateIndices","gpuMemoryOnly","toLeftHanded","_bind","effect","allowInstancedRendering","indexToBind","isUsingTextureForTargets","_getRenderingFillMode","_getLinesIndexBuffer","getIndexBuffer","vertexArrayObjects","_draw","getVertexBuffers","drawArraysType","drawElementsType","_linesIndexCount","registerBeforeRender","func","unregisterBeforeRender","removeCallback","registerAfterRender","unregisterAfterRender","_getInstancesRenderList","subMeshId","isReplacementMode","previousBatch","isInIntermediateRendering","_isInIntermediateRendering","onlyForInstances","_onlyForInstancesIntermediate","_onlyForInstances","isVisible","currentRenderId","_renderWithInstances","batch","_id","visibleInstanceCount","instanceStorage","currentInstancesBufferSize","instancesBuffer","instancesPreviousBuffer","bufferSize","Float32Array","needsPreviousWorldMatrices","needUpdateBuffer","masterMeshPreviousWorldMatrix","copyToArray","copyFrom","INSTANCEDMESH_SORT_TRANSPARENT","activeCamera","getRenderingMesh","cameraPosition","instanceIndex","instanceMesh","_distanceToCamera","m1","m2","matrix","_previousWorldMatrix","dispose","strides","sizes","vertexArrayObject","createVertexBuffer","_invalidateInstanceVertexArrayObject","updateDirectly","_processInstancedBuffers","_activeIndices","addCount","_currentDrawContext","useInstancing","unbindInstanceAttributes","_renderWithThinInstances","previousMatrixData","_thinInstanceCreateMatrixBuffer","_processRendering","renderingMesh","instanceCount","visibleInstancesForSubMesh","_rebuild","_freeze","_unFreeze","render","enableAlphaMode","effectiveMeshReplacement","_isActiveIntermediate","_isActive","_checkOcclusionQuery","_occlusionDataStorage","forceRenderingWhenOccluded","oldCameraMaxZ","oldCamera","maxZ","updateTransformMatrix","getMesh","_actAsRegularMesh","instanceDataStorage","_wasPreviouslyReady","getEffect","drawWrapper","setAlphaMode","alphaMode","_drawWrapper","_getDrawWrapper","step","_beforeRenderingMeshStage","action","effectiveMesh","sideOrientation","backFaceCulling","mainDeterminant","_getWorldMatrixDeterminant","reverse","_preBind","forceDepthWrite","setDepthWrite","bindForSubMesh","bind","separateCullingPass","setState","zOffset","cullBackFaces","stencil","zOffsetUnits","unbind","_afterRenderingMeshStage","performancePriority","cleanMatrixWeights","_normalizeSkinWeightsAndExtra","_normalizeSkinFourWeights","matricesWeights","numWeights","t","recip","matricesWeightsExtra","validateSkinning","skinned","valid","report","numberNotSorted","missingWeights","maxUsedWeights","numberNotNormalized","numInfluences","usedWeightCounts","lastWeight","usedWeights","d","tolerance","abs","numBones","bones","matricesIndices","matricesIndicesExtra","numBadBoneIndices","load","_queueLoad","addPendingData","getBinaryData","delayLoadingFile","ArrayBuffer","_delayLoadingFunction","JSON","parse","_syncSubMeshes","removePendingData","offlineProvider","isInFrustum","frustumPlanes","setMaterialById","materials","multiMaterials","getAnimatables","results","bakeTransformIntoVertices","transform","submeshes","_resetPointsArrayCache","temp","toArray","normalize","determinant","flipFaces","bakeCurrentTransformIntoVertices","bakeIndependentlyOfChildren","resetLocalMatrix","_positions","_generatePointsArray","doNotRecurse","disposeMaterialAndTextures","clear","abstractMesh","_disposeInstanceSpecificData","_disposeThinInstanceSpecificData","applyDisplacementMap","url","minHeight","maxHeight","onSuccess","uvOffset","uvScale","forceUpdate","img","heightMapWidth","width","heightMapHeight","height","context","createCanvas","getContext","drawImage","getImageData","applyDisplacementMapFromBuffer","uvs","normal","uv","pos","x","y","gradient","scaleInPlace","convertToFlatShadedMesh","vbs","newdata","kindIndex","updatableNormals","vertexBuffer","getData","previousSubmeshes","slice","vertexIndex","getStrideSize","flipNormalGeneration","useRightHandedSystem","p1","p2","p3","p1p2","p3p2","localIndex","z","submeshIndex","previousOne","materialIndex","convertToUnIndexedMesh","flipNormals","vertex_data","increaseVertices","numberPerEdge","currentIndices","isArray","segments","tempIndices","deltaPosition","deltaNormal","deltaUV","side","len","uvPtr","normalsPtr","positionPtr","j","k","idx","forceSharedVertices","currentUVs","currentPositions","currentColors","colors","currentMatrixIndices","currentMatrixWeights","currentMatrixIndicesExtra","currentMatrixWeightsExtra","matrixIndices","matrixWeights","matrixIndicesExtra","matrixWeightsExtra","pstring","indexPtr","uniquePositions","ptr","facet","physicObject","jsonObject","_instancedMeshFactory","optimizeIndices","successCallback","vectorPositions","dupes","iteration","realPos","testedPosition","againstPosition","equals","originalSubMeshes","serialize","serializationObject","type","tags","asArray","_postMultiplyPivotMatrix","pivotMatrix","localMatrix","infiniteDistance","pickable","isPickable","receiveShadows","billboardMode","visibility","checkCollisions","isBlocker","_serializeAsParent","geometryUniqueId","geometryId","subIndex","doNotSerialize","materialUniqueId","materialId","morphTargetManagerId","skeletonId","numBoneInfluencers","_getComponent","getPhysicsImpostor","physicsMass","getParam","physicsFriction","physicsRestitution","serializationInstance","actionManager","actions","serializeAnimationRanges","thinInstances","enablePicking","thinInstanceEnablePicking","_userThinInstanceBuffersStorage","userThinInstance","layerMask","alphaIndex","hasVertexAlpha","overlayAlpha","overlayColor","renderOverlay","applyFog","_syncGeometryWithMorphTargetManager","_morphTargetManager","vertexCount","numInfluencers","morphTarget","getActiveTarget","getPositions","getNormals","tangents","getTangents","getUVs","parsedMesh","rootUrl","_LinesMeshParser","_GroundMeshParser","_GoldbergMeshParser","_GreasedLineMeshParser","_waitingParsedUniqueId","setPreTransformMatrix","showBoundingBox","showSubMeshesBoundingBox","useFlatShading","freezeWorldMatrix","_waitingData","parentId","parentInstanceIndex","_waitingParentInstanceIndex","buildBoundingInfo","boundingBoxMinimum","boundingBoxMaximum","_binaryInfo","hasUVs","hasUVs2","hasUVs3","hasUVs4","hasUVs5","hasUVs6","hasColors","hasMatricesIndices","hasMatricesWeights","_waitingMaterialId","getMorphTargetManagerById","getLastSkeletonById","animationIndex","parsedAnimation","internalClass","Parse","N","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","isNaN","parseInt","_PhysicsImpostorParser","lodMeshIds","lods","ids","distances","lodDistances","coverages","lodCoverages","parsedInstance","thinInstanceSetBuffer","setPositionsForCPUSkinning","setNormalsForCPUSkinning","_softwareSkinningFrameId","getFrameId","hasNormals","positionsData","normalsData","matricesIndicesData","matricesWeightsData","needExtras","matricesIndicesExtraData","matricesWeightsExtraData","skeletonMatrices","getTransformMatrices","tempVector3","finalMatrix","tempMatrix","inf","matWeightIdx","weight","floor","addToSelf","reset","minVector","maxVector","boundingBox","minimizeInPlace","minimumWorld","maximizeInPlace","maximumWorld","min","max","meshesOrMinMaxVector","minMaxVector","MinMax","disposeSource","allow32BitsIndices","meshSubclass","subdivideWithSubMeshes","multiMultiMaterials","_MergeMeshesCoroutine","isAsync","filter","Boolean","materialArray","materialIndexArray","indiceArray","currentOverrideMaterialSideOrientation","isAnInstance","matIndex","subMaterials","getVertexDataFromMesh","wm","sourceVertexData","sourceTransform","meshVertexDatas","mergeCoroutine","_mergeCoroutine","mergeCoroutineStep","applyToCoroutine","_applyToCoroutine","applyToCoroutineStep","newMultiMaterial","addInstance","_indexInSourceMeshInstanceArray","removeInstance","last","pop","_shouldConvertRHS","forcePointsCloud","forceWireframe","BACKSIDE","DOUBLESIDE","NO_CAP","CAP_START","CAP_END","CAP_ALL","NO_FLIP","FLIP_TILE","ROTATE_TILE","FLIP_ROW","ROTATE_ROW","FLIP_N_ROTATE_TILE","FLIP_N_ROTATE_ROW","CENTER","LEFT","RIGHT","TOP","BOTTOM","setMaterialByID","CreateDisc","Error","CreateBox","CreateSphere","CreateCylinder","CreateTorusKnot","CreateTorus","CreatePlane","CreateGround","CreateTiledGround","CreateGroundFromHeightMap","CreateTube","CreatePolyhedron","CreateIcoSphere","CreateDecal","CreateCapsule","ExtendToGoldberg"],"sourceRoot":""}